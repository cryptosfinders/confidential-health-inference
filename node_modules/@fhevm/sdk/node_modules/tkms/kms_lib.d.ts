/* tslint:disable */
/* eslint-disable */
export function public_sig_key_to_u8vec(pk: PublicSigKey): Uint8Array;
export function u8vec_to_public_sig_key(v: Uint8Array): PublicSigKey;
export function private_sig_key_to_u8vec(sk: PrivateSigKey): Uint8Array;
export function u8vec_to_private_sig_key(v: Uint8Array): PrivateSigKey;
/**
 * Instantiate a new client.
 *
 * * `server_addrs` - a list of KMS server EIP-55 addresses,
 * must be prefixed with "0x".
 *
 * * `client_address_hex` - the client (wallet) address in hex,
 * must be prefixed with "0x".
 *
 * * `fhe_parameter` - the parameter choice, which can be either `"test"` or `"default"`.
 * The "default" parameter choice is selected if no matching string is found.
 */
export function new_client(server_addrs: string[], client_address_hex: string, fhe_parameter: string): Client;
export function get_server_addrs(client: Client): string[];
export function get_client_secret_key(client: Client): PrivateSigKey | undefined;
export function get_client_address(client: Client): string;
export function cryptobox_keygen(): PrivateEncKey;
export function cryptobox_get_pk(sk: PrivateEncKey): PublicEncKey;
export function cryptobox_pk_to_u8vec(pk: PublicEncKey): Uint8Array;
export function cryptobox_sk_to_u8vec(sk: PrivateEncKey): Uint8Array;
export function u8vec_to_cryptobox_pk(v: Uint8Array): PublicEncKey;
export function u8vec_to_cryptobox_sk(v: Uint8Array): PrivateEncKey;
export function cryptobox_encrypt(msg: Uint8Array, their_pk: PublicEncKey, my_sk: PrivateEncKey): CryptoBoxCt;
export function cryptobox_decrypt(ct: CryptoBoxCt, my_sk: PrivateEncKey, their_pk: PublicEncKey): Uint8Array;
/**
 * Process the user_decryption response from JavaScript objects.
 * The returned result is a byte array representing a plaintext of any length,
 * postprocessing is returned to turn it into an integer.
 *
 * * `client` - client that wants to perform user_decryption.
 *
 * * `request` - the initial user_decryption request JS object.
 * It can be set to null if `verify` is false.
 * Otherwise the caller needs to give the following JS object.
 * Note that `client_address` and `eip712_verifying_contract` follow EIP-55.
 * The signature field is not needed.
 * ```
 * {
 *   signature: undefined,
 *   client_address: '0x17853A630aAe15AED549B2B874de08B73C0F59c5',
 *   enc_key: '2000000000000000df2fcacb774f03187f3802a27259f45c06d33cefa68d9c53426b15ad531aa822',
 *   ciphertext_handles: [ '0748b542afe2353c86cb707e3d21044b0be1fd18efc7cbaa6a415af055bfb358' ]
 *   eip712_verifying_contract: '0x66f9664f97F2b50F62D13eA064982f936dE76657'
 * }
 * ```
 *
 * * `eip712_domain` - the EIP-712 domain JS object.
 * It can be set to null if `verify` is false.
 * Otherwise the caller needs to give the following JS object.
 * Note that `salt` is optional and `verifying_contract` follows EIP-55,
 * additionally, `chain_id` is an array of u8.
 * ```
 * {
 *   name: 'Authorization token',
 *   version: '1',
 *   chain_id: [
 *     70, 31, 0, 0, 0, 0, 0, 0, 0,
 *      0,  0, 0, 0, 0, 0, 0, 0, 0,
 *      0,  0, 0, 0, 0, 0, 0, 0, 0,
 *      0,  0, 0, 0, 0
 *   ],
 *   verifying_contract: '0x66f9664f97F2b50F62D13eA064982f936dE76657',
 *   salt: []
 * }
 * ```
 *
 * * `agg_resp` - the response JS object from the gateway.
 * It has two fields like so, both are hex encoded byte arrays.
 * ```
 * [
 *   {
 *     signature: '69e7e040cab157aa819015b321c012dccb1545ffefd325b359b492653f0347517e28e66c572cdc299e259024329859ff9fcb0096e1ce072af0b6e1ca1fe25ec6',
 *     payload: '0100000029...'
 *   }
 * ]
 * ```
 *
 * * `enc_pk` - The ephemeral public key.
 *
 * * `enc_sk` - The ephemeral secret key.
 *
 * * `verify` - Whether to perform signature verification for the response.
 * It is insecure if `verify = false`!
 */
export function process_user_decryption_resp_from_js(client: Client, request: any, eip712_domain: any, agg_resp: any, enc_pk: PublicEncKey, enc_sk: PrivateEncKey, verify: boolean): TypedPlaintext[];
/**
 * Process the user_decryption response from Rust objects.
 * Consider using [process_user_decryption_resp_from_js]
 * when using the JS API.
 * The result is a byte array representing a plaintext of any length.
 *
 * * `client` - client that wants to perform user_decryption.
 *
 * * `request` - the initial user_decryption request.
 * Must be given if `verify` is true.
 *
 * * `eip712_domain` - the EIP-712 domain.
 * Must be given if `verify` is true.
 *
 * * `agg_resp` - the vector of user_decryption responses.
 *
 * * `enc_pk` - The ephemeral public key.
 *
 * * `enc_sk` - The ephemeral secret key.
 *
 * * `verify` - Whether to perform signature verification for the response.
 * It is insecure if `verify = false`!
 */
export function process_user_decryption_resp(client: Client, request: ParsedUserDecryptionRequest | null | undefined, eip712_domain: Eip712DomainMsg | null | undefined, agg_resp: UserDecryptionResponse[], enc_pk: PublicEncKey, enc_sk: PrivateEncKey, verify: boolean): TypedPlaintext[];
export class CiphertextHandle {
  private constructor();
  free(): void;
}
/**
 * Core Client
 *
 * Simple client to interact with the KMS servers. This can be seen as a proof-of-concept
 * and reference code for validating the KMS. The logic supplied by the client will be
 * distributed across the aggregator/proxy and smart contracts.
 */
export class Client {
  private constructor();
  free(): void;
}
export class CryptoBoxCt {
  private constructor();
  free(): void;
}
/**
 * <https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator>
 * eventually chain_id, verifying_contract and salt will be parsed in to
 * solidity types
 */
export class Eip712DomainMsg {
  private constructor();
  free(): void;
  name: string;
  version: string;
  chain_id: Uint8Array;
  verifying_contract: string;
  get salt(): Uint8Array | undefined;
  set salt(value: Uint8Array | null | undefined);
}
/**
 * Validity of this struct is not checked.
 */
export class ParsedUserDecryptionRequest {
  private constructor();
  free(): void;
}
export class PrivateEncKey {
  private constructor();
  free(): void;
}
export class PrivateSigKey {
  private constructor();
  free(): void;
}
export class PublicEncKey {
  private constructor();
  free(): void;
}
export class PublicSigKey {
  private constructor();
  free(): void;
}
/**
 * Simple response to return a 32 Byte / 256 Bit ID, to be used to retrieve the
 * computed result later on. This string does NOT contain a `0x` prefix.
 */
export class RequestId {
  private constructor();
  free(): void;
  request_id: string;
}
export class TypedCiphertext {
  private constructor();
  free(): void;
  /**
   * The actual ciphertext to decrypt, taken directly from fhevm.
   */
  ciphertext: Uint8Array;
  /**
   * The type of plaintext encrypted. The type should match FheType from tfhe-rs:
   * <https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/high_level_api/mod.rs>
   */
  fhe_type: number;
  /**
   * The external handle of the ciphertext (the handle used in the copro).
   */
  external_handle: Uint8Array;
  /**
   * The ciphertext format, see CiphertextFormat documentation for details.
   * CiphertextFormat::default() is used if unspecified.
   */
  ciphertext_format: number;
}
export class TypedPlaintext {
  private constructor();
  free(): void;
  /**
   * The actual plaintext in bytes.
   */
  bytes: Uint8Array;
  /**
   * The type of plaintext encrypted. The type should match FheType from tfhe-rs:
   * <https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/high_level_api/mod.rs>
   */
  fhe_type: number;
}
export class TypedSigncryptedCiphertext {
  private constructor();
  free(): void;
  /**
   * The type of plaintext encrypted. The type should match FheType from tfhe-rs:
   * <https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/high_level_api/mod.rs>
   */
  fhe_type: number;
  /**
   * The signcrypted payload, using a hybrid encryption approach in
   * sign-then-encrypt.
   */
  signcrypted_ciphertext: Uint8Array;
  /**
   * The external handles that were originally in the request.
   */
  external_handle: Uint8Array;
  /**
   * The packing factor determines whether the decrypted plaintext
   * has a different way of packing compared to what is specified in the plaintext modulus.
   */
  packing_factor: number;
}
export class UserDecryptionRequest {
  private constructor();
  free(): void;
  /**
   * The 32 Byte / 256 Bit ID of the user decryption request, without `0x`
   * prefix. Future queries for the result must use this request ID.
   */
  get request_id(): RequestId | undefined;
  /**
   * The 32 Byte / 256 Bit ID of the user decryption request, without `0x`
   * prefix. Future queries for the result must use this request ID.
   */
  set request_id(value: RequestId | null | undefined);
  /**
   * The list of ciphertexts to decrypt for the user.
   */
  typed_ciphertexts: TypedCiphertext[];
  /**
   * The 32 Byte / 256 Bit key id to use for decryption. This is the request_id
   * used for key generation
   */
  get key_id(): RequestId | undefined;
  /**
   * The 32 Byte / 256 Bit key id to use for decryption. This is the request_id
   * used for key generation
   */
  set key_id(value: RequestId | null | undefined);
  /**
   * The client's (blockchain wallet) address,
   * encoded using EIP-55.
   */
  client_address: string;
  /**
   * Encoding of the user's public encryption key for this request.
   * Encoding using the default encoding of libsodium, i.e. the 32 bytes of a
   * Montgomery point.
   */
  enc_key: Uint8Array;
  get domain(): Eip712DomainMsg | undefined;
  set domain(value: Eip712DomainMsg | null | undefined);
}
export class UserDecryptionResponse {
  private constructor();
  free(): void;
  signature: Uint8Array;
  /**
   * This is the external signature created from the Eip712 domain
   * on the structure, where userDecryptedShare is bincode::serialize(&payload)
   * struct UserDecryptResponseVerification {
   *      bytes publicKey;
   *      uint256\[\] ctHandles;
   *      bytes userDecryptedShare;
   * }
   */
  external_signature: Uint8Array;
  /**
   * The actual \[UserDecryptionResponsePayload\].
   */
  get payload(): UserDecryptionResponsePayload | undefined;
  /**
   * The actual \[UserDecryptionResponsePayload\].
   */
  set payload(value: UserDecryptionResponsePayload | null | undefined);
}
export class UserDecryptionResponsePayload {
  private constructor();
  free(): void;
  /**
   * The server's signature verification key, Encoded using SEC1.
   * Needed to validate the response, but MUST also be linked to a list of
   * trusted keys.
   */
  verification_key: Uint8Array;
  /**
   * This is needed to ensure the response corresponds to the request.
   * It is the digest of UserDecryptionLinker hashed using EIP712
   * under the given domain in the request.
   */
  digest: Uint8Array;
  /**
   * The resulting signcrypted ciphertexts, each ciphertext
   * must be decrypted and then reconstructed with the other shares
   * to produce the final plaintext.
   */
  signcrypted_ciphertexts: TypedSigncryptedCiphertext[];
  /**
   * The ID of the MPC party doing the user decryption. Used for polynomial
   * reconstruction.
   */
  party_id: number;
  /**
   * The degree of the sharing scheme used.
   */
  degree: number;
}

export type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;

export interface InitOutput {
  readonly memory: WebAssembly.Memory;
  readonly __wbg_client_free: (a: number, b: number) => void;
  readonly __wbg_ciphertexthandle_free: (a: number, b: number) => void;
  readonly __wbg_parseduserdecryptionrequest_free: (a: number, b: number) => void;
  readonly public_sig_key_to_u8vec: (a: number) => [number, number];
  readonly u8vec_to_public_sig_key: (a: number, b: number) => [number, number, number];
  readonly private_sig_key_to_u8vec: (a: number) => [number, number, number, number];
  readonly u8vec_to_private_sig_key: (a: number, b: number) => [number, number, number];
  readonly new_client: (a: number, b: number, c: number, d: number, e: number, f: number) => [number, number, number];
  readonly get_server_addrs: (a: number) => [number, number];
  readonly get_client_secret_key: (a: number) => number;
  readonly get_client_address: (a: number) => [number, number];
  readonly __wbg_cryptoboxct_free: (a: number, b: number) => void;
  readonly cryptobox_keygen: () => number;
  readonly cryptobox_get_pk: (a: number) => number;
  readonly cryptobox_pk_to_u8vec: (a: number) => [number, number, number, number];
  readonly cryptobox_sk_to_u8vec: (a: number) => [number, number, number, number];
  readonly u8vec_to_cryptobox_pk: (a: number, b: number) => [number, number, number];
  readonly u8vec_to_cryptobox_sk: (a: number, b: number) => [number, number, number];
  readonly cryptobox_encrypt: (a: number, b: number, c: number, d: number) => number;
  readonly cryptobox_decrypt: (a: number, b: number, c: number) => [number, number];
  readonly process_user_decryption_resp_from_js: (a: number, b: any, c: any, d: any, e: number, f: number, g: number) => [number, number, number, number];
  readonly process_user_decryption_resp: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => [number, number, number, number];
  readonly __wbg_publicenckey_free: (a: number, b: number) => void;
  readonly __wbg_privateenckey_free: (a: number, b: number) => void;
  readonly __wbg_publicsigkey_free: (a: number, b: number) => void;
  readonly __wbg_privatesigkey_free: (a: number, b: number) => void;
  readonly __wbg_requestid_free: (a: number, b: number) => void;
  readonly __wbg_typedciphertext_free: (a: number, b: number) => void;
  readonly __wbg_get_typedciphertext_ciphertext: (a: number) => [number, number];
  readonly __wbg_get_typedciphertext_fhe_type: (a: number) => number;
  readonly __wbg_set_typedciphertext_fhe_type: (a: number, b: number) => void;
  readonly __wbg_get_typedciphertext_external_handle: (a: number) => [number, number];
  readonly __wbg_get_typedciphertext_ciphertext_format: (a: number) => number;
  readonly __wbg_set_typedciphertext_ciphertext_format: (a: number, b: number) => void;
  readonly __wbg_eip712domainmsg_free: (a: number, b: number) => void;
  readonly __wbg_get_eip712domainmsg_name: (a: number) => [number, number];
  readonly __wbg_set_eip712domainmsg_name: (a: number, b: number, c: number) => void;
  readonly __wbg_get_eip712domainmsg_version: (a: number) => [number, number];
  readonly __wbg_set_eip712domainmsg_version: (a: number, b: number, c: number) => void;
  readonly __wbg_get_eip712domainmsg_chain_id: (a: number) => [number, number];
  readonly __wbg_set_eip712domainmsg_chain_id: (a: number, b: number, c: number) => void;
  readonly __wbg_get_eip712domainmsg_verifying_contract: (a: number) => [number, number];
  readonly __wbg_set_eip712domainmsg_verifying_contract: (a: number, b: number, c: number) => void;
  readonly __wbg_get_eip712domainmsg_salt: (a: number) => [number, number];
  readonly __wbg_set_eip712domainmsg_salt: (a: number, b: number, c: number) => void;
  readonly __wbg_userdecryptionrequest_free: (a: number, b: number) => void;
  readonly __wbg_get_userdecryptionrequest_request_id: (a: number) => number;
  readonly __wbg_set_userdecryptionrequest_request_id: (a: number, b: number) => void;
  readonly __wbg_get_userdecryptionrequest_typed_ciphertexts: (a: number) => [number, number];
  readonly __wbg_set_userdecryptionrequest_typed_ciphertexts: (a: number, b: number, c: number) => void;
  readonly __wbg_get_userdecryptionrequest_key_id: (a: number) => number;
  readonly __wbg_set_userdecryptionrequest_key_id: (a: number, b: number) => void;
  readonly __wbg_get_userdecryptionrequest_domain: (a: number) => number;
  readonly __wbg_set_userdecryptionrequest_domain: (a: number, b: number) => void;
  readonly __wbg_userdecryptionresponse_free: (a: number, b: number) => void;
  readonly __wbg_get_userdecryptionresponse_payload: (a: number) => number;
  readonly __wbg_set_userdecryptionresponse_payload: (a: number, b: number) => void;
  readonly __wbg_userdecryptionresponsepayload_free: (a: number, b: number) => void;
  readonly __wbg_get_userdecryptionresponsepayload_signcrypted_ciphertexts: (a: number) => [number, number];
  readonly __wbg_set_userdecryptionresponsepayload_signcrypted_ciphertexts: (a: number, b: number, c: number) => void;
  readonly __wbg_get_userdecryptionresponsepayload_party_id: (a: number) => number;
  readonly __wbg_set_userdecryptionresponsepayload_party_id: (a: number, b: number) => void;
  readonly __wbg_get_userdecryptionresponsepayload_degree: (a: number) => number;
  readonly __wbg_set_userdecryptionresponsepayload_degree: (a: number, b: number) => void;
  readonly __wbg_typedplaintext_free: (a: number, b: number) => void;
  readonly __wbg_get_typedplaintext_fhe_type: (a: number) => number;
  readonly __wbg_set_typedplaintext_fhe_type: (a: number, b: number) => void;
  readonly __wbg_typedsigncryptedciphertext_free: (a: number, b: number) => void;
  readonly __wbg_get_requestid_request_id: (a: number) => [number, number];
  readonly __wbg_get_userdecryptionrequest_client_address: (a: number) => [number, number];
  readonly __wbg_get_typedsigncryptedciphertext_fhe_type: (a: number) => number;
  readonly __wbg_get_typedsigncryptedciphertext_packing_factor: (a: number) => number;
  readonly __wbg_set_typedciphertext_ciphertext: (a: number, b: number, c: number) => void;
  readonly __wbg_set_requestid_request_id: (a: number, b: number, c: number) => void;
  readonly __wbg_set_typedciphertext_external_handle: (a: number, b: number, c: number) => void;
  readonly __wbg_set_userdecryptionrequest_client_address: (a: number, b: number, c: number) => void;
  readonly __wbg_set_userdecryptionrequest_enc_key: (a: number, b: number, c: number) => void;
  readonly __wbg_set_userdecryptionresponse_signature: (a: number, b: number, c: number) => void;
  readonly __wbg_set_userdecryptionresponse_external_signature: (a: number, b: number, c: number) => void;
  readonly __wbg_set_userdecryptionresponsepayload_verification_key: (a: number, b: number, c: number) => void;
  readonly __wbg_set_userdecryptionresponsepayload_digest: (a: number, b: number, c: number) => void;
  readonly __wbg_set_typedplaintext_bytes: (a: number, b: number, c: number) => void;
  readonly __wbg_set_typedsigncryptedciphertext_signcrypted_ciphertext: (a: number, b: number, c: number) => void;
  readonly __wbg_set_typedsigncryptedciphertext_external_handle: (a: number, b: number, c: number) => void;
  readonly __wbg_get_userdecryptionrequest_enc_key: (a: number) => [number, number];
  readonly __wbg_get_userdecryptionresponse_signature: (a: number) => [number, number];
  readonly __wbg_get_userdecryptionresponse_external_signature: (a: number) => [number, number];
  readonly __wbg_get_userdecryptionresponsepayload_verification_key: (a: number) => [number, number];
  readonly __wbg_get_userdecryptionresponsepayload_digest: (a: number) => [number, number];
  readonly __wbg_get_typedplaintext_bytes: (a: number) => [number, number];
  readonly __wbg_get_typedsigncryptedciphertext_signcrypted_ciphertext: (a: number) => [number, number];
  readonly __wbg_get_typedsigncryptedciphertext_external_handle: (a: number) => [number, number];
  readonly __wbg_set_typedsigncryptedciphertext_fhe_type: (a: number, b: number) => void;
  readonly __wbg_set_typedsigncryptedciphertext_packing_factor: (a: number, b: number) => void;
  readonly __wbindgen_malloc: (a: number, b: number) => number;
  readonly __wbindgen_realloc: (a: number, b: number, c: number, d: number) => number;
  readonly __wbindgen_exn_store: (a: number) => void;
  readonly __externref_table_alloc: () => number;
  readonly __wbindgen_export_4: WebAssembly.Table;
  readonly __wbindgen_free: (a: number, b: number, c: number) => void;
  readonly __externref_table_dealloc: (a: number) => void;
  readonly __externref_drop_slice: (a: number, b: number) => void;
  readonly __wbindgen_start: () => void;
}

export type SyncInitInput = BufferSource | WebAssembly.Module;
/**
* Instantiates the given `module`, which can either be bytes or
* a precompiled `WebAssembly.Module`.
*
* @param {{ module: SyncInitInput }} module - Passing `SyncInitInput` directly is deprecated.
*
* @returns {InitOutput}
*/
export function initSync(module: { module: SyncInitInput } | SyncInitInput): InitOutput;

/**
* If `module_or_path` is {RequestInfo} or {URL}, makes a request and
* for everything else, calls `WebAssembly.instantiate` directly.
*
* @param {{ module_or_path: InitInput | Promise<InitInput> }} module_or_path - Passing `InitInput` directly is deprecated.
*
* @returns {Promise<InitOutput>}
*/
export default function __wbg_init (module_or_path?: { module_or_path: InitInput | Promise<InitInput> } | InitInput | Promise<InitInput>): Promise<InitOutput>;
