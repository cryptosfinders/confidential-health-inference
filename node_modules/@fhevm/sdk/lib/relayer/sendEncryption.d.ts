import { TfheCompactPublicKey, CompactPkeCrs } from 'node-tfhe';
import { EncryptedInput } from '../sdk/encrypt';
import { ENCRYPTION_TYPES } from '../sdk/encryptionTypes';
type EncryptionTypes = keyof typeof ENCRYPTION_TYPES;
export declare const currentCiphertextVersion: () => number;
export type FhevmRelayerInputProofResponse = {
    response: {
        handles: string[];
        signatures: string[];
    };
    status: string;
};
export type RelayerEncryptedInputInternal = RelayerEncryptedInput & {
    _input: EncryptedInput;
};
export type RelayerEncryptedInput = {
    addBool: (value: boolean | number | bigint) => RelayerEncryptedInput;
    add8: (value: number | bigint) => RelayerEncryptedInput;
    add16: (value: number | bigint) => RelayerEncryptedInput;
    add32: (value: number | bigint) => RelayerEncryptedInput;
    add64: (value: number | bigint) => RelayerEncryptedInput;
    add128: (value: number | bigint) => RelayerEncryptedInput;
    add256: (value: number | bigint) => RelayerEncryptedInput;
    addBytes64: (value: Uint8Array) => RelayerEncryptedInput;
    addBytes128: (value: Uint8Array) => RelayerEncryptedInput;
    addBytes256: (value: Uint8Array) => RelayerEncryptedInput;
    addAddress: (value: string) => RelayerEncryptedInput;
    getBits: () => EncryptionTypes[];
    encrypt: () => Promise<{
        handles: Uint8Array[];
        inputProof: Uint8Array;
    }>;
};
export type PublicParams<T = CompactPkeCrs> = {
    [key in EncryptionTypes]?: {
        publicParams: T;
        publicParamsId: string;
    };
};
export declare const createRelayerEncryptedInput: (aclContractAddress: string, verifyingContractAddressInputVerification: string, chainId: number, gatewayChainId: number, relayerUrl: string, tfheCompactPublicKey: TfheCompactPublicKey, publicParams: PublicParams, coprocessorSigners: string[], thresholdCoprocessorSigners: number) => (contractAddress: string, userAddress: string) => RelayerEncryptedInputInternal;
export {};
