var xm = Object.defineProperty;
var mw = (n) => {
  throw TypeError(n);
};
var Bm = (n, t, e) => t in n ? xm(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var $ = (n, t, e) => Bm(n, typeof t != "symbol" ? t + "" : t, e), gl = (n, t, e) => t.has(n) || mw("Cannot " + e);
var A = (n, t, e) => (gl(n, t, "read from private field"), e ? e.call(n) : t.get(n)), nt = (n, t, e) => t.has(n) ? mw("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), K = (n, t, e, r) => (gl(n, t, "write to private field"), r ? r.call(n, e) : t.set(n, e), e), At = (n, t, e) => (gl(n, t, "access private method"), e);
var Fc = (n, t, e, r) => ({
  set _(s) {
    K(n, t, s, e);
  },
  get _() {
    return A(n, t, r);
  }
});
const Ac = globalThis || void 0 || self;
var Wy = {}, Bf = {};
Bf.byteLength = Nm;
Bf.toByteArray = km;
Bf.fromByteArray = Um;
var Si = [], _r = [], Cm = typeof Uint8Array < "u" ? Uint8Array : Array, bl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var N_ = 0, Im = bl.length; N_ < Im; ++N_)
  Si[N_] = bl[N_], _r[bl.charCodeAt(N_)] = N_;
_r[45] = 62;
_r[95] = 63;
function Jy(n) {
  var t = n.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var e = n.indexOf("=");
  e === -1 && (e = t);
  var r = e === t ? 0 : 4 - e % 4;
  return [e, r];
}
function Nm(n) {
  var t = Jy(n), e = t[0], r = t[1];
  return (e + r) * 3 / 4 - r;
}
function Om(n, t, e) {
  return (t + e) * 3 / 4 - e;
}
function km(n) {
  var t, e = Jy(n), r = e[0], s = e[1], _ = new Cm(Om(n, r, s)), a = 0, c = s > 0 ? r - 4 : r, u;
  for (u = 0; u < c; u += 4)
    t = _r[n.charCodeAt(u)] << 18 | _r[n.charCodeAt(u + 1)] << 12 | _r[n.charCodeAt(u + 2)] << 6 | _r[n.charCodeAt(u + 3)], _[a++] = t >> 16 & 255, _[a++] = t >> 8 & 255, _[a++] = t & 255;
  return s === 2 && (t = _r[n.charCodeAt(u)] << 2 | _r[n.charCodeAt(u + 1)] >> 4, _[a++] = t & 255), s === 1 && (t = _r[n.charCodeAt(u)] << 10 | _r[n.charCodeAt(u + 1)] << 4 | _r[n.charCodeAt(u + 2)] >> 2, _[a++] = t >> 8 & 255, _[a++] = t & 255), _;
}
function Tm(n) {
  return Si[n >> 18 & 63] + Si[n >> 12 & 63] + Si[n >> 6 & 63] + Si[n & 63];
}
function Gm(n, t, e) {
  for (var r, s = [], _ = t; _ < e; _ += 3)
    r = (n[_] << 16 & 16711680) + (n[_ + 1] << 8 & 65280) + (n[_ + 2] & 255), s.push(Tm(r));
  return s.join("");
}
function Um(n) {
  for (var t, e = n.length, r = e % 3, s = [], _ = 16383, a = 0, c = e - r; a < c; a += _)
    s.push(Gm(n, a, a + _ > c ? c : a + _));
  return r === 1 ? (t = n[e - 1], s.push(
    Si[t >> 2] + Si[t << 4 & 63] + "=="
  )) : r === 2 && (t = (n[e - 2] << 8) + n[e - 1], s.push(
    Si[t >> 10] + Si[t >> 4 & 63] + Si[t << 2 & 63] + "="
  )), s.join("");
}
var Uh = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Uh.read = function(n, t, e, r, s) {
  var _, a, c = s * 8 - r - 1, u = (1 << c) - 1, l = u >> 1, f = -7, w = e ? s - 1 : 0, y = e ? -1 : 1, v = n[t + w];
  for (w += y, _ = v & (1 << -f) - 1, v >>= -f, f += c; f > 0; _ = _ * 256 + n[t + w], w += y, f -= 8)
    ;
  for (a = _ & (1 << -f) - 1, _ >>= -f, f += r; f > 0; a = a * 256 + n[t + w], w += y, f -= 8)
    ;
  if (_ === 0)
    _ = 1 - l;
  else {
    if (_ === u)
      return a ? NaN : (v ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, r), _ = _ - l;
  }
  return (v ? -1 : 1) * a * Math.pow(2, _ - r);
};
Uh.write = function(n, t, e, r, s, _) {
  var a, c, u, l = _ * 8 - s - 1, f = (1 << l) - 1, w = f >> 1, y = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, v = r ? 0 : _ - 1, x = r ? 1 : -1, C = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (c = isNaN(t) ? 1 : 0, a = f) : (a = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -a)) < 1 && (a--, u *= 2), a + w >= 1 ? t += y / u : t += y * Math.pow(2, 1 - w), t * u >= 2 && (a++, u /= 2), a + w >= f ? (c = 0, a = f) : a + w >= 1 ? (c = (t * u - 1) * Math.pow(2, s), a = a + w) : (c = t * Math.pow(2, w - 1) * Math.pow(2, s), a = 0)); s >= 8; n[e + v] = c & 255, v += x, c /= 256, s -= 8)
    ;
  for (a = a << s | c, l += s; l > 0; n[e + v] = a & 255, v += x, a /= 256, l -= 8)
    ;
  n[e + v - x] |= C * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(n) {
  const t = Bf, e = Uh, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  n.Buffer = f, n.SlowBuffer = G, n.INSPECT_MAX_BYTES = 50;
  const s = 2147483647;
  n.kMaxLength = s;
  const { Uint8Array: _, ArrayBuffer: a, SharedArrayBuffer: c } = globalThis;
  f.TYPED_ARRAY_SUPPORT = u(), !f.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function u() {
    try {
      const E = new _(1), p = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(p, _.prototype), Object.setPrototypeOf(E, p), E.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(f.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (f.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(f.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (f.isBuffer(this))
        return this.byteOffset;
    }
  });
  function l(E) {
    if (E > s)
      throw new RangeError('The value "' + E + '" is invalid for option "size"');
    const p = new _(E);
    return Object.setPrototypeOf(p, f.prototype), p;
  }
  function f(E, p, d) {
    if (typeof E == "number") {
      if (typeof p == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return x(E);
    }
    return w(E, p, d);
  }
  f.poolSize = 8192;
  function w(E, p, d) {
    if (typeof E == "string")
      return C(E, p);
    if (a.isView(E))
      return z(E);
    if (E == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof E
      );
    if (we(E, a) || E && we(E.buffer, a) || typeof c < "u" && (we(E, c) || E && we(E.buffer, c)))
      return M(E, p, d);
    if (typeof E == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const k = E.valueOf && E.valueOf();
    if (k != null && k !== E)
      return f.from(k, p, d);
    const q = N(E);
    if (q) return q;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof E[Symbol.toPrimitive] == "function")
      return f.from(E[Symbol.toPrimitive]("string"), p, d);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof E
    );
  }
  f.from = function(E, p, d) {
    return w(E, p, d);
  }, Object.setPrototypeOf(f.prototype, _.prototype), Object.setPrototypeOf(f, _);
  function y(E) {
    if (typeof E != "number")
      throw new TypeError('"size" argument must be of type number');
    if (E < 0)
      throw new RangeError('The value "' + E + '" is invalid for option "size"');
  }
  function v(E, p, d) {
    return y(E), E <= 0 ? l(E) : p !== void 0 ? typeof d == "string" ? l(E).fill(p, d) : l(E).fill(p) : l(E);
  }
  f.alloc = function(E, p, d) {
    return v(E, p, d);
  };
  function x(E) {
    return y(E), l(E < 0 ? 0 : I(E) | 0);
  }
  f.allocUnsafe = function(E) {
    return x(E);
  }, f.allocUnsafeSlow = function(E) {
    return x(E);
  };
  function C(E, p) {
    if ((typeof p != "string" || p === "") && (p = "utf8"), !f.isEncoding(p))
      throw new TypeError("Unknown encoding: " + p);
    const d = D(E, p) | 0;
    let k = l(d);
    const q = k.write(E, p);
    return q !== d && (k = k.slice(0, q)), k;
  }
  function U(E) {
    const p = E.length < 0 ? 0 : I(E.length) | 0, d = l(p);
    for (let k = 0; k < p; k += 1)
      d[k] = E[k] & 255;
    return d;
  }
  function z(E) {
    if (we(E, _)) {
      const p = new _(E);
      return M(p.buffer, p.byteOffset, p.byteLength);
    }
    return U(E);
  }
  function M(E, p, d) {
    if (p < 0 || E.byteLength < p)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (E.byteLength < p + (d || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let k;
    return p === void 0 && d === void 0 ? k = new _(E) : d === void 0 ? k = new _(E, p) : k = new _(E, p, d), Object.setPrototypeOf(k, f.prototype), k;
  }
  function N(E) {
    if (f.isBuffer(E)) {
      const p = I(E.length) | 0, d = l(p);
      return d.length === 0 || E.copy(d, 0, 0, p), d;
    }
    if (E.length !== void 0)
      return typeof E.length != "number" || xe(E.length) ? l(0) : U(E);
    if (E.type === "Buffer" && Array.isArray(E.data))
      return U(E.data);
  }
  function I(E) {
    if (E >= s)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
    return E | 0;
  }
  function G(E) {
    return +E != E && (E = 0), f.alloc(+E);
  }
  f.isBuffer = function(p) {
    return p != null && p._isBuffer === !0 && p !== f.prototype;
  }, f.compare = function(p, d) {
    if (we(p, _) && (p = f.from(p, p.offset, p.byteLength)), we(d, _) && (d = f.from(d, d.offset, d.byteLength)), !f.isBuffer(p) || !f.isBuffer(d))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (p === d) return 0;
    let k = p.length, q = d.length;
    for (let Z = 0, ct = Math.min(k, q); Z < ct; ++Z)
      if (p[Z] !== d[Z]) {
        k = p[Z], q = d[Z];
        break;
      }
    return k < q ? -1 : q < k ? 1 : 0;
  }, f.isEncoding = function(p) {
    switch (String(p).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, f.concat = function(p, d) {
    if (!Array.isArray(p))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (p.length === 0)
      return f.alloc(0);
    let k;
    if (d === void 0)
      for (d = 0, k = 0; k < p.length; ++k)
        d += p[k].length;
    const q = f.allocUnsafe(d);
    let Z = 0;
    for (k = 0; k < p.length; ++k) {
      let ct = p[k];
      if (we(ct, _))
        Z + ct.length > q.length ? (f.isBuffer(ct) || (ct = f.from(ct)), ct.copy(q, Z)) : _.prototype.set.call(
          q,
          ct,
          Z
        );
      else if (f.isBuffer(ct))
        ct.copy(q, Z);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Z += ct.length;
    }
    return q;
  };
  function D(E, p) {
    if (f.isBuffer(E))
      return E.length;
    if (a.isView(E) || we(E, a))
      return E.byteLength;
    if (typeof E != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof E
      );
    const d = E.length, k = arguments.length > 2 && arguments[2] === !0;
    if (!k && d === 0) return 0;
    let q = !1;
    for (; ; )
      switch (p) {
        case "ascii":
        case "latin1":
        case "binary":
          return d;
        case "utf8":
        case "utf-8":
          return ge(E).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return d * 2;
        case "hex":
          return d >>> 1;
        case "base64":
          return ie(E).length;
        default:
          if (q)
            return k ? -1 : ge(E).length;
          p = ("" + p).toLowerCase(), q = !0;
      }
  }
  f.byteLength = D;
  function j(E, p, d) {
    let k = !1;
    if ((p === void 0 || p < 0) && (p = 0), p > this.length || ((d === void 0 || d > this.length) && (d = this.length), d <= 0) || (d >>>= 0, p >>>= 0, d <= p))
      return "";
    for (E || (E = "utf8"); ; )
      switch (E) {
        case "hex":
          return J(this, p, d);
        case "utf8":
        case "utf-8":
          return Pt(this, p, d);
        case "ascii":
          return Nt(this, p, d);
        case "latin1":
        case "binary":
          return Ht(this, p, d);
        case "base64":
          return wt(this, p, d);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return st(this, p, d);
        default:
          if (k) throw new TypeError("Unknown encoding: " + E);
          E = (E + "").toLowerCase(), k = !0;
      }
  }
  f.prototype._isBuffer = !0;
  function L(E, p, d) {
    const k = E[p];
    E[p] = E[d], E[d] = k;
  }
  f.prototype.swap16 = function() {
    const p = this.length;
    if (p % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let d = 0; d < p; d += 2)
      L(this, d, d + 1);
    return this;
  }, f.prototype.swap32 = function() {
    const p = this.length;
    if (p % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let d = 0; d < p; d += 4)
      L(this, d, d + 3), L(this, d + 1, d + 2);
    return this;
  }, f.prototype.swap64 = function() {
    const p = this.length;
    if (p % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let d = 0; d < p; d += 8)
      L(this, d, d + 7), L(this, d + 1, d + 6), L(this, d + 2, d + 5), L(this, d + 3, d + 4);
    return this;
  }, f.prototype.toString = function() {
    const p = this.length;
    return p === 0 ? "" : arguments.length === 0 ? Pt(this, 0, p) : j.apply(this, arguments);
  }, f.prototype.toLocaleString = f.prototype.toString, f.prototype.equals = function(p) {
    if (!f.isBuffer(p)) throw new TypeError("Argument must be a Buffer");
    return this === p ? !0 : f.compare(this, p) === 0;
  }, f.prototype.inspect = function() {
    let p = "";
    const d = n.INSPECT_MAX_BYTES;
    return p = this.toString("hex", 0, d).replace(/(.{2})/g, "$1 ").trim(), this.length > d && (p += " ... "), "<Buffer " + p + ">";
  }, r && (f.prototype[r] = f.prototype.inspect), f.prototype.compare = function(p, d, k, q, Z) {
    if (we(p, _) && (p = f.from(p, p.offset, p.byteLength)), !f.isBuffer(p))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof p
      );
    if (d === void 0 && (d = 0), k === void 0 && (k = p ? p.length : 0), q === void 0 && (q = 0), Z === void 0 && (Z = this.length), d < 0 || k > p.length || q < 0 || Z > this.length)
      throw new RangeError("out of range index");
    if (q >= Z && d >= k)
      return 0;
    if (q >= Z)
      return -1;
    if (d >= k)
      return 1;
    if (d >>>= 0, k >>>= 0, q >>>= 0, Z >>>= 0, this === p) return 0;
    let ct = Z - q, kt = k - d;
    const Qt = Math.min(ct, kt), Wt = this.slice(q, Z), Jt = p.slice(d, k);
    for (let Dt = 0; Dt < Qt; ++Dt)
      if (Wt[Dt] !== Jt[Dt]) {
        ct = Wt[Dt], kt = Jt[Dt];
        break;
      }
    return ct < kt ? -1 : kt < ct ? 1 : 0;
  };
  function X(E, p, d, k, q) {
    if (E.length === 0) return -1;
    if (typeof d == "string" ? (k = d, d = 0) : d > 2147483647 ? d = 2147483647 : d < -2147483648 && (d = -2147483648), d = +d, xe(d) && (d = q ? 0 : E.length - 1), d < 0 && (d = E.length + d), d >= E.length) {
      if (q) return -1;
      d = E.length - 1;
    } else if (d < 0)
      if (q) d = 0;
      else return -1;
    if (typeof p == "string" && (p = f.from(p, k)), f.isBuffer(p))
      return p.length === 0 ? -1 : et(E, p, d, k, q);
    if (typeof p == "number")
      return p = p & 255, typeof _.prototype.indexOf == "function" ? q ? _.prototype.indexOf.call(E, p, d) : _.prototype.lastIndexOf.call(E, p, d) : et(E, [p], d, k, q);
    throw new TypeError("val must be string, number or Buffer");
  }
  function et(E, p, d, k, q) {
    let Z = 1, ct = E.length, kt = p.length;
    if (k !== void 0 && (k = String(k).toLowerCase(), k === "ucs2" || k === "ucs-2" || k === "utf16le" || k === "utf-16le")) {
      if (E.length < 2 || p.length < 2)
        return -1;
      Z = 2, ct /= 2, kt /= 2, d /= 2;
    }
    function Qt(Jt, Dt) {
      return Z === 1 ? Jt[Dt] : Jt.readUInt16BE(Dt * Z);
    }
    let Wt;
    if (q) {
      let Jt = -1;
      for (Wt = d; Wt < ct; Wt++)
        if (Qt(E, Wt) === Qt(p, Jt === -1 ? 0 : Wt - Jt)) {
          if (Jt === -1 && (Jt = Wt), Wt - Jt + 1 === kt) return Jt * Z;
        } else
          Jt !== -1 && (Wt -= Wt - Jt), Jt = -1;
    } else
      for (d + kt > ct && (d = ct - kt), Wt = d; Wt >= 0; Wt--) {
        let Jt = !0;
        for (let Dt = 0; Dt < kt; Dt++)
          if (Qt(E, Wt + Dt) !== Qt(p, Dt)) {
            Jt = !1;
            break;
          }
        if (Jt) return Wt;
      }
    return -1;
  }
  f.prototype.includes = function(p, d, k) {
    return this.indexOf(p, d, k) !== -1;
  }, f.prototype.indexOf = function(p, d, k) {
    return X(this, p, d, k, !0);
  }, f.prototype.lastIndexOf = function(p, d, k) {
    return X(this, p, d, k, !1);
  };
  function lt(E, p, d, k) {
    d = Number(d) || 0;
    const q = E.length - d;
    k ? (k = Number(k), k > q && (k = q)) : k = q;
    const Z = p.length;
    k > Z / 2 && (k = Z / 2);
    let ct;
    for (ct = 0; ct < k; ++ct) {
      const kt = parseInt(p.substr(ct * 2, 2), 16);
      if (xe(kt)) return ct;
      E[d + ct] = kt;
    }
    return ct;
  }
  function Y(E, p, d, k) {
    return Ue(ge(p, E.length - d), E, d, k);
  }
  function Et(E, p, d, k) {
    return Ue(Ge(p), E, d, k);
  }
  function Ct(E, p, d, k) {
    return Ue(ie(p), E, d, k);
  }
  function pt(E, p, d, k) {
    return Ue(Zt(p, E.length - d), E, d, k);
  }
  f.prototype.write = function(p, d, k, q) {
    if (d === void 0)
      q = "utf8", k = this.length, d = 0;
    else if (k === void 0 && typeof d == "string")
      q = d, k = this.length, d = 0;
    else if (isFinite(d))
      d = d >>> 0, isFinite(k) ? (k = k >>> 0, q === void 0 && (q = "utf8")) : (q = k, k = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const Z = this.length - d;
    if ((k === void 0 || k > Z) && (k = Z), p.length > 0 && (k < 0 || d < 0) || d > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    q || (q = "utf8");
    let ct = !1;
    for (; ; )
      switch (q) {
        case "hex":
          return lt(this, p, d, k);
        case "utf8":
        case "utf-8":
          return Y(this, p, d, k);
        case "ascii":
        case "latin1":
        case "binary":
          return Et(this, p, d, k);
        case "base64":
          return Ct(this, p, d, k);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return pt(this, p, d, k);
        default:
          if (ct) throw new TypeError("Unknown encoding: " + q);
          q = ("" + q).toLowerCase(), ct = !0;
      }
  }, f.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function wt(E, p, d) {
    return p === 0 && d === E.length ? t.fromByteArray(E) : t.fromByteArray(E.slice(p, d));
  }
  function Pt(E, p, d) {
    d = Math.min(E.length, d);
    const k = [];
    let q = p;
    for (; q < d; ) {
      const Z = E[q];
      let ct = null, kt = Z > 239 ? 4 : Z > 223 ? 3 : Z > 191 ? 2 : 1;
      if (q + kt <= d) {
        let Qt, Wt, Jt, Dt;
        switch (kt) {
          case 1:
            Z < 128 && (ct = Z);
            break;
          case 2:
            Qt = E[q + 1], (Qt & 192) === 128 && (Dt = (Z & 31) << 6 | Qt & 63, Dt > 127 && (ct = Dt));
            break;
          case 3:
            Qt = E[q + 1], Wt = E[q + 2], (Qt & 192) === 128 && (Wt & 192) === 128 && (Dt = (Z & 15) << 12 | (Qt & 63) << 6 | Wt & 63, Dt > 2047 && (Dt < 55296 || Dt > 57343) && (ct = Dt));
            break;
          case 4:
            Qt = E[q + 1], Wt = E[q + 2], Jt = E[q + 3], (Qt & 192) === 128 && (Wt & 192) === 128 && (Jt & 192) === 128 && (Dt = (Z & 15) << 18 | (Qt & 63) << 12 | (Wt & 63) << 6 | Jt & 63, Dt > 65535 && Dt < 1114112 && (ct = Dt));
        }
      }
      ct === null ? (ct = 65533, kt = 1) : ct > 65535 && (ct -= 65536, k.push(ct >>> 10 & 1023 | 55296), ct = 56320 | ct & 1023), k.push(ct), q += kt;
    }
    return xt(k);
  }
  const Mt = 4096;
  function xt(E) {
    const p = E.length;
    if (p <= Mt)
      return String.fromCharCode.apply(String, E);
    let d = "", k = 0;
    for (; k < p; )
      d += String.fromCharCode.apply(
        String,
        E.slice(k, k += Mt)
      );
    return d;
  }
  function Nt(E, p, d) {
    let k = "";
    d = Math.min(E.length, d);
    for (let q = p; q < d; ++q)
      k += String.fromCharCode(E[q] & 127);
    return k;
  }
  function Ht(E, p, d) {
    let k = "";
    d = Math.min(E.length, d);
    for (let q = p; q < d; ++q)
      k += String.fromCharCode(E[q]);
    return k;
  }
  function J(E, p, d) {
    const k = E.length;
    (!p || p < 0) && (p = 0), (!d || d < 0 || d > k) && (d = k);
    let q = "";
    for (let Z = p; Z < d; ++Z)
      q += Fe[E[Z]];
    return q;
  }
  function st(E, p, d) {
    const k = E.slice(p, d);
    let q = "";
    for (let Z = 0; Z < k.length - 1; Z += 2)
      q += String.fromCharCode(k[Z] + k[Z + 1] * 256);
    return q;
  }
  f.prototype.slice = function(p, d) {
    const k = this.length;
    p = ~~p, d = d === void 0 ? k : ~~d, p < 0 ? (p += k, p < 0 && (p = 0)) : p > k && (p = k), d < 0 ? (d += k, d < 0 && (d = 0)) : d > k && (d = k), d < p && (d = p);
    const q = this.subarray(p, d);
    return Object.setPrototypeOf(q, f.prototype), q;
  };
  function _t(E, p, d) {
    if (E % 1 !== 0 || E < 0) throw new RangeError("offset is not uint");
    if (E + p > d) throw new RangeError("Trying to access beyond buffer length");
  }
  f.prototype.readUintLE = f.prototype.readUIntLE = function(p, d, k) {
    p = p >>> 0, d = d >>> 0, k || _t(p, d, this.length);
    let q = this[p], Z = 1, ct = 0;
    for (; ++ct < d && (Z *= 256); )
      q += this[p + ct] * Z;
    return q;
  }, f.prototype.readUintBE = f.prototype.readUIntBE = function(p, d, k) {
    p = p >>> 0, d = d >>> 0, k || _t(p, d, this.length);
    let q = this[p + --d], Z = 1;
    for (; d > 0 && (Z *= 256); )
      q += this[p + --d] * Z;
    return q;
  }, f.prototype.readUint8 = f.prototype.readUInt8 = function(p, d) {
    return p = p >>> 0, d || _t(p, 1, this.length), this[p];
  }, f.prototype.readUint16LE = f.prototype.readUInt16LE = function(p, d) {
    return p = p >>> 0, d || _t(p, 2, this.length), this[p] | this[p + 1] << 8;
  }, f.prototype.readUint16BE = f.prototype.readUInt16BE = function(p, d) {
    return p = p >>> 0, d || _t(p, 2, this.length), this[p] << 8 | this[p + 1];
  }, f.prototype.readUint32LE = f.prototype.readUInt32LE = function(p, d) {
    return p = p >>> 0, d || _t(p, 4, this.length), (this[p] | this[p + 1] << 8 | this[p + 2] << 16) + this[p + 3] * 16777216;
  }, f.prototype.readUint32BE = f.prototype.readUInt32BE = function(p, d) {
    return p = p >>> 0, d || _t(p, 4, this.length), this[p] * 16777216 + (this[p + 1] << 16 | this[p + 2] << 8 | this[p + 3]);
  }, f.prototype.readBigUInt64LE = ce(function(p) {
    p = p >>> 0, vt(p, "offset");
    const d = this[p], k = this[p + 7];
    (d === void 0 || k === void 0) && It(p, this.length - 8);
    const q = d + this[++p] * 2 ** 8 + this[++p] * 2 ** 16 + this[++p] * 2 ** 24, Z = this[++p] + this[++p] * 2 ** 8 + this[++p] * 2 ** 16 + k * 2 ** 24;
    return BigInt(q) + (BigInt(Z) << BigInt(32));
  }), f.prototype.readBigUInt64BE = ce(function(p) {
    p = p >>> 0, vt(p, "offset");
    const d = this[p], k = this[p + 7];
    (d === void 0 || k === void 0) && It(p, this.length - 8);
    const q = d * 2 ** 24 + this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + this[++p], Z = this[++p] * 2 ** 24 + this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + k;
    return (BigInt(q) << BigInt(32)) + BigInt(Z);
  }), f.prototype.readIntLE = function(p, d, k) {
    p = p >>> 0, d = d >>> 0, k || _t(p, d, this.length);
    let q = this[p], Z = 1, ct = 0;
    for (; ++ct < d && (Z *= 256); )
      q += this[p + ct] * Z;
    return Z *= 128, q >= Z && (q -= Math.pow(2, 8 * d)), q;
  }, f.prototype.readIntBE = function(p, d, k) {
    p = p >>> 0, d = d >>> 0, k || _t(p, d, this.length);
    let q = d, Z = 1, ct = this[p + --q];
    for (; q > 0 && (Z *= 256); )
      ct += this[p + --q] * Z;
    return Z *= 128, ct >= Z && (ct -= Math.pow(2, 8 * d)), ct;
  }, f.prototype.readInt8 = function(p, d) {
    return p = p >>> 0, d || _t(p, 1, this.length), this[p] & 128 ? (255 - this[p] + 1) * -1 : this[p];
  }, f.prototype.readInt16LE = function(p, d) {
    p = p >>> 0, d || _t(p, 2, this.length);
    const k = this[p] | this[p + 1] << 8;
    return k & 32768 ? k | 4294901760 : k;
  }, f.prototype.readInt16BE = function(p, d) {
    p = p >>> 0, d || _t(p, 2, this.length);
    const k = this[p + 1] | this[p] << 8;
    return k & 32768 ? k | 4294901760 : k;
  }, f.prototype.readInt32LE = function(p, d) {
    return p = p >>> 0, d || _t(p, 4, this.length), this[p] | this[p + 1] << 8 | this[p + 2] << 16 | this[p + 3] << 24;
  }, f.prototype.readInt32BE = function(p, d) {
    return p = p >>> 0, d || _t(p, 4, this.length), this[p] << 24 | this[p + 1] << 16 | this[p + 2] << 8 | this[p + 3];
  }, f.prototype.readBigInt64LE = ce(function(p) {
    p = p >>> 0, vt(p, "offset");
    const d = this[p], k = this[p + 7];
    (d === void 0 || k === void 0) && It(p, this.length - 8);
    const q = this[p + 4] + this[p + 5] * 2 ** 8 + this[p + 6] * 2 ** 16 + (k << 24);
    return (BigInt(q) << BigInt(32)) + BigInt(d + this[++p] * 2 ** 8 + this[++p] * 2 ** 16 + this[++p] * 2 ** 24);
  }), f.prototype.readBigInt64BE = ce(function(p) {
    p = p >>> 0, vt(p, "offset");
    const d = this[p], k = this[p + 7];
    (d === void 0 || k === void 0) && It(p, this.length - 8);
    const q = (d << 24) + // Overflow
    this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + this[++p];
    return (BigInt(q) << BigInt(32)) + BigInt(this[++p] * 2 ** 24 + this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + k);
  }), f.prototype.readFloatLE = function(p, d) {
    return p = p >>> 0, d || _t(p, 4, this.length), e.read(this, p, !0, 23, 4);
  }, f.prototype.readFloatBE = function(p, d) {
    return p = p >>> 0, d || _t(p, 4, this.length), e.read(this, p, !1, 23, 4);
  }, f.prototype.readDoubleLE = function(p, d) {
    return p = p >>> 0, d || _t(p, 8, this.length), e.read(this, p, !0, 52, 8);
  }, f.prototype.readDoubleBE = function(p, d) {
    return p = p >>> 0, d || _t(p, 8, this.length), e.read(this, p, !1, 52, 8);
  };
  function mt(E, p, d, k, q, Z) {
    if (!f.isBuffer(E)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (p > q || p < Z) throw new RangeError('"value" argument is out of bounds');
    if (d + k > E.length) throw new RangeError("Index out of range");
  }
  f.prototype.writeUintLE = f.prototype.writeUIntLE = function(p, d, k, q) {
    if (p = +p, d = d >>> 0, k = k >>> 0, !q) {
      const kt = Math.pow(2, 8 * k) - 1;
      mt(this, p, d, k, kt, 0);
    }
    let Z = 1, ct = 0;
    for (this[d] = p & 255; ++ct < k && (Z *= 256); )
      this[d + ct] = p / Z & 255;
    return d + k;
  }, f.prototype.writeUintBE = f.prototype.writeUIntBE = function(p, d, k, q) {
    if (p = +p, d = d >>> 0, k = k >>> 0, !q) {
      const kt = Math.pow(2, 8 * k) - 1;
      mt(this, p, d, k, kt, 0);
    }
    let Z = k - 1, ct = 1;
    for (this[d + Z] = p & 255; --Z >= 0 && (ct *= 256); )
      this[d + Z] = p / ct & 255;
    return d + k;
  }, f.prototype.writeUint8 = f.prototype.writeUInt8 = function(p, d, k) {
    return p = +p, d = d >>> 0, k || mt(this, p, d, 1, 255, 0), this[d] = p & 255, d + 1;
  }, f.prototype.writeUint16LE = f.prototype.writeUInt16LE = function(p, d, k) {
    return p = +p, d = d >>> 0, k || mt(this, p, d, 2, 65535, 0), this[d] = p & 255, this[d + 1] = p >>> 8, d + 2;
  }, f.prototype.writeUint16BE = f.prototype.writeUInt16BE = function(p, d, k) {
    return p = +p, d = d >>> 0, k || mt(this, p, d, 2, 65535, 0), this[d] = p >>> 8, this[d + 1] = p & 255, d + 2;
  }, f.prototype.writeUint32LE = f.prototype.writeUInt32LE = function(p, d, k) {
    return p = +p, d = d >>> 0, k || mt(this, p, d, 4, 4294967295, 0), this[d + 3] = p >>> 24, this[d + 2] = p >>> 16, this[d + 1] = p >>> 8, this[d] = p & 255, d + 4;
  }, f.prototype.writeUint32BE = f.prototype.writeUInt32BE = function(p, d, k) {
    return p = +p, d = d >>> 0, k || mt(this, p, d, 4, 4294967295, 0), this[d] = p >>> 24, this[d + 1] = p >>> 16, this[d + 2] = p >>> 8, this[d + 3] = p & 255, d + 4;
  };
  function H(E, p, d, k, q) {
    Ot(p, k, q, E, d, 7);
    let Z = Number(p & BigInt(4294967295));
    E[d++] = Z, Z = Z >> 8, E[d++] = Z, Z = Z >> 8, E[d++] = Z, Z = Z >> 8, E[d++] = Z;
    let ct = Number(p >> BigInt(32) & BigInt(4294967295));
    return E[d++] = ct, ct = ct >> 8, E[d++] = ct, ct = ct >> 8, E[d++] = ct, ct = ct >> 8, E[d++] = ct, d;
  }
  function V(E, p, d, k, q) {
    Ot(p, k, q, E, d, 7);
    let Z = Number(p & BigInt(4294967295));
    E[d + 7] = Z, Z = Z >> 8, E[d + 6] = Z, Z = Z >> 8, E[d + 5] = Z, Z = Z >> 8, E[d + 4] = Z;
    let ct = Number(p >> BigInt(32) & BigInt(4294967295));
    return E[d + 3] = ct, ct = ct >> 8, E[d + 2] = ct, ct = ct >> 8, E[d + 1] = ct, ct = ct >> 8, E[d] = ct, d + 8;
  }
  f.prototype.writeBigUInt64LE = ce(function(p, d = 0) {
    return H(this, p, d, BigInt(0), BigInt("0xffffffffffffffff"));
  }), f.prototype.writeBigUInt64BE = ce(function(p, d = 0) {
    return V(this, p, d, BigInt(0), BigInt("0xffffffffffffffff"));
  }), f.prototype.writeIntLE = function(p, d, k, q) {
    if (p = +p, d = d >>> 0, !q) {
      const Qt = Math.pow(2, 8 * k - 1);
      mt(this, p, d, k, Qt - 1, -Qt);
    }
    let Z = 0, ct = 1, kt = 0;
    for (this[d] = p & 255; ++Z < k && (ct *= 256); )
      p < 0 && kt === 0 && this[d + Z - 1] !== 0 && (kt = 1), this[d + Z] = (p / ct >> 0) - kt & 255;
    return d + k;
  }, f.prototype.writeIntBE = function(p, d, k, q) {
    if (p = +p, d = d >>> 0, !q) {
      const Qt = Math.pow(2, 8 * k - 1);
      mt(this, p, d, k, Qt - 1, -Qt);
    }
    let Z = k - 1, ct = 1, kt = 0;
    for (this[d + Z] = p & 255; --Z >= 0 && (ct *= 256); )
      p < 0 && kt === 0 && this[d + Z + 1] !== 0 && (kt = 1), this[d + Z] = (p / ct >> 0) - kt & 255;
    return d + k;
  }, f.prototype.writeInt8 = function(p, d, k) {
    return p = +p, d = d >>> 0, k || mt(this, p, d, 1, 127, -128), p < 0 && (p = 255 + p + 1), this[d] = p & 255, d + 1;
  }, f.prototype.writeInt16LE = function(p, d, k) {
    return p = +p, d = d >>> 0, k || mt(this, p, d, 2, 32767, -32768), this[d] = p & 255, this[d + 1] = p >>> 8, d + 2;
  }, f.prototype.writeInt16BE = function(p, d, k) {
    return p = +p, d = d >>> 0, k || mt(this, p, d, 2, 32767, -32768), this[d] = p >>> 8, this[d + 1] = p & 255, d + 2;
  }, f.prototype.writeInt32LE = function(p, d, k) {
    return p = +p, d = d >>> 0, k || mt(this, p, d, 4, 2147483647, -2147483648), this[d] = p & 255, this[d + 1] = p >>> 8, this[d + 2] = p >>> 16, this[d + 3] = p >>> 24, d + 4;
  }, f.prototype.writeInt32BE = function(p, d, k) {
    return p = +p, d = d >>> 0, k || mt(this, p, d, 4, 2147483647, -2147483648), p < 0 && (p = 4294967295 + p + 1), this[d] = p >>> 24, this[d + 1] = p >>> 16, this[d + 2] = p >>> 8, this[d + 3] = p & 255, d + 4;
  }, f.prototype.writeBigInt64LE = ce(function(p, d = 0) {
    return H(this, p, d, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), f.prototype.writeBigInt64BE = ce(function(p, d = 0) {
    return V(this, p, d, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function tt(E, p, d, k, q, Z) {
    if (d + k > E.length) throw new RangeError("Index out of range");
    if (d < 0) throw new RangeError("Index out of range");
  }
  function ut(E, p, d, k, q) {
    return p = +p, d = d >>> 0, q || tt(E, p, d, 4), e.write(E, p, d, k, 23, 4), d + 4;
  }
  f.prototype.writeFloatLE = function(p, d, k) {
    return ut(this, p, d, !0, k);
  }, f.prototype.writeFloatBE = function(p, d, k) {
    return ut(this, p, d, !1, k);
  };
  function dt(E, p, d, k, q) {
    return p = +p, d = d >>> 0, q || tt(E, p, d, 8), e.write(E, p, d, k, 52, 8), d + 8;
  }
  f.prototype.writeDoubleLE = function(p, d, k) {
    return dt(this, p, d, !0, k);
  }, f.prototype.writeDoubleBE = function(p, d, k) {
    return dt(this, p, d, !1, k);
  }, f.prototype.copy = function(p, d, k, q) {
    if (!f.isBuffer(p)) throw new TypeError("argument should be a Buffer");
    if (k || (k = 0), !q && q !== 0 && (q = this.length), d >= p.length && (d = p.length), d || (d = 0), q > 0 && q < k && (q = k), q === k || p.length === 0 || this.length === 0) return 0;
    if (d < 0)
      throw new RangeError("targetStart out of bounds");
    if (k < 0 || k >= this.length) throw new RangeError("Index out of range");
    if (q < 0) throw new RangeError("sourceEnd out of bounds");
    q > this.length && (q = this.length), p.length - d < q - k && (q = p.length - d + k);
    const Z = q - k;
    return this === p && typeof _.prototype.copyWithin == "function" ? this.copyWithin(d, k, q) : _.prototype.set.call(
      p,
      this.subarray(k, q),
      d
    ), Z;
  }, f.prototype.fill = function(p, d, k, q) {
    if (typeof p == "string") {
      if (typeof d == "string" ? (q = d, d = 0, k = this.length) : typeof k == "string" && (q = k, k = this.length), q !== void 0 && typeof q != "string")
        throw new TypeError("encoding must be a string");
      if (typeof q == "string" && !f.isEncoding(q))
        throw new TypeError("Unknown encoding: " + q);
      if (p.length === 1) {
        const ct = p.charCodeAt(0);
        (q === "utf8" && ct < 128 || q === "latin1") && (p = ct);
      }
    } else typeof p == "number" ? p = p & 255 : typeof p == "boolean" && (p = Number(p));
    if (d < 0 || this.length < d || this.length < k)
      throw new RangeError("Out of range index");
    if (k <= d)
      return this;
    d = d >>> 0, k = k === void 0 ? this.length : k >>> 0, p || (p = 0);
    let Z;
    if (typeof p == "number")
      for (Z = d; Z < k; ++Z)
        this[Z] = p;
    else {
      const ct = f.isBuffer(p) ? p : f.from(p, q), kt = ct.length;
      if (kt === 0)
        throw new TypeError('The value "' + p + '" is invalid for argument "value"');
      for (Z = 0; Z < k - d; ++Z)
        this[Z + d] = ct[Z % kt];
    }
    return this;
  };
  const B = {};
  function O(E, p, d) {
    B[E] = class extends d {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: p.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${E}]`, this.stack, delete this.name;
      }
      get code() {
        return E;
      }
      set code(q) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: q,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${E}]: ${this.message}`;
      }
    };
  }
  O(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(E) {
      return E ? `${E} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), O(
    "ERR_INVALID_ARG_TYPE",
    function(E, p) {
      return `The "${E}" argument must be of type number. Received type ${typeof p}`;
    },
    TypeError
  ), O(
    "ERR_OUT_OF_RANGE",
    function(E, p, d) {
      let k = `The value of "${E}" is out of range.`, q = d;
      return Number.isInteger(d) && Math.abs(d) > 2 ** 32 ? q = it(String(d)) : typeof d == "bigint" && (q = String(d), (d > BigInt(2) ** BigInt(32) || d < -(BigInt(2) ** BigInt(32))) && (q = it(q)), q += "n"), k += ` It must be ${p}. Received ${q}`, k;
    },
    RangeError
  );
  function it(E) {
    let p = "", d = E.length;
    const k = E[0] === "-" ? 1 : 0;
    for (; d >= k + 4; d -= 3)
      p = `_${E.slice(d - 3, d)}${p}`;
    return `${E.slice(0, d)}${p}`;
  }
  function gt(E, p, d) {
    vt(p, "offset"), (E[p] === void 0 || E[p + d] === void 0) && It(p, E.length - (d + 1));
  }
  function Ot(E, p, d, k, q, Z) {
    if (E > d || E < p) {
      const ct = typeof p == "bigint" ? "n" : "";
      let kt;
      throw p === 0 || p === BigInt(0) ? kt = `>= 0${ct} and < 2${ct} ** ${(Z + 1) * 8}${ct}` : kt = `>= -(2${ct} ** ${(Z + 1) * 8 - 1}${ct}) and < 2 ** ${(Z + 1) * 8 - 1}${ct}`, new B.ERR_OUT_OF_RANGE("value", kt, E);
    }
    gt(k, q, Z);
  }
  function vt(E, p) {
    if (typeof E != "number")
      throw new B.ERR_INVALID_ARG_TYPE(p, "number", E);
  }
  function It(E, p, d) {
    throw Math.floor(E) !== E ? (vt(E, d), new B.ERR_OUT_OF_RANGE("offset", "an integer", E)) : p < 0 ? new B.ERR_BUFFER_OUT_OF_BOUNDS() : new B.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${p}`,
      E
    );
  }
  const re = /[^+/0-9A-Za-z-_]/g;
  function at(E) {
    if (E = E.split("=")[0], E = E.trim().replace(re, ""), E.length < 2) return "";
    for (; E.length % 4 !== 0; )
      E = E + "=";
    return E;
  }
  function ge(E, p) {
    p = p || 1 / 0;
    let d;
    const k = E.length;
    let q = null;
    const Z = [];
    for (let ct = 0; ct < k; ++ct) {
      if (d = E.charCodeAt(ct), d > 55295 && d < 57344) {
        if (!q) {
          if (d > 56319) {
            (p -= 3) > -1 && Z.push(239, 191, 189);
            continue;
          } else if (ct + 1 === k) {
            (p -= 3) > -1 && Z.push(239, 191, 189);
            continue;
          }
          q = d;
          continue;
        }
        if (d < 56320) {
          (p -= 3) > -1 && Z.push(239, 191, 189), q = d;
          continue;
        }
        d = (q - 55296 << 10 | d - 56320) + 65536;
      } else q && (p -= 3) > -1 && Z.push(239, 191, 189);
      if (q = null, d < 128) {
        if ((p -= 1) < 0) break;
        Z.push(d);
      } else if (d < 2048) {
        if ((p -= 2) < 0) break;
        Z.push(
          d >> 6 | 192,
          d & 63 | 128
        );
      } else if (d < 65536) {
        if ((p -= 3) < 0) break;
        Z.push(
          d >> 12 | 224,
          d >> 6 & 63 | 128,
          d & 63 | 128
        );
      } else if (d < 1114112) {
        if ((p -= 4) < 0) break;
        Z.push(
          d >> 18 | 240,
          d >> 12 & 63 | 128,
          d >> 6 & 63 | 128,
          d & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Z;
  }
  function Ge(E) {
    const p = [];
    for (let d = 0; d < E.length; ++d)
      p.push(E.charCodeAt(d) & 255);
    return p;
  }
  function Zt(E, p) {
    let d, k, q;
    const Z = [];
    for (let ct = 0; ct < E.length && !((p -= 2) < 0); ++ct)
      d = E.charCodeAt(ct), k = d >> 8, q = d % 256, Z.push(q), Z.push(k);
    return Z;
  }
  function ie(E) {
    return t.toByteArray(at(E));
  }
  function Ue(E, p, d, k) {
    let q;
    for (q = 0; q < k && !(q + d >= p.length || q >= E.length); ++q)
      p[q + d] = E[q];
    return q;
  }
  function we(E, p) {
    return E instanceof p || E != null && E.constructor != null && E.constructor.name != null && E.constructor.name === p.name;
  }
  function xe(E) {
    return E !== E;
  }
  const Fe = function() {
    const E = "0123456789abcdef", p = new Array(256);
    for (let d = 0; d < 16; ++d) {
      const k = d * 16;
      for (let q = 0; q < 16; ++q)
        p[k + q] = E[d] + E[q];
    }
    return p;
  }();
  function ce(E) {
    return typeof BigInt > "u" ? tr : E;
  }
  function tr() {
    throw new Error("BigInt not supported");
  }
})(Wy);
const Rr = Wy.Buffer, Fm = "6.13.4";
function Km(n, t, e) {
  const r = t.split("|").map((_) => _.trim());
  for (let _ = 0; _ < r.length; _++)
    switch (t) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof n === t)
          return;
    }
  const s = new Error(`invalid value for type ${t}`);
  throw s.code = "INVALID_ARGUMENT", s.argument = `value.${e}`, s.value = n, s;
}
async function Ce(n) {
  const t = Object.keys(n);
  return (await Promise.all(t.map((r) => Promise.resolve(n[r])))).reduce((r, s, _) => (r[t[_]] = s, r), {});
}
function Bt(n, t, e) {
  for (let r in t) {
    let s = t[r];
    const _ = e ? e[r] : null;
    _ && Km(s, _, r), Object.defineProperty(n, r, { enumerable: !0, value: s, writable: !1 });
  }
}
function D_(n) {
  if (n == null)
    return "null";
  if (Array.isArray(n))
    return "[ " + n.map(D_).join(", ") + " ]";
  if (n instanceof Uint8Array) {
    const t = "0123456789abcdef";
    let e = "0x";
    for (let r = 0; r < n.length; r++)
      e += t[n[r] >> 4], e += t[n[r] & 15];
    return e;
  }
  if (typeof n == "object" && typeof n.toJSON == "function")
    return D_(n.toJSON());
  switch (typeof n) {
    case "boolean":
    case "symbol":
      return n.toString();
    case "bigint":
      return BigInt(n).toString();
    case "number":
      return n.toString();
    case "string":
      return JSON.stringify(n);
    case "object": {
      const t = Object.keys(n);
      return t.sort(), "{ " + t.map((e) => `${D_(e)}: ${D_(n[e])}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function Re(n, t) {
  return n && n.code === t;
}
function Fh(n) {
  return Re(n, "CALL_EXCEPTION");
}
function oe(n, t, e) {
  let r = n;
  {
    const _ = [];
    if (e) {
      if ("message" in e || "code" in e || "name" in e)
        throw new Error(`value will overwrite populated values: ${D_(e)}`);
      for (const a in e) {
        if (a === "shortMessage")
          continue;
        const c = e[a];
        _.push(a + "=" + D_(c));
      }
    }
    _.push(`code=${t}`), _.push(`version=${Fm}`), _.length && (n += " (" + _.join(", ") + ")");
  }
  let s;
  switch (t) {
    case "INVALID_ARGUMENT":
      s = new TypeError(n);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      s = new RangeError(n);
      break;
    default:
      s = new Error(n);
  }
  return Bt(s, { code: t }), e && Object.assign(s, e), s.shortMessage == null && Bt(s, { shortMessage: r }), s;
}
function ht(n, t, e, r) {
  if (!n)
    throw oe(t, e, r);
}
function W(n, t, e, r) {
  ht(n, t, "INVALID_ARGUMENT", { argument: e, value: r });
}
function $y(n, t, e) {
  e == null && (e = ""), e && (e = ": " + e), ht(n >= t, "missing arguemnt" + e, "MISSING_ARGUMENT", {
    count: n,
    expectedCount: t
  }), ht(n <= t, "too many arguments" + e, "UNEXPECTED_ARGUMENT", {
    count: n,
    expectedCount: t
  });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((n, t) => {
  try {
    if ("test".normalize(t) !== "test")
      throw new Error("bad");
    if (t === "NFD" && "é".normalize("NFD") !== "é")
      throw new Error("broken");
    n.push(t);
  } catch {
  }
  return n;
}, []);
function Cf(n, t, e) {
  if (e == null && (e = ""), n !== t) {
    let r = e, s = "new";
    e && (r += ".", s += " " + e), ht(!1, `private constructor; use ${r}from* methods`, "UNSUPPORTED_OPERATION", {
      operation: s
    });
  }
}
function Zy(n, t, e) {
  if (n instanceof Uint8Array)
    return e ? new Uint8Array(n) : n;
  if (typeof n == "string" && n.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const r = new Uint8Array((n.length - 2) / 2);
    let s = 2;
    for (let _ = 0; _ < r.length; _++)
      r[_] = parseInt(n.substring(s, s + 2), 16), s += 2;
    return r;
  }
  W(!1, "invalid BytesLike value", t || "value", n);
}
function Vt(n, t) {
  return Zy(n, t, !1);
}
function Ie(n, t) {
  return Zy(n, t, !0);
}
function ee(n, t) {
  return !(typeof n != "string" || !n.match(/^0x[0-9A-Fa-f]*$/) || typeof t == "number" && n.length !== 2 + 2 * t || t === !0 && n.length % 2 !== 0);
}
function Kh(n) {
  return ee(n, !0) || n instanceof Uint8Array;
}
const Sw = "0123456789abcdef";
function Rt(n) {
  const t = Vt(n);
  let e = "0x";
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    e += Sw[(s & 240) >> 4] + Sw[s & 15];
  }
  return e;
}
function pe(n) {
  return "0x" + n.map((t) => Rt(t).substring(2)).join("");
}
function Pa(n) {
  return ee(n, !0) ? (n.length - 2) / 2 : Vt(n).length;
}
function ae(n, t, e) {
  const r = Vt(n);
  return e != null && e > r.length && ht(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
    buffer: r,
    length: r.length,
    offset: e
  }), Rt(r.slice(t ?? 0, e ?? r.length));
}
function Xy(n, t, e) {
  const r = Vt(n);
  ht(t >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(r),
    length: t,
    offset: t + 1
  });
  const s = new Uint8Array(t);
  return s.fill(0), e ? s.set(r, t - r.length) : s.set(r, 0), Rt(s);
}
function S_(n, t) {
  return Xy(n, t, !0);
}
function Dm(n, t) {
  return Xy(n, t, !1);
}
const If = BigInt(0), Sr = BigInt(1), eh = 9007199254740991;
function Lm(n, t) {
  const e = Nf(n, "value"), r = BigInt(Ft(t, "width"));
  if (ht(e >> r === If, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: n
  }), e >> r - Sr) {
    const s = (Sr << r) - Sr;
    return -((~e & s) + Sr);
  }
  return e;
}
function tA(n, t) {
  let e = zt(n, "value");
  const r = BigInt(Ft(t, "width")), s = Sr << r - Sr;
  if (e < If) {
    e = -e, ht(e <= s, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: n
    });
    const _ = (Sr << r) - Sr;
    return (~e & _) + Sr;
  } else
    ht(e < s, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: n
    });
  return e;
}
function jc(n, t) {
  const e = Nf(n, "value"), r = BigInt(Ft(t, "bits"));
  return e & (Sr << r) - Sr;
}
function zt(n, t) {
  switch (typeof n) {
    case "bigint":
      return n;
    case "number":
      return W(Number.isInteger(n), "underflow", t || "value", n), W(n >= -9007199254740991 && n <= eh, "overflow", t || "value", n), BigInt(n);
    case "string":
      try {
        if (n === "")
          throw new Error("empty string");
        return n[0] === "-" && n[1] !== "-" ? -BigInt(n.substring(1)) : BigInt(n);
      } catch (e) {
        W(!1, `invalid BigNumberish string: ${e.message}`, t || "value", n);
      }
  }
  W(!1, "invalid BigNumberish value", t || "value", n);
}
function Nf(n, t) {
  const e = zt(n, t);
  return ht(e >= If, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: n
  }), e;
}
const Rw = "0123456789abcdef";
function Dh(n) {
  if (n instanceof Uint8Array) {
    let t = "0x0";
    for (const e of n)
      t += Rw[e >> 4], t += Rw[e & 15];
    return BigInt(t);
  }
  return zt(n);
}
function Ft(n, t) {
  switch (typeof n) {
    case "bigint":
      return W(n >= -9007199254740991 && n <= eh, "overflow", t || "value", n), Number(n);
    case "number":
      return W(Number.isInteger(n), "underflow", t || "value", n), W(n >= -9007199254740991 && n <= eh, "overflow", t || "value", n), n;
    case "string":
      try {
        if (n === "")
          throw new Error("empty string");
        return Ft(BigInt(n), t);
      } catch (e) {
        W(!1, `invalid numeric string: ${e.message}`, t || "value", n);
      }
  }
  W(!1, "invalid numeric value", t || "value", n);
}
function jm(n) {
  return Ft(Dh(n));
}
function zs(n, t) {
  let r = Nf(n, "value").toString(16);
  if (t == null)
    r.length % 2 && (r = "0" + r);
  else {
    const s = Ft(t, "width");
    for (ht(s * 2 >= r.length, `value exceeds width (${s} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: n
    }); r.length < s * 2; )
      r = "0" + r;
  }
  return "0x" + r;
}
function Ne(n) {
  const t = Nf(n, "value");
  if (t === If)
    return new Uint8Array([]);
  let e = t.toString(16);
  e.length % 2 && (e = "0" + e);
  const r = new Uint8Array(e.length / 2);
  for (let s = 0; s < r.length; s++) {
    const _ = s * 2;
    r[s] = parseInt(e.substring(_, _ + 2), 16);
  }
  return r;
}
function L_(n) {
  let t = Rt(Kh(n) ? n : Ne(n)).substring(2);
  for (; t.startsWith("0"); )
    t = t.substring(1);
  return t === "" && (t = "0"), "0x" + t;
}
const Ew = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const Pw = BigInt(58);
function Vm(n) {
  const t = Vt(n);
  let e = Dh(t), r = "";
  for (; e; )
    r = Ew[Number(e % Pw)] + r, e /= Pw;
  for (let s = 0; s < t.length && !t[s]; s++)
    r = Ew[0] + r;
  return r;
}
function Ym(n) {
  n = atob(n);
  const t = new Uint8Array(n.length);
  for (let e = 0; e < n.length; e++)
    t[e] = n.charCodeAt(e);
  return Vt(t);
}
function Hm(n) {
  const t = Vt(n);
  let e = "";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return btoa(e);
}
var Oa;
class eA {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(t, e, r) {
    /**
     *  The event filter.
     */
    $(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    $(this, "emitter");
    nt(this, Oa);
    K(this, Oa, e), Bt(this, { emitter: t, filter: r });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    A(this, Oa) != null && await this.emitter.off(this.filter, A(this, Oa));
  }
}
Oa = new WeakMap();
function qm(n, t, e, r, s) {
  W(!1, `invalid codepoint at offset ${t}; ${n}`, "bytes", e);
}
function rA(n, t, e, r, s) {
  if (n === "BAD_PREFIX" || n === "UNEXPECTED_CONTINUE") {
    let _ = 0;
    for (let a = t + 1; a < e.length && e[a] >> 6 === 2; a++)
      _++;
    return _;
  }
  return n === "OVERRUN" ? e.length - t - 1 : 0;
}
function Qm(n, t, e, r, s) {
  return n === "OVERLONG" ? (W(typeof s == "number", "invalid bad code point for replacement", "badCodepoint", s), r.push(s), 0) : (r.push(65533), rA(n, t, e));
}
const Wm = Object.freeze({
  error: qm,
  ignore: rA,
  replace: Qm
});
function Jm(n, t) {
  t == null && (t = Wm.error);
  const e = Vt(n, "bytes"), r = [];
  let s = 0;
  for (; s < e.length; ) {
    const _ = e[s++];
    if (_ >> 7 === 0) {
      r.push(_);
      continue;
    }
    let a = null, c = null;
    if ((_ & 224) === 192)
      a = 1, c = 127;
    else if ((_ & 240) === 224)
      a = 2, c = 2047;
    else if ((_ & 248) === 240)
      a = 3, c = 65535;
    else {
      (_ & 192) === 128 ? s += t("UNEXPECTED_CONTINUE", s - 1, e, r) : s += t("BAD_PREFIX", s - 1, e, r);
      continue;
    }
    if (s - 1 + a >= e.length) {
      s += t("OVERRUN", s - 1, e, r);
      continue;
    }
    let u = _ & (1 << 8 - a - 1) - 1;
    for (let l = 0; l < a; l++) {
      let f = e[s];
      if ((f & 192) != 128) {
        s += t("MISSING_CONTINUE", s, e, r), u = null;
        break;
      }
      u = u << 6 | f & 63, s++;
    }
    if (u !== null) {
      if (u > 1114111) {
        s += t("OUT_OF_RANGE", s - 1 - a, e, r, u);
        continue;
      }
      if (u >= 55296 && u <= 57343) {
        s += t("UTF16_SURROGATE", s - 1 - a, e, r, u);
        continue;
      }
      if (u <= c) {
        s += t("OVERLONG", s - 1 - a, e, r, u);
        continue;
      }
      r.push(u);
    }
  }
  return r;
}
function qi(n, t) {
  W(typeof n == "string", "invalid string value", "str", n);
  let e = [];
  for (let r = 0; r < n.length; r++) {
    const s = n.charCodeAt(r);
    if (s < 128)
      e.push(s);
    else if (s < 2048)
      e.push(s >> 6 | 192), e.push(s & 63 | 128);
    else if ((s & 64512) == 55296) {
      r++;
      const _ = n.charCodeAt(r);
      W(r < n.length && (_ & 64512) === 56320, "invalid surrogate pair", "str", n);
      const a = 65536 + ((s & 1023) << 10) + (_ & 1023);
      e.push(a >> 18 | 240), e.push(a >> 12 & 63 | 128), e.push(a >> 6 & 63 | 128), e.push(a & 63 | 128);
    } else
      e.push(s >> 12 | 224), e.push(s >> 6 & 63 | 128), e.push(s & 63 | 128);
  }
  return new Uint8Array(e);
}
function $m(n) {
  return n.map((t) => t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10 & 1023) + 55296, (t & 1023) + 56320))).join("");
}
function uf(n, t) {
  return $m(Jm(n, t));
}
function nA(n) {
  async function t(e, r) {
    ht(r == null || !r.cancelled, "request cancelled before sending", "CANCELLED");
    const s = e.url.split(":")[0].toLowerCase();
    ht(s === "http" || s === "https", `unsupported protocol ${s}`, "UNSUPPORTED_OPERATION", {
      info: { protocol: s },
      operation: "request"
    }), ht(s === "https" || !e.credentials || e.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let _ = null;
    const a = new AbortController(), c = setTimeout(() => {
      _ = oe("request timeout", "TIMEOUT"), a.abort();
    }, e.timeout);
    r && r.addListener(() => {
      _ = oe("request cancelled", "CANCELLED"), a.abort();
    });
    const u = {
      method: e.method,
      headers: new Headers(Array.from(e)),
      body: e.body || void 0,
      signal: a.signal
    };
    let l;
    try {
      l = await fetch(e.url, u);
    } catch (v) {
      throw clearTimeout(c), _ || v;
    }
    clearTimeout(c);
    const f = {};
    l.headers.forEach((v, x) => {
      f[x.toLowerCase()] = v;
    });
    const w = await l.arrayBuffer(), y = w == null ? null : new Uint8Array(w);
    return {
      statusCode: l.status,
      statusMessage: l.statusText,
      headers: f,
      body: y
    };
  }
  return t;
}
const Zm = 12, Xm = 250;
let zw = nA();
const tS = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), eS = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let yl = !1;
async function iA(n, t) {
  try {
    const e = n.match(tS);
    if (!e)
      throw new Error("invalid data");
    return new Rs(200, "OK", {
      "content-type": e[1] || "text/plain"
    }, e[2] ? Ym(e[3]) : nS(e[3]));
  } catch {
    return new Rs(599, "BAD REQUEST (invalid data: URI)", {}, null, new Wi(n));
  }
}
function sA(n) {
  async function t(e, r) {
    try {
      const s = e.match(eS);
      if (!s)
        throw new Error("invalid link");
      return new Wi(`${n}${s[2]}`);
    } catch {
      return new Rs(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new Wi(e));
    }
  }
  return t;
}
const ku = {
  data: iA,
  ipfs: sA("https://gateway.ipfs.io/ipfs/")
}, _A = /* @__PURE__ */ new WeakMap();
var Xs, _s;
class rS {
  constructor(t) {
    nt(this, Xs);
    nt(this, _s);
    K(this, Xs, []), K(this, _s, !1), _A.set(t, () => {
      if (!A(this, _s)) {
        K(this, _s, !0);
        for (const e of A(this, Xs))
          setTimeout(() => {
            e();
          }, 0);
        K(this, Xs, []);
      }
    });
  }
  addListener(t) {
    ht(!A(this, _s), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    }), A(this, Xs).push(t);
  }
  get cancelled() {
    return A(this, _s);
  }
  checkSignal() {
    ht(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
Xs = new WeakMap(), _s = new WeakMap();
function Tu(n) {
  if (n == null)
    throw new Error("missing signal; should not happen");
  return n.checkSignal(), n;
}
var ka, Ta, br, Ii, Ga, Ua, be, We, Ni, t_, e_, r_, Ur, yr, os, n_, Vc;
const Rf = class Rf {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(t) {
    nt(this, n_);
    nt(this, ka);
    nt(this, Ta);
    nt(this, br);
    nt(this, Ii);
    nt(this, Ga);
    nt(this, Ua);
    nt(this, be);
    nt(this, We);
    nt(this, Ni);
    // Hooks
    nt(this, t_);
    nt(this, e_);
    nt(this, r_);
    nt(this, Ur);
    nt(this, yr);
    nt(this, os);
    K(this, Ua, String(t)), K(this, ka, !1), K(this, Ta, !0), K(this, br, {}), K(this, Ii, ""), K(this, Ga, 3e5), K(this, yr, {
      slotInterval: Xm,
      maxAttempts: Zm
    }), K(this, os, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return A(this, Ua);
  }
  set url(t) {
    K(this, Ua, String(t));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    return A(this, be) == null ? null : new Uint8Array(A(this, be));
  }
  set body(t) {
    if (t == null)
      K(this, be, void 0), K(this, We, void 0);
    else if (typeof t == "string")
      K(this, be, qi(t)), K(this, We, "text/plain");
    else if (t instanceof Uint8Array)
      K(this, be, t), K(this, We, "application/octet-stream");
    else if (typeof t == "object")
      K(this, be, qi(JSON.stringify(t))), K(this, We, "application/json");
    else
      throw new Error("invalid body");
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return A(this, be) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    return A(this, Ii) ? A(this, Ii) : this.hasBody() ? "POST" : "GET";
  }
  set method(t) {
    t == null && (t = ""), K(this, Ii, String(t).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const t = Object.assign({}, A(this, br));
    return A(this, Ni) && (t.authorization = `Basic ${Hm(qi(A(this, Ni)))}`), this.allowGzip && (t["accept-encoding"] = "gzip"), t["content-type"] == null && A(this, We) && (t["content-type"] = A(this, We)), this.body && (t["content-length"] = String(this.body.length)), t;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(t) {
    return this.headers[t.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(t, e) {
    A(this, br)[String(t).toLowerCase()] = String(e);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    K(this, br, {});
  }
  [Symbol.iterator]() {
    const t = this.headers, e = Object.keys(t);
    let r = 0;
    return {
      next: () => {
        if (r < e.length) {
          const s = e[r++];
          return {
            value: [s, t[s]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return A(this, Ni) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(t, e) {
    W(!t.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"), K(this, Ni, `${t}:${e}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return A(this, Ta);
  }
  set allowGzip(t) {
    K(this, Ta, !!t);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!A(this, ka);
  }
  set allowInsecureAuthentication(t) {
    K(this, ka, !!t);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return A(this, Ga);
  }
  set timeout(t) {
    W(t >= 0, "timeout must be non-zero", "timeout", t), K(this, Ga, t);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return A(this, t_) || null;
  }
  set preflightFunc(t) {
    K(this, t_, t);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return A(this, e_) || null;
  }
  set processFunc(t) {
    K(this, e_, t);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return A(this, r_) || null;
  }
  set retryFunc(t) {
    K(this, r_, t);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return A(this, os) || zw;
  }
  set getUrlFunc(t) {
    K(this, os, t);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${A(this, be) ? Rt(A(this, be)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(t) {
    t.slotInterval != null && (A(this, yr).slotInterval = t.slotInterval), t.maxAttempts != null && (A(this, yr).maxAttempts = t.maxAttempts);
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    return ht(A(this, Ur) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" }), K(this, Ur, new rS(this)), At(this, n_, Vc).call(this, 0, vw() + this.timeout, 0, this, new Rs(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    ht(A(this, Ur) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const t = _A.get(this);
    if (!t)
      throw new Error("missing signal; should not happen");
    t();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(t) {
    const e = this.url.split(":")[0].toLowerCase(), r = t.split(":")[0].toLowerCase();
    ht(this.method === "GET" && (e !== "https" || r !== "http") && t.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(t)})`
    });
    const s = new Rf(t);
    return s.method = "GET", s.allowGzip = this.allowGzip, s.timeout = this.timeout, K(s, br, Object.assign({}, A(this, br))), A(this, be) && K(s, be, new Uint8Array(A(this, be))), K(s, We, A(this, We)), s;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const t = new Rf(this.url);
    return K(t, Ii, A(this, Ii)), A(this, be) && K(t, be, A(this, be)), K(t, We, A(this, We)), K(t, br, Object.assign({}, A(this, br))), K(t, Ni, A(this, Ni)), this.allowGzip && (t.allowGzip = !0), t.timeout = this.timeout, this.allowInsecureAuthentication && (t.allowInsecureAuthentication = !0), K(t, t_, A(this, t_)), K(t, e_, A(this, e_)), K(t, r_, A(this, r_)), K(t, yr, Object.assign({}, A(this, yr))), K(t, os, A(this, os)), t;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    yl = !0;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(t) {
    return ku[t.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(t, e) {
    if (t = t.toLowerCase(), t === "http" || t === "https")
      throw new Error(`cannot intercept ${t}; use registerGetUrl`);
    if (yl)
      throw new Error("gateways locked");
    ku[t] = e;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(t) {
    if (yl)
      throw new Error("gateways locked");
    zw = t;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(t) {
    return nA();
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return iA;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(t) {
    return sA(t);
  }
};
ka = new WeakMap(), Ta = new WeakMap(), br = new WeakMap(), Ii = new WeakMap(), Ga = new WeakMap(), Ua = new WeakMap(), be = new WeakMap(), We = new WeakMap(), Ni = new WeakMap(), t_ = new WeakMap(), e_ = new WeakMap(), r_ = new WeakMap(), Ur = new WeakMap(), yr = new WeakMap(), os = new WeakMap(), n_ = new WeakSet(), Vc = async function(t, e, r, s, _) {
  var f, w, y;
  if (t >= A(this, yr).maxAttempts)
    return _.makeServerError("exceeded maximum retry limit");
  ht(vw() <= e, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: s
  }), r > 0 && await iS(r);
  let a = this.clone();
  const c = (a.url.split(":")[0] || "").toLowerCase();
  if (c in ku) {
    const v = await ku[c](a.url, Tu(A(s, Ur)));
    if (v instanceof Rs) {
      let x = v;
      if (this.processFunc) {
        Tu(A(s, Ur));
        try {
          x = await this.processFunc(a, x);
        } catch (C) {
          (C.throttle == null || typeof C.stall != "number") && x.makeServerError("error in post-processing function", C).assertOk();
        }
      }
      return x;
    }
    a = v;
  }
  this.preflightFunc && (a = await this.preflightFunc(a));
  const u = await this.getUrlFunc(a, Tu(A(s, Ur)));
  let l = new Rs(u.statusCode, u.statusMessage, u.headers, u.body, s);
  if (l.statusCode === 301 || l.statusCode === 302) {
    try {
      const v = l.headers.location || "";
      return At(f = a.redirect(v), n_, Vc).call(f, t + 1, e, 0, s, l);
    } catch {
    }
    return l;
  } else if (l.statusCode === 429 && (this.retryFunc == null || await this.retryFunc(a, l, t))) {
    const v = l.headers["retry-after"];
    let x = A(this, yr).slotInterval * Math.trunc(Math.random() * Math.pow(2, t));
    return typeof v == "string" && v.match(/^[1-9][0-9]*$/) && (x = parseInt(v)), At(w = a.clone(), n_, Vc).call(w, t + 1, e, x, s, l);
  }
  if (this.processFunc) {
    Tu(A(s, Ur));
    try {
      l = await this.processFunc(a, l);
    } catch (v) {
      (v.throttle == null || typeof v.stall != "number") && l.makeServerError("error in post-processing function", v).assertOk();
      let x = A(this, yr).slotInterval * Math.trunc(Math.random() * Math.pow(2, t));
      return v.stall >= 0 && (x = v.stall), At(y = a.clone(), n_, Vc).call(y, t + 1, e, x, s, l);
    }
  }
  return l;
};
let Wi = Rf;
var wu, du, gu, Je, Fa, i_;
const bw = class bw {
  constructor(t, e, r, s, _) {
    nt(this, wu);
    nt(this, du);
    nt(this, gu);
    nt(this, Je);
    nt(this, Fa);
    nt(this, i_);
    K(this, wu, t), K(this, du, e), K(this, gu, Object.keys(r).reduce((a, c) => (a[c.toLowerCase()] = String(r[c]), a), {})), K(this, Je, s == null ? null : new Uint8Array(s)), K(this, Fa, _ || null), K(this, i_, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${A(this, Je) ? Rt(A(this, Je)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return A(this, wu);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return A(this, du);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, A(this, gu));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return A(this, Je) == null ? null : new Uint8Array(A(this, Je));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return A(this, Je) == null ? "" : uf(A(this, Je));
    } catch {
      ht(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch {
      ht(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const t = this.headers, e = Object.keys(t);
    let r = 0;
    return {
      next: () => {
        if (r < e.length) {
          const s = e[r++];
          return {
            value: [s, t[s]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(t, e) {
    let r;
    t ? r = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${t})` : (t = `${this.statusCode} ${this.statusMessage}`, r = `CLIENT ESCALATED SERVER ERROR (${t})`);
    const s = new bw(599, r, this.headers, this.body, A(this, Fa) || void 0);
    return K(s, i_, { message: t, error: e }), s;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(t, e) {
    e == null ? e = -1 : W(Number.isInteger(e) && e >= 0, "invalid stall timeout", "stall", e);
    const r = new Error(t || "throttling requests");
    throw Bt(r, { stall: e, throttle: !0 }), r;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(t) {
    return this.headers[t.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return A(this, Je) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return A(this, Fa);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return A(this, i_).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok())
      return;
    let { message: t, error: e } = A(this, i_);
    t === "" && (t = `server response ${this.statusCode} ${this.statusMessage}`);
    let r = null;
    this.request && (r = this.request.url);
    let s = null;
    try {
      A(this, Je) && (s = uf(A(this, Je)));
    } catch {
    }
    ht(!1, t, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error: e,
      info: {
        requestUrl: r,
        responseBody: s,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
wu = new WeakMap(), du = new WeakMap(), gu = new WeakMap(), Je = new WeakMap(), Fa = new WeakMap(), i_ = new WeakMap();
let Rs = bw;
function vw() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function nS(n) {
  return qi(n.replace(/%([0-9a-f][0-9a-f])/gi, (t, e) => String.fromCharCode(parseInt(e, 16))));
}
function iS(n) {
  return new Promise((t) => setTimeout(t, n));
}
function sS(n) {
  let t = n.toString(16);
  for (; t.length < 2; )
    t = "0" + t;
  return "0x" + t;
}
function Mw(n, t, e) {
  let r = 0;
  for (let s = 0; s < e; s++)
    r = r * 256 + n[t + s];
  return r;
}
function xw(n, t, e, r) {
  const s = [];
  for (; e < t + 1 + r; ) {
    const _ = oA(n, e);
    s.push(_.result), e += _.consumed, ht(e <= t + 1 + r, "child data too short", "BUFFER_OVERRUN", {
      buffer: n,
      length: r,
      offset: t
    });
  }
  return { consumed: 1 + r, result: s };
}
function oA(n, t) {
  ht(n.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: n,
    length: 0,
    offset: 1
  });
  const e = (r) => {
    ht(r <= n.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: n,
      length: n.length,
      offset: r
    });
  };
  if (n[t] >= 248) {
    const r = n[t] - 247;
    e(t + 1 + r);
    const s = Mw(n, t + 1, r);
    return e(t + 1 + r + s), xw(n, t, t + 1 + r, r + s);
  } else if (n[t] >= 192) {
    const r = n[t] - 192;
    return e(t + 1 + r), xw(n, t, t + 1, r);
  } else if (n[t] >= 184) {
    const r = n[t] - 183;
    e(t + 1 + r);
    const s = Mw(n, t + 1, r);
    e(t + 1 + r + s);
    const _ = Rt(n.slice(t + 1 + r, t + 1 + r + s));
    return { consumed: 1 + r + s, result: _ };
  } else if (n[t] >= 128) {
    const r = n[t] - 128;
    e(t + 1 + r);
    const s = Rt(n.slice(t + 1, t + 1 + r));
    return { consumed: 1 + r, result: s };
  }
  return { consumed: 1, result: sS(n[t]) };
}
function Of(n) {
  const t = Vt(n, "data"), e = oA(t, 0);
  return W(e.consumed === t.length, "unexpected junk after rlp payload", "data", n), e.result;
}
function Bw(n) {
  const t = [];
  for (; n; )
    t.unshift(n & 255), n >>= 8;
  return t;
}
function aA(n) {
  if (Array.isArray(n)) {
    let r = [];
    if (n.forEach(function(_) {
      r = r.concat(aA(_));
    }), r.length <= 55)
      return r.unshift(192 + r.length), r;
    const s = Bw(r.length);
    return s.unshift(247 + s.length), s.concat(r);
  }
  const t = Array.prototype.slice.call(Vt(n, "object"));
  if (t.length === 1 && t[0] <= 127)
    return t;
  if (t.length <= 55)
    return t.unshift(128 + t.length), t;
  const e = Bw(t.length);
  return e.unshift(183 + e.length), e.concat(t);
}
const Cw = "0123456789abcdef";
function R_(n) {
  let t = "0x";
  for (const e of aA(n))
    t += Cw[e >> 4], t += Cw[e & 15];
  return t;
}
const Oe = 32, rh = new Uint8Array(Oe), _S = ["then"], Gu = {}, cA = /* @__PURE__ */ new WeakMap();
function ks(n) {
  return cA.get(n);
}
function Iw(n, t) {
  cA.set(n, t);
}
function Kc(n, t) {
  const e = new Error(`deferred error during ABI decoding triggered accessing ${n}`);
  throw e.error = t, e;
}
function nh(n, t, e) {
  return n.indexOf(null) >= 0 ? t.map((r, s) => r instanceof mc ? nh(ks(r), r, e) : r) : n.reduce((r, s, _) => {
    let a = t.getValue(s);
    return s in r || (e && a instanceof mc && (a = nh(ks(a), a, e)), r[s] = a), r;
  }, {});
}
var Ka;
const Sa = class Sa extends Array {
  /**
   *  @private
   */
  constructor(...e) {
    const r = e[0];
    let s = e[1], _ = (e[2] || []).slice(), a = !0;
    r !== Gu && (s = e, _ = [], a = !1);
    super(s.length);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    nt(this, Ka);
    s.forEach((l, f) => {
      this[f] = l;
    });
    const c = _.reduce((l, f) => (typeof f == "string" && l.set(f, (l.get(f) || 0) + 1), l), /* @__PURE__ */ new Map());
    if (Iw(this, Object.freeze(s.map((l, f) => {
      const w = _[f];
      return w != null && c.get(w) === 1 ? w : null;
    }))), K(this, Ka, []), A(this, Ka) == null && A(this, Ka), !a)
      return;
    Object.freeze(this);
    const u = new Proxy(this, {
      get: (l, f, w) => {
        if (typeof f == "string") {
          if (f.match(/^[0-9]+$/)) {
            const v = Ft(f, "%index");
            if (v < 0 || v >= this.length)
              throw new RangeError("out of result range");
            const x = l[v];
            return x instanceof Error && Kc(`index ${v}`, x), x;
          }
          if (_S.indexOf(f) >= 0)
            return Reflect.get(l, f, w);
          const y = l[f];
          if (y instanceof Function)
            return function(...v) {
              return y.apply(this === w ? l : this, v);
            };
          if (!(f in l))
            return l.getValue.apply(this === w ? l : this, [f]);
        }
        return Reflect.get(l, f, w);
      }
    });
    return Iw(u, ks(this)), u;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(e) {
    const r = [];
    return this.forEach((s, _) => {
      s instanceof Error && Kc(`index ${_}`, s), e && s instanceof Sa && (s = s.toArray(e)), r.push(s);
    }), r;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(e) {
    const r = ks(this);
    return r.reduce((s, _, a) => (ht(_ != null, `value at index ${a} unnamed`, "UNSUPPORTED_OPERATION", {
      operation: "toObject()"
    }), nh(r, this, e)), {});
  }
  /**
   *  @_ignore
   */
  slice(e, r) {
    e == null && (e = 0), e < 0 && (e += this.length, e < 0 && (e = 0)), r == null && (r = this.length), r < 0 && (r += this.length, r < 0 && (r = 0)), r > this.length && (r = this.length);
    const s = ks(this), _ = [], a = [];
    for (let c = e; c < r; c++)
      _.push(this[c]), a.push(s[c]);
    return new Sa(Gu, _, a);
  }
  /**
   *  @_ignore
   */
  filter(e, r) {
    const s = ks(this), _ = [], a = [];
    for (let c = 0; c < this.length; c++) {
      const u = this[c];
      u instanceof Error && Kc(`index ${c}`, u), e.call(r, u, c, this) && (_.push(u), a.push(s[c]));
    }
    return new Sa(Gu, _, a);
  }
  /**
   *  @_ignore
   */
  map(e, r) {
    const s = [];
    for (let _ = 0; _ < this.length; _++) {
      const a = this[_];
      a instanceof Error && Kc(`index ${_}`, a), s.push(e.call(r, a, _, this));
    }
    return s;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(e) {
    const r = ks(this).indexOf(e);
    if (r === -1)
      return;
    const s = this[r];
    return s instanceof Error && Kc(`property ${JSON.stringify(e)}`, s.error), s;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(e, r) {
    return new Sa(Gu, e, r);
  }
};
Ka = new WeakMap();
let mc = Sa;
function Nw(n) {
  let t = Ne(n);
  return ht(t.length <= Oe, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: t, length: Oe, offset: t.length }), t.length !== Oe && (t = Ie(pe([rh.slice(t.length % Oe), t]))), t;
}
class $i {
  constructor(t, e, r, s) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    $(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    $(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    $(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    $(this, "dynamic");
    Bt(this, { name: t, type: e, localName: r, dynamic: s }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(t, e) {
    W(!1, t, this.localName, e);
  }
}
var Oi, s_, Da, Wu;
class ih {
  constructor() {
    nt(this, Da);
    // An array of WordSize lengthed objects to concatenation
    nt(this, Oi);
    nt(this, s_);
    K(this, Oi, []), K(this, s_, 0);
  }
  get data() {
    return pe(A(this, Oi));
  }
  get length() {
    return A(this, s_);
  }
  appendWriter(t) {
    return At(this, Da, Wu).call(this, Ie(t.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(t) {
    let e = Ie(t);
    const r = e.length % Oe;
    return r && (e = Ie(pe([e, rh.slice(r)]))), At(this, Da, Wu).call(this, e);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(t) {
    return At(this, Da, Wu).call(this, Nw(t));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const t = A(this, Oi).length;
    return A(this, Oi).push(rh), K(this, s_, A(this, s_) + Oe), (e) => {
      A(this, Oi)[t] = Nw(e);
    };
  }
}
Oi = new WeakMap(), s_ = new WeakMap(), Da = new WeakSet(), Wu = function(t) {
  return A(this, Oi).push(t), K(this, s_, A(this, s_) + t.length), t.length;
};
var De, $e, __, o_, as, B_, _h, uA;
const yw = class yw {
  constructor(t, e, r) {
    nt(this, B_);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    $(this, "allowLoose");
    nt(this, De);
    nt(this, $e);
    nt(this, __);
    nt(this, o_);
    nt(this, as);
    Bt(this, { allowLoose: !!e }), K(this, De, Ie(t)), K(this, __, 0), K(this, o_, null), K(this, as, r ?? 1024), K(this, $e, 0);
  }
  get data() {
    return Rt(A(this, De));
  }
  get dataLength() {
    return A(this, De).length;
  }
  get consumed() {
    return A(this, $e);
  }
  get bytes() {
    return new Uint8Array(A(this, De));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(t) {
    const e = new yw(A(this, De).slice(A(this, $e) + t), this.allowLoose, A(this, as));
    return K(e, o_, this), e;
  }
  // Read bytes
  readBytes(t, e) {
    let r = At(this, B_, uA).call(this, 0, t, !!e);
    return At(this, B_, _h).call(this, t), K(this, $e, A(this, $e) + r.length), r.slice(0, t);
  }
  // Read a numeric values
  readValue() {
    return Dh(this.readBytes(Oe));
  }
  readIndex() {
    return jm(this.readBytes(Oe));
  }
};
De = new WeakMap(), $e = new WeakMap(), __ = new WeakMap(), o_ = new WeakMap(), as = new WeakMap(), B_ = new WeakSet(), _h = function(t) {
  var e;
  if (A(this, o_))
    return At(e = A(this, o_), B_, _h).call(e, t);
  K(this, __, A(this, __) + t), ht(A(this, as) < 1 || A(this, __) <= A(this, as) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${A(this, as)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: Ie(A(this, De)),
    offset: A(this, $e),
    length: t,
    info: {
      bytesRead: A(this, __),
      dataLength: this.dataLength
    }
  });
}, uA = function(t, e, r) {
  let s = Math.ceil(e / Oe) * Oe;
  return A(this, $e) + s > A(this, De).length && (this.allowLoose && r && A(this, $e) + e <= A(this, De).length ? s = e : ht(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
    buffer: Ie(A(this, De)),
    length: A(this, De).length,
    offset: A(this, $e) + s
  })), A(this, De).slice(A(this, $e), A(this, $e) + s);
};
let sh = yw;
function ff(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function Lh(n, ...t) {
  if (!(n instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(n.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${n.length}`);
}
function oS(n) {
  if (typeof n != "function" || typeof n.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  ff(n.outputLen), ff(n.blockLen);
}
function Sc(n, t = !0) {
  if (n.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && n.finished)
    throw new Error("Hash#digest() has already been called");
}
function fA(n, t) {
  Lh(n);
  const e = t.outputLen;
  if (n.length < e)
    throw new Error(`digestInto() expects output buffer of length at least ${e}`);
}
const Al = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const lA = (n) => n instanceof Uint8Array, aS = (n) => new Uint32Array(n.buffer, n.byteOffset, Math.floor(n.byteLength / 4)), ml = (n) => new DataView(n.buffer, n.byteOffset, n.byteLength), Cr = (n, t) => n << 32 - t | n >>> t, cS = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!cS)
  throw new Error("Non little-endian hardware is not supported");
function uS(n) {
  if (typeof n != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof n}`);
  return new Uint8Array(new TextEncoder().encode(n));
}
function kf(n) {
  if (typeof n == "string" && (n = uS(n)), !lA(n))
    throw new Error(`expected Uint8Array, got ${typeof n}`);
  return n;
}
function fS(...n) {
  const t = new Uint8Array(n.reduce((r, s) => r + s.length, 0));
  let e = 0;
  return n.forEach((r) => {
    if (!lA(r))
      throw new Error("Uint8Array expected");
    t.set(r, e), e += r.length;
  }), t;
}
class jh {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function Vh(n) {
  const t = (r) => n().update(kf(r)).digest(), e = n();
  return t.outputLen = e.outputLen, t.blockLen = e.blockLen, t.create = () => n(), t;
}
function lS(n = 32) {
  if (Al && typeof Al.getRandomValues == "function")
    return Al.getRandomValues(new Uint8Array(n));
  throw new Error("crypto.getRandomValues must be defined");
}
class pA extends jh {
  constructor(t, e) {
    super(), this.finished = !1, this.destroyed = !1, oS(t);
    const r = kf(e);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, _ = new Uint8Array(s);
    _.set(r.length > s ? t.create().update(r).digest() : r);
    for (let a = 0; a < _.length; a++)
      _[a] ^= 54;
    this.iHash.update(_), this.oHash = t.create();
    for (let a = 0; a < _.length; a++)
      _[a] ^= 106;
    this.oHash.update(_), _.fill(0);
  }
  update(t) {
    return Sc(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Sc(this), Lh(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: e, iHash: r, finished: s, destroyed: _, blockLen: a, outputLen: c } = this;
    return t = t, t.finished = s, t.destroyed = _, t.blockLen = a, t.outputLen = c, t.oHash = e._cloneInto(t.oHash), t.iHash = r._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const hA = (n, t, e) => new pA(n, t).update(e).digest();
hA.create = (n, t) => new pA(n, t);
function pS(n, t, e, r) {
  if (typeof n.setBigUint64 == "function")
    return n.setBigUint64(t, e, r);
  const s = BigInt(32), _ = BigInt(4294967295), a = Number(e >> s & _), c = Number(e & _), u = r ? 4 : 0, l = r ? 0 : 4;
  n.setUint32(t + u, a, r), n.setUint32(t + l, c, r);
}
class wA extends jh {
  constructor(t, e, r, s) {
    super(), this.blockLen = t, this.outputLen = e, this.padOffset = r, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = ml(this.buffer);
  }
  update(t) {
    Sc(this);
    const { view: e, buffer: r, blockLen: s } = this;
    t = kf(t);
    const _ = t.length;
    for (let a = 0; a < _; ) {
      const c = Math.min(s - this.pos, _ - a);
      if (c === s) {
        const u = ml(t);
        for (; s <= _ - a; a += s)
          this.process(u, a);
        continue;
      }
      r.set(t.subarray(a, a + c), this.pos), this.pos += c, a += c, this.pos === s && (this.process(e, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Sc(this), fA(t, this), this.finished = !0;
    const { buffer: e, view: r, blockLen: s, isLE: _ } = this;
    let { pos: a } = this;
    e[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > s - a && (this.process(r, 0), a = 0);
    for (let w = a; w < s; w++)
      e[w] = 0;
    pS(r, s - 8, BigInt(this.length * 8), _), this.process(r, 0);
    const c = ml(t), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = u / 4, f = this.get();
    if (l > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let w = 0; w < l; w++)
      c.setUint32(4 * w, f[w], _);
  }
  digest() {
    const { buffer: t, outputLen: e } = this;
    this.digestInto(t);
    const r = t.slice(0, e);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: e, buffer: r, length: s, finished: _, destroyed: a, pos: c } = this;
    return t.length = s, t.pos = c, t.finished = _, t.destroyed = a, s % e && t.buffer.set(r), t;
  }
}
const hS = (n, t, e) => n & t ^ ~n & e, wS = (n, t, e) => n & t ^ n & e ^ t & e, dS = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), ts = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), es = /* @__PURE__ */ new Uint32Array(64);
class gS extends wA {
  constructor() {
    super(64, 32, 8, !1), this.A = ts[0] | 0, this.B = ts[1] | 0, this.C = ts[2] | 0, this.D = ts[3] | 0, this.E = ts[4] | 0, this.F = ts[5] | 0, this.G = ts[6] | 0, this.H = ts[7] | 0;
  }
  get() {
    const { A: t, B: e, C: r, D: s, E: _, F: a, G: c, H: u } = this;
    return [t, e, r, s, _, a, c, u];
  }
  // prettier-ignore
  set(t, e, r, s, _, a, c, u) {
    this.A = t | 0, this.B = e | 0, this.C = r | 0, this.D = s | 0, this.E = _ | 0, this.F = a | 0, this.G = c | 0, this.H = u | 0;
  }
  process(t, e) {
    for (let w = 0; w < 16; w++, e += 4)
      es[w] = t.getUint32(e, !1);
    for (let w = 16; w < 64; w++) {
      const y = es[w - 15], v = es[w - 2], x = Cr(y, 7) ^ Cr(y, 18) ^ y >>> 3, C = Cr(v, 17) ^ Cr(v, 19) ^ v >>> 10;
      es[w] = C + es[w - 7] + x + es[w - 16] | 0;
    }
    let { A: r, B: s, C: _, D: a, E: c, F: u, G: l, H: f } = this;
    for (let w = 0; w < 64; w++) {
      const y = Cr(c, 6) ^ Cr(c, 11) ^ Cr(c, 25), v = f + y + hS(c, u, l) + dS[w] + es[w] | 0, C = (Cr(r, 2) ^ Cr(r, 13) ^ Cr(r, 22)) + wS(r, s, _) | 0;
      f = l, l = u, u = c, c = a + v | 0, a = _, _ = s, s = r, r = v + C | 0;
    }
    r = r + this.A | 0, s = s + this.B | 0, _ = _ + this.C | 0, a = a + this.D | 0, c = c + this.E | 0, u = u + this.F | 0, l = l + this.G | 0, f = f + this.H | 0, this.set(r, s, _, a, c, u, l, f);
  }
  roundClean() {
    es.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const dA = /* @__PURE__ */ Vh(() => new gS()), Uu = /* @__PURE__ */ BigInt(2 ** 32 - 1), oh = /* @__PURE__ */ BigInt(32);
function gA(n, t = !1) {
  return t ? { h: Number(n & Uu), l: Number(n >> oh & Uu) } : { h: Number(n >> oh & Uu) | 0, l: Number(n & Uu) | 0 };
}
function bA(n, t = !1) {
  let e = new Uint32Array(n.length), r = new Uint32Array(n.length);
  for (let s = 0; s < n.length; s++) {
    const { h: _, l: a } = gA(n[s], t);
    [e[s], r[s]] = [_, a];
  }
  return [e, r];
}
const bS = (n, t) => BigInt(n >>> 0) << oh | BigInt(t >>> 0), yS = (n, t, e) => n >>> e, AS = (n, t, e) => n << 32 - e | t >>> e, mS = (n, t, e) => n >>> e | t << 32 - e, SS = (n, t, e) => n << 32 - e | t >>> e, RS = (n, t, e) => n << 64 - e | t >>> e - 32, ES = (n, t, e) => n >>> e - 32 | t << 64 - e, PS = (n, t) => t, zS = (n, t) => n, yA = (n, t, e) => n << e | t >>> 32 - e, AA = (n, t, e) => t << e | n >>> 32 - e, mA = (n, t, e) => t << e - 32 | n >>> 64 - e, SA = (n, t, e) => n << e - 32 | t >>> 64 - e;
function vS(n, t, e, r) {
  const s = (t >>> 0) + (r >>> 0);
  return { h: n + e + (s / 2 ** 32 | 0) | 0, l: s | 0 };
}
const MS = (n, t, e) => (n >>> 0) + (t >>> 0) + (e >>> 0), xS = (n, t, e, r) => t + e + r + (n / 2 ** 32 | 0) | 0, BS = (n, t, e, r) => (n >>> 0) + (t >>> 0) + (e >>> 0) + (r >>> 0), CS = (n, t, e, r, s) => t + e + r + s + (n / 2 ** 32 | 0) | 0, IS = (n, t, e, r, s) => (n >>> 0) + (t >>> 0) + (e >>> 0) + (r >>> 0) + (s >>> 0), NS = (n, t, e, r, s, _) => t + e + r + s + _ + (n / 2 ** 32 | 0) | 0, Gt = {
  fromBig: gA,
  split: bA,
  toBig: bS,
  shrSH: yS,
  shrSL: AS,
  rotrSH: mS,
  rotrSL: SS,
  rotrBH: RS,
  rotrBL: ES,
  rotr32H: PS,
  rotr32L: zS,
  rotlSH: yA,
  rotlSL: AA,
  rotlBH: mA,
  rotlBL: SA,
  add: vS,
  add3L: MS,
  add3H: xS,
  add4L: BS,
  add4H: CS,
  add5H: NS,
  add5L: IS
}, [OS, kS] = Gt.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))), rs = /* @__PURE__ */ new Uint32Array(80), ns = /* @__PURE__ */ new Uint32Array(80);
class TS extends wA {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: e, Bh: r, Bl: s, Ch: _, Cl: a, Dh: c, Dl: u, Eh: l, El: f, Fh: w, Fl: y, Gh: v, Gl: x, Hh: C, Hl: U } = this;
    return [t, e, r, s, _, a, c, u, l, f, w, y, v, x, C, U];
  }
  // prettier-ignore
  set(t, e, r, s, _, a, c, u, l, f, w, y, v, x, C, U) {
    this.Ah = t | 0, this.Al = e | 0, this.Bh = r | 0, this.Bl = s | 0, this.Ch = _ | 0, this.Cl = a | 0, this.Dh = c | 0, this.Dl = u | 0, this.Eh = l | 0, this.El = f | 0, this.Fh = w | 0, this.Fl = y | 0, this.Gh = v | 0, this.Gl = x | 0, this.Hh = C | 0, this.Hl = U | 0;
  }
  process(t, e) {
    for (let N = 0; N < 16; N++, e += 4)
      rs[N] = t.getUint32(e), ns[N] = t.getUint32(e += 4);
    for (let N = 16; N < 80; N++) {
      const I = rs[N - 15] | 0, G = ns[N - 15] | 0, D = Gt.rotrSH(I, G, 1) ^ Gt.rotrSH(I, G, 8) ^ Gt.shrSH(I, G, 7), j = Gt.rotrSL(I, G, 1) ^ Gt.rotrSL(I, G, 8) ^ Gt.shrSL(I, G, 7), L = rs[N - 2] | 0, X = ns[N - 2] | 0, et = Gt.rotrSH(L, X, 19) ^ Gt.rotrBH(L, X, 61) ^ Gt.shrSH(L, X, 6), lt = Gt.rotrSL(L, X, 19) ^ Gt.rotrBL(L, X, 61) ^ Gt.shrSL(L, X, 6), Y = Gt.add4L(j, lt, ns[N - 7], ns[N - 16]), Et = Gt.add4H(Y, D, et, rs[N - 7], rs[N - 16]);
      rs[N] = Et | 0, ns[N] = Y | 0;
    }
    let { Ah: r, Al: s, Bh: _, Bl: a, Ch: c, Cl: u, Dh: l, Dl: f, Eh: w, El: y, Fh: v, Fl: x, Gh: C, Gl: U, Hh: z, Hl: M } = this;
    for (let N = 0; N < 80; N++) {
      const I = Gt.rotrSH(w, y, 14) ^ Gt.rotrSH(w, y, 18) ^ Gt.rotrBH(w, y, 41), G = Gt.rotrSL(w, y, 14) ^ Gt.rotrSL(w, y, 18) ^ Gt.rotrBL(w, y, 41), D = w & v ^ ~w & C, j = y & x ^ ~y & U, L = Gt.add5L(M, G, j, kS[N], ns[N]), X = Gt.add5H(L, z, I, D, OS[N], rs[N]), et = L | 0, lt = Gt.rotrSH(r, s, 28) ^ Gt.rotrBH(r, s, 34) ^ Gt.rotrBH(r, s, 39), Y = Gt.rotrSL(r, s, 28) ^ Gt.rotrBL(r, s, 34) ^ Gt.rotrBL(r, s, 39), Et = r & _ ^ r & c ^ _ & c, Ct = s & a ^ s & u ^ a & u;
      z = C | 0, M = U | 0, C = v | 0, U = x | 0, v = w | 0, x = y | 0, { h: w, l: y } = Gt.add(l | 0, f | 0, X | 0, et | 0), l = c | 0, f = u | 0, c = _ | 0, u = a | 0, _ = r | 0, a = s | 0;
      const pt = Gt.add3L(et, Y, Ct);
      r = Gt.add3H(pt, X, lt, Et), s = pt | 0;
    }
    ({ h: r, l: s } = Gt.add(this.Ah | 0, this.Al | 0, r | 0, s | 0)), { h: _, l: a } = Gt.add(this.Bh | 0, this.Bl | 0, _ | 0, a | 0), { h: c, l: u } = Gt.add(this.Ch | 0, this.Cl | 0, c | 0, u | 0), { h: l, l: f } = Gt.add(this.Dh | 0, this.Dl | 0, l | 0, f | 0), { h: w, l: y } = Gt.add(this.Eh | 0, this.El | 0, w | 0, y | 0), { h: v, l: x } = Gt.add(this.Fh | 0, this.Fl | 0, v | 0, x | 0), { h: C, l: U } = Gt.add(this.Gh | 0, this.Gl | 0, C | 0, U | 0), { h: z, l: M } = Gt.add(this.Hh | 0, this.Hl | 0, z | 0, M | 0), this.set(r, s, _, a, c, u, l, f, w, y, v, x, C, U, z, M);
  }
  roundClean() {
    rs.fill(0), ns.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const GS = /* @__PURE__ */ Vh(() => new TS());
function US() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof Ac < "u")
    return Ac;
  throw new Error("unable to locate global object");
}
const Ow = US();
Ow.crypto || Ow.msCrypto;
function FS(n) {
  switch (n) {
    case "sha256":
      return dA.create();
    case "sha512":
      return GS.create();
  }
  W(!1, "invalid hashing algorithm name", "algorithm", n);
}
const [RA, EA, PA] = [[], [], []], KS = /* @__PURE__ */ BigInt(0), Dc = /* @__PURE__ */ BigInt(1), DS = /* @__PURE__ */ BigInt(2), LS = /* @__PURE__ */ BigInt(7), jS = /* @__PURE__ */ BigInt(256), VS = /* @__PURE__ */ BigInt(113);
for (let n = 0, t = Dc, e = 1, r = 0; n < 24; n++) {
  [e, r] = [r, (2 * e + 3 * r) % 5], RA.push(2 * (5 * r + e)), EA.push((n + 1) * (n + 2) / 2 % 64);
  let s = KS;
  for (let _ = 0; _ < 7; _++)
    t = (t << Dc ^ (t >> LS) * VS) % jS, t & DS && (s ^= Dc << (Dc << /* @__PURE__ */ BigInt(_)) - Dc);
  PA.push(s);
}
const [YS, HS] = /* @__PURE__ */ bA(PA, !0), kw = (n, t, e) => e > 32 ? mA(n, t, e) : yA(n, t, e), Tw = (n, t, e) => e > 32 ? SA(n, t, e) : AA(n, t, e);
function qS(n, t = 24) {
  const e = new Uint32Array(10);
  for (let r = 24 - t; r < 24; r++) {
    for (let a = 0; a < 10; a++)
      e[a] = n[a] ^ n[a + 10] ^ n[a + 20] ^ n[a + 30] ^ n[a + 40];
    for (let a = 0; a < 10; a += 2) {
      const c = (a + 8) % 10, u = (a + 2) % 10, l = e[u], f = e[u + 1], w = kw(l, f, 1) ^ e[c], y = Tw(l, f, 1) ^ e[c + 1];
      for (let v = 0; v < 50; v += 10)
        n[a + v] ^= w, n[a + v + 1] ^= y;
    }
    let s = n[2], _ = n[3];
    for (let a = 0; a < 24; a++) {
      const c = EA[a], u = kw(s, _, c), l = Tw(s, _, c), f = RA[a];
      s = n[f], _ = n[f + 1], n[f] = u, n[f + 1] = l;
    }
    for (let a = 0; a < 50; a += 10) {
      for (let c = 0; c < 10; c++)
        e[c] = n[a + c];
      for (let c = 0; c < 10; c++)
        n[a + c] ^= ~e[(c + 2) % 10] & e[(c + 4) % 10];
    }
    n[0] ^= YS[r], n[1] ^= HS[r];
  }
  e.fill(0);
}
class Yh extends jh {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, e, r, s = !1, _ = 24) {
    if (super(), this.blockLen = t, this.suffix = e, this.outputLen = r, this.enableXOF = s, this.rounds = _, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, ff(r), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = aS(this.state);
  }
  keccak() {
    qS(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    Sc(this);
    const { blockLen: e, state: r } = this;
    t = kf(t);
    const s = t.length;
    for (let _ = 0; _ < s; ) {
      const a = Math.min(e - this.pos, s - _);
      for (let c = 0; c < a; c++)
        r[this.pos++] ^= t[_++];
      this.pos === e && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: e, pos: r, blockLen: s } = this;
    t[r] ^= e, (e & 128) !== 0 && r === s - 1 && this.keccak(), t[s - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    Sc(this, !1), Lh(t), this.finish();
    const e = this.state, { blockLen: r } = this;
    for (let s = 0, _ = t.length; s < _; ) {
      this.posOut >= r && this.keccak();
      const a = Math.min(r - this.posOut, _ - s);
      t.set(e.subarray(this.posOut, this.posOut + a), s), this.posOut += a, s += a;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return ff(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (fA(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: e, suffix: r, outputLen: s, rounds: _, enableXOF: a } = this;
    return t || (t = new Yh(e, r, s, a, _)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = _, t.suffix = r, t.outputLen = s, t.enableXOF = a, t.destroyed = this.destroyed, t;
  }
}
const QS = (n, t, e) => Vh(() => new Yh(t, n, e)), WS = /* @__PURE__ */ QS(1, 136, 256 / 8);
let zA = !1;
const vA = function(n) {
  return WS(n);
};
let MA = vA;
function de(n) {
  const t = Vt(n, "data");
  return Rt(MA(t));
}
de._ = vA;
de.lock = function() {
  zA = !0;
};
de.register = function(n) {
  if (zA)
    throw new TypeError("keccak256 is locked");
  MA = n;
};
Object.freeze(de);
const xA = function(n) {
  return FS("sha256").update(n).digest();
};
let BA = xA, CA = !1;
function Ic(n) {
  const t = Vt(n, "data");
  return Rt(BA(t));
}
Ic._ = xA;
Ic.lock = function() {
  CA = !0;
};
Ic.register = function(n) {
  if (CA)
    throw new Error("sha256 is locked");
  BA = n;
};
Object.freeze(Ic);
Object.freeze(Ic);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const IA = BigInt(0), Tf = BigInt(1), JS = BigInt(2), Gf = (n) => n instanceof Uint8Array, $S = /* @__PURE__ */ Array.from({ length: 256 }, (n, t) => t.toString(16).padStart(2, "0"));
function Rc(n) {
  if (!Gf(n))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let e = 0; e < n.length; e++)
    t += $S[n[e]];
  return t;
}
function NA(n) {
  const t = n.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function Hh(n) {
  if (typeof n != "string")
    throw new Error("hex string expected, got " + typeof n);
  return BigInt(n === "" ? "0" : `0x${n}`);
}
function Ec(n) {
  if (typeof n != "string")
    throw new Error("hex string expected, got " + typeof n);
  const t = n.length;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const e = new Uint8Array(t / 2);
  for (let r = 0; r < e.length; r++) {
    const s = r * 2, _ = n.slice(s, s + 2), a = Number.parseInt(_, 16);
    if (Number.isNaN(a) || a < 0)
      throw new Error("Invalid byte sequence");
    e[r] = a;
  }
  return e;
}
function y_(n) {
  return Hh(Rc(n));
}
function qh(n) {
  if (!Gf(n))
    throw new Error("Uint8Array expected");
  return Hh(Rc(Uint8Array.from(n).reverse()));
}
function Pc(n, t) {
  return Ec(n.toString(16).padStart(t * 2, "0"));
}
function Qh(n, t) {
  return Pc(n, t).reverse();
}
function ZS(n) {
  return Ec(NA(n));
}
function gr(n, t, e) {
  let r;
  if (typeof t == "string")
    try {
      r = Ec(t);
    } catch (_) {
      throw new Error(`${n} must be valid hex string, got "${t}". Cause: ${_}`);
    }
  else if (Gf(t))
    r = Uint8Array.from(t);
  else
    throw new Error(`${n} must be hex string or Uint8Array`);
  const s = r.length;
  if (typeof e == "number" && s !== e)
    throw new Error(`${n} expected ${e} bytes, got ${s}`);
  return r;
}
function ru(...n) {
  const t = new Uint8Array(n.reduce((r, s) => r + s.length, 0));
  let e = 0;
  return n.forEach((r) => {
    if (!Gf(r))
      throw new Error("Uint8Array expected");
    t.set(r, e), e += r.length;
  }), t;
}
function XS(n, t) {
  if (n.length !== t.length)
    return !1;
  for (let e = 0; e < n.length; e++)
    if (n[e] !== t[e])
      return !1;
  return !0;
}
function tR(n) {
  if (typeof n != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof n}`);
  return new Uint8Array(new TextEncoder().encode(n));
}
function eR(n) {
  let t;
  for (t = 0; n > IA; n >>= Tf, t += 1)
    ;
  return t;
}
function rR(n, t) {
  return n >> BigInt(t) & Tf;
}
const nR = (n, t, e) => n | (e ? Tf : IA) << BigInt(t), Wh = (n) => (JS << BigInt(n - 1)) - Tf, Sl = (n) => new Uint8Array(n), Gw = (n) => Uint8Array.from(n);
function OA(n, t, e) {
  if (typeof n != "number" || n < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof e != "function")
    throw new Error("hmacFn must be a function");
  let r = Sl(n), s = Sl(n), _ = 0;
  const a = () => {
    r.fill(1), s.fill(0), _ = 0;
  }, c = (...w) => e(s, r, ...w), u = (w = Sl()) => {
    s = c(Gw([0]), w), r = c(), w.length !== 0 && (s = c(Gw([1]), w), r = c());
  }, l = () => {
    if (_++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let w = 0;
    const y = [];
    for (; w < t; ) {
      r = c();
      const v = r.slice();
      y.push(v), w += r.length;
    }
    return ru(...y);
  };
  return (w, y) => {
    a(), u(w);
    let v;
    for (; !(v = y(l())); )
      u();
    return a(), v;
  };
}
const iR = {
  bigint: (n) => typeof n == "bigint",
  function: (n) => typeof n == "function",
  boolean: (n) => typeof n == "boolean",
  string: (n) => typeof n == "string",
  stringOrUint8Array: (n) => typeof n == "string" || n instanceof Uint8Array,
  isSafeInteger: (n) => Number.isSafeInteger(n),
  array: (n) => Array.isArray(n),
  field: (n, t) => t.Fp.isValid(n),
  hash: (n) => typeof n == "function" && Number.isSafeInteger(n.outputLen)
};
function vu(n, t, e = {}) {
  const r = (s, _, a) => {
    const c = iR[_];
    if (typeof c != "function")
      throw new Error(`Invalid validator "${_}", expected function`);
    const u = n[s];
    if (!(a && u === void 0) && !c(u, n))
      throw new Error(`Invalid param ${String(s)}=${u} (${typeof u}), expected ${_}`);
  };
  for (const [s, _] of Object.entries(t))
    r(s, _, !1);
  for (const [s, _] of Object.entries(e))
    r(s, _, !0);
  return n;
}
const sR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: rR,
  bitLen: eR,
  bitMask: Wh,
  bitSet: nR,
  bytesToHex: Rc,
  bytesToNumberBE: y_,
  bytesToNumberLE: qh,
  concatBytes: ru,
  createHmacDrbg: OA,
  ensureBytes: gr,
  equalBytes: XS,
  hexToBytes: Ec,
  hexToNumber: Hh,
  numberToBytesBE: Pc,
  numberToBytesLE: Qh,
  numberToHexUnpadded: NA,
  numberToVarBytesBE: ZS,
  utf8ToBytes: tR,
  validateObject: vu
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ae = BigInt(0), fe = BigInt(1), Ts = BigInt(2), _R = BigInt(3), ah = BigInt(4), Uw = BigInt(5), Fw = BigInt(8);
BigInt(9);
BigInt(16);
function je(n, t) {
  const e = n % t;
  return e >= Ae ? e : t + e;
}
function oR(n, t, e) {
  if (e <= Ae || t < Ae)
    throw new Error("Expected power/modulo > 0");
  if (e === fe)
    return Ae;
  let r = fe;
  for (; t > Ae; )
    t & fe && (r = r * n % e), n = n * n % e, t >>= fe;
  return r;
}
function rr(n, t, e) {
  let r = n;
  for (; t-- > Ae; )
    r *= r, r %= e;
  return r;
}
function ch(n, t) {
  if (n === Ae || t <= Ae)
    throw new Error(`invert: expected positive integers, got n=${n} mod=${t}`);
  let e = je(n, t), r = t, s = Ae, _ = fe;
  for (; e !== Ae; ) {
    const c = r / e, u = r % e, l = s - _ * c;
    r = e, e = u, s = _, _ = l;
  }
  if (r !== fe)
    throw new Error("invert: does not exist");
  return je(s, t);
}
function aR(n) {
  const t = (n - fe) / Ts;
  let e, r, s;
  for (e = n - fe, r = 0; e % Ts === Ae; e /= Ts, r++)
    ;
  for (s = Ts; s < n && oR(s, t, n) !== n - fe; s++)
    ;
  if (r === 1) {
    const a = (n + fe) / ah;
    return function(u, l) {
      const f = u.pow(l, a);
      if (!u.eql(u.sqr(f), l))
        throw new Error("Cannot find square root");
      return f;
    };
  }
  const _ = (e + fe) / Ts;
  return function(c, u) {
    if (c.pow(u, t) === c.neg(c.ONE))
      throw new Error("Cannot find square root");
    let l = r, f = c.pow(c.mul(c.ONE, s), e), w = c.pow(u, _), y = c.pow(u, e);
    for (; !c.eql(y, c.ONE); ) {
      if (c.eql(y, c.ZERO))
        return c.ZERO;
      let v = 1;
      for (let C = c.sqr(y); v < l && !c.eql(C, c.ONE); v++)
        C = c.sqr(C);
      const x = c.pow(f, fe << BigInt(l - v - 1));
      f = c.sqr(x), w = c.mul(w, x), y = c.mul(y, f), l = v;
    }
    return w;
  };
}
function cR(n) {
  if (n % ah === _R) {
    const t = (n + fe) / ah;
    return function(r, s) {
      const _ = r.pow(s, t);
      if (!r.eql(r.sqr(_), s))
        throw new Error("Cannot find square root");
      return _;
    };
  }
  if (n % Fw === Uw) {
    const t = (n - Uw) / Fw;
    return function(r, s) {
      const _ = r.mul(s, Ts), a = r.pow(_, t), c = r.mul(s, a), u = r.mul(r.mul(c, Ts), a), l = r.mul(c, r.sub(u, r.ONE));
      if (!r.eql(r.sqr(l), s))
        throw new Error("Cannot find square root");
      return l;
    };
  }
  return aR(n);
}
const uR = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function fR(n) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, e = uR.reduce((r, s) => (r[s] = "function", r), t);
  return vu(n, e);
}
function lR(n, t, e) {
  if (e < Ae)
    throw new Error("Expected power > 0");
  if (e === Ae)
    return n.ONE;
  if (e === fe)
    return t;
  let r = n.ONE, s = t;
  for (; e > Ae; )
    e & fe && (r = n.mul(r, s)), s = n.sqr(s), e >>= fe;
  return r;
}
function pR(n, t) {
  const e = new Array(t.length), r = t.reduce((_, a, c) => n.is0(a) ? _ : (e[c] = _, n.mul(_, a)), n.ONE), s = n.inv(r);
  return t.reduceRight((_, a, c) => n.is0(a) ? _ : (e[c] = n.mul(_, e[c]), n.mul(_, a)), s), e;
}
function kA(n, t) {
  const e = t !== void 0 ? t : n.toString(2).length, r = Math.ceil(e / 8);
  return { nBitLength: e, nByteLength: r };
}
function hR(n, t, e = !1, r = {}) {
  if (n <= Ae)
    throw new Error(`Expected Field ORDER > 0, got ${n}`);
  const { nBitLength: s, nByteLength: _ } = kA(n, t);
  if (_ > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const a = cR(n), c = Object.freeze({
    ORDER: n,
    BITS: s,
    BYTES: _,
    MASK: Wh(s),
    ZERO: Ae,
    ONE: fe,
    create: (u) => je(u, n),
    isValid: (u) => {
      if (typeof u != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof u}`);
      return Ae <= u && u < n;
    },
    is0: (u) => u === Ae,
    isOdd: (u) => (u & fe) === fe,
    neg: (u) => je(-u, n),
    eql: (u, l) => u === l,
    sqr: (u) => je(u * u, n),
    add: (u, l) => je(u + l, n),
    sub: (u, l) => je(u - l, n),
    mul: (u, l) => je(u * l, n),
    pow: (u, l) => lR(c, u, l),
    div: (u, l) => je(u * ch(l, n), n),
    // Same as above, but doesn't normalize
    sqrN: (u) => u * u,
    addN: (u, l) => u + l,
    subN: (u, l) => u - l,
    mulN: (u, l) => u * l,
    inv: (u) => ch(u, n),
    sqrt: r.sqrt || ((u) => a(c, u)),
    invertBatch: (u) => pR(c, u),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (u, l, f) => f ? l : u,
    toBytes: (u) => e ? Qh(u, _) : Pc(u, _),
    fromBytes: (u) => {
      if (u.length !== _)
        throw new Error(`Fp.fromBytes: expected ${_}, got ${u.length}`);
      return e ? qh(u) : y_(u);
    }
  });
  return Object.freeze(c);
}
function TA(n) {
  if (typeof n != "bigint")
    throw new Error("field order must be bigint");
  const t = n.toString(2).length;
  return Math.ceil(t / 8);
}
function GA(n) {
  const t = TA(n);
  return t + Math.ceil(t / 2);
}
function wR(n, t, e = !1) {
  const r = n.length, s = TA(t), _ = GA(t);
  if (r < 16 || r < _ || r > 1024)
    throw new Error(`expected ${_}-1024 bytes of input, got ${r}`);
  const a = e ? y_(n) : qh(n), c = je(a, t - fe) + fe;
  return e ? Qh(c, s) : Pc(c, s);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const dR = BigInt(0), Rl = BigInt(1);
function gR(n, t) {
  const e = (s, _) => {
    const a = _.negate();
    return s ? a : _;
  }, r = (s) => {
    const _ = Math.ceil(t / s) + 1, a = 2 ** (s - 1);
    return { windows: _, windowSize: a };
  };
  return {
    constTimeNegate: e,
    // non-const time multiplication ladder
    unsafeLadder(s, _) {
      let a = n.ZERO, c = s;
      for (; _ > dR; )
        _ & Rl && (a = a.add(c)), c = c.double(), _ >>= Rl;
      return a;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(s, _) {
      const { windows: a, windowSize: c } = r(_), u = [];
      let l = s, f = l;
      for (let w = 0; w < a; w++) {
        f = l, u.push(f);
        for (let y = 1; y < c; y++)
          f = f.add(l), u.push(f);
        l = f.double();
      }
      return u;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(s, _, a) {
      const { windows: c, windowSize: u } = r(s);
      let l = n.ZERO, f = n.BASE;
      const w = BigInt(2 ** s - 1), y = 2 ** s, v = BigInt(s);
      for (let x = 0; x < c; x++) {
        const C = x * u;
        let U = Number(a & w);
        a >>= v, U > u && (U -= y, a += Rl);
        const z = C, M = C + Math.abs(U) - 1, N = x % 2 !== 0, I = U < 0;
        U === 0 ? f = f.add(e(N, _[z])) : l = l.add(e(I, _[M]));
      }
      return { p: l, f };
    },
    wNAFCached(s, _, a, c) {
      const u = s._WINDOW_SIZE || 1;
      let l = _.get(s);
      return l || (l = this.precomputeWindow(s, u), u !== 1 && _.set(s, c(l))), this.wNAF(u, l, a);
    }
  };
}
function UA(n) {
  return fR(n.Fp), vu(n, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...kA(n.n, n.nBitLength),
    ...n,
    p: n.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function bR(n) {
  const t = UA(n);
  vu(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: e, Fp: r, a: s } = t;
  if (e) {
    if (!r.eql(s, r.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof e != "object" || typeof e.beta != "bigint" || typeof e.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: yR, hexToBytes: AR } = sR, Ls = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  _parseInt(n) {
    const { Err: t } = Ls;
    if (n.length < 2 || n[0] !== 2)
      throw new t("Invalid signature integer tag");
    const e = n[1], r = n.subarray(2, e + 2);
    if (!e || r.length !== e)
      throw new t("Invalid signature integer: wrong length");
    if (r[0] & 128)
      throw new t("Invalid signature integer: negative");
    if (r[0] === 0 && !(r[1] & 128))
      throw new t("Invalid signature integer: unnecessary leading zero");
    return { d: yR(r), l: n.subarray(e + 2) };
  },
  toSig(n) {
    const { Err: t } = Ls, e = typeof n == "string" ? AR(n) : n;
    if (!(e instanceof Uint8Array))
      throw new Error("ui8a expected");
    let r = e.length;
    if (r < 2 || e[0] != 48)
      throw new t("Invalid signature tag");
    if (e[1] !== r - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: s, l: _ } = Ls._parseInt(e.subarray(2)), { d: a, l: c } = Ls._parseInt(_);
    if (c.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: s, s: a };
  },
  hexFromSig(n) {
    const t = (l) => Number.parseInt(l[0], 16) & 8 ? "00" + l : l, e = (l) => {
      const f = l.toString(16);
      return f.length & 1 ? `0${f}` : f;
    }, r = t(e(n.s)), s = t(e(n.r)), _ = r.length / 2, a = s.length / 2, c = e(_), u = e(a);
    return `30${e(a + _ + 4)}02${u}${s}02${c}${r}`;
  }
}, Vi = BigInt(0), lr = BigInt(1);
BigInt(2);
const Kw = BigInt(3);
BigInt(4);
function mR(n) {
  const t = bR(n), { Fp: e } = t, r = t.toBytes || ((x, C, U) => {
    const z = C.toAffine();
    return ru(Uint8Array.from([4]), e.toBytes(z.x), e.toBytes(z.y));
  }), s = t.fromBytes || ((x) => {
    const C = x.subarray(1), U = e.fromBytes(C.subarray(0, e.BYTES)), z = e.fromBytes(C.subarray(e.BYTES, 2 * e.BYTES));
    return { x: U, y: z };
  });
  function _(x) {
    const { a: C, b: U } = t, z = e.sqr(x), M = e.mul(z, x);
    return e.add(e.add(M, e.mul(x, C)), U);
  }
  if (!e.eql(e.sqr(t.Gy), _(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function a(x) {
    return typeof x == "bigint" && Vi < x && x < t.n;
  }
  function c(x) {
    if (!a(x))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function u(x) {
    const { allowedPrivateKeyLengths: C, nByteLength: U, wrapPrivateKey: z, n: M } = t;
    if (C && typeof x != "bigint") {
      if (x instanceof Uint8Array && (x = Rc(x)), typeof x != "string" || !C.includes(x.length))
        throw new Error("Invalid key");
      x = x.padStart(U * 2, "0");
    }
    let N;
    try {
      N = typeof x == "bigint" ? x : y_(gr("private key", x, U));
    } catch {
      throw new Error(`private key must be ${U} bytes, hex or bigint, not ${typeof x}`);
    }
    return z && (N = je(N, M)), c(N), N;
  }
  const l = /* @__PURE__ */ new Map();
  function f(x) {
    if (!(x instanceof w))
      throw new Error("ProjectivePoint expected");
  }
  class w {
    constructor(C, U, z) {
      if (this.px = C, this.py = U, this.pz = z, C == null || !e.isValid(C))
        throw new Error("x required");
      if (U == null || !e.isValid(U))
        throw new Error("y required");
      if (z == null || !e.isValid(z))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(C) {
      const { x: U, y: z } = C || {};
      if (!C || !e.isValid(U) || !e.isValid(z))
        throw new Error("invalid affine point");
      if (C instanceof w)
        throw new Error("projective point not allowed");
      const M = (N) => e.eql(N, e.ZERO);
      return M(U) && M(z) ? w.ZERO : new w(U, z, e.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(C) {
      const U = e.invertBatch(C.map((z) => z.pz));
      return C.map((z, M) => z.toAffine(U[M])).map(w.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(C) {
      const U = w.fromAffine(s(gr("pointHex", C)));
      return U.assertValidity(), U;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(C) {
      return w.BASE.multiply(u(C));
    }
    // "Private method", don't use it directly
    _setWindowSize(C) {
      this._WINDOW_SIZE = C, l.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint && !e.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: C, y: U } = this.toAffine();
      if (!e.isValid(C) || !e.isValid(U))
        throw new Error("bad point: x or y not FE");
      const z = e.sqr(U), M = _(C);
      if (!e.eql(z, M))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: C } = this.toAffine();
      if (e.isOdd)
        return !e.isOdd(C);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(C) {
      f(C);
      const { px: U, py: z, pz: M } = this, { px: N, py: I, pz: G } = C, D = e.eql(e.mul(U, G), e.mul(N, M)), j = e.eql(e.mul(z, G), e.mul(I, M));
      return D && j;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new w(this.px, e.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: C, b: U } = t, z = e.mul(U, Kw), { px: M, py: N, pz: I } = this;
      let G = e.ZERO, D = e.ZERO, j = e.ZERO, L = e.mul(M, M), X = e.mul(N, N), et = e.mul(I, I), lt = e.mul(M, N);
      return lt = e.add(lt, lt), j = e.mul(M, I), j = e.add(j, j), G = e.mul(C, j), D = e.mul(z, et), D = e.add(G, D), G = e.sub(X, D), D = e.add(X, D), D = e.mul(G, D), G = e.mul(lt, G), j = e.mul(z, j), et = e.mul(C, et), lt = e.sub(L, et), lt = e.mul(C, lt), lt = e.add(lt, j), j = e.add(L, L), L = e.add(j, L), L = e.add(L, et), L = e.mul(L, lt), D = e.add(D, L), et = e.mul(N, I), et = e.add(et, et), L = e.mul(et, lt), G = e.sub(G, L), j = e.mul(et, X), j = e.add(j, j), j = e.add(j, j), new w(G, D, j);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(C) {
      f(C);
      const { px: U, py: z, pz: M } = this, { px: N, py: I, pz: G } = C;
      let D = e.ZERO, j = e.ZERO, L = e.ZERO;
      const X = t.a, et = e.mul(t.b, Kw);
      let lt = e.mul(U, N), Y = e.mul(z, I), Et = e.mul(M, G), Ct = e.add(U, z), pt = e.add(N, I);
      Ct = e.mul(Ct, pt), pt = e.add(lt, Y), Ct = e.sub(Ct, pt), pt = e.add(U, M);
      let wt = e.add(N, G);
      return pt = e.mul(pt, wt), wt = e.add(lt, Et), pt = e.sub(pt, wt), wt = e.add(z, M), D = e.add(I, G), wt = e.mul(wt, D), D = e.add(Y, Et), wt = e.sub(wt, D), L = e.mul(X, pt), D = e.mul(et, Et), L = e.add(D, L), D = e.sub(Y, L), L = e.add(Y, L), j = e.mul(D, L), Y = e.add(lt, lt), Y = e.add(Y, lt), Et = e.mul(X, Et), pt = e.mul(et, pt), Y = e.add(Y, Et), Et = e.sub(lt, Et), Et = e.mul(X, Et), pt = e.add(pt, Et), lt = e.mul(Y, pt), j = e.add(j, lt), lt = e.mul(wt, pt), D = e.mul(Ct, D), D = e.sub(D, lt), lt = e.mul(Ct, Y), L = e.mul(wt, L), L = e.add(L, lt), new w(D, j, L);
    }
    subtract(C) {
      return this.add(C.negate());
    }
    is0() {
      return this.equals(w.ZERO);
    }
    wNAF(C) {
      return v.wNAFCached(this, l, C, (U) => {
        const z = e.invertBatch(U.map((M) => M.pz));
        return U.map((M, N) => M.toAffine(z[N])).map(w.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(C) {
      const U = w.ZERO;
      if (C === Vi)
        return U;
      if (c(C), C === lr)
        return this;
      const { endo: z } = t;
      if (!z)
        return v.unsafeLadder(this, C);
      let { k1neg: M, k1: N, k2neg: I, k2: G } = z.splitScalar(C), D = U, j = U, L = this;
      for (; N > Vi || G > Vi; )
        N & lr && (D = D.add(L)), G & lr && (j = j.add(L)), L = L.double(), N >>= lr, G >>= lr;
      return M && (D = D.negate()), I && (j = j.negate()), j = new w(e.mul(j.px, z.beta), j.py, j.pz), D.add(j);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(C) {
      c(C);
      let U = C, z, M;
      const { endo: N } = t;
      if (N) {
        const { k1neg: I, k1: G, k2neg: D, k2: j } = N.splitScalar(U);
        let { p: L, f: X } = this.wNAF(G), { p: et, f: lt } = this.wNAF(j);
        L = v.constTimeNegate(I, L), et = v.constTimeNegate(D, et), et = new w(e.mul(et.px, N.beta), et.py, et.pz), z = L.add(et), M = X.add(lt);
      } else {
        const { p: I, f: G } = this.wNAF(U);
        z = I, M = G;
      }
      return w.normalizeZ([z, M])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(C, U, z) {
      const M = w.BASE, N = (G, D) => D === Vi || D === lr || !G.equals(M) ? G.multiplyUnsafe(D) : G.multiply(D), I = N(this, U).add(N(C, z));
      return I.is0() ? void 0 : I;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(C) {
      const { px: U, py: z, pz: M } = this, N = this.is0();
      C == null && (C = N ? e.ONE : e.inv(M));
      const I = e.mul(U, C), G = e.mul(z, C), D = e.mul(M, C);
      if (N)
        return { x: e.ZERO, y: e.ZERO };
      if (!e.eql(D, e.ONE))
        throw new Error("invZ was invalid");
      return { x: I, y: G };
    }
    isTorsionFree() {
      const { h: C, isTorsionFree: U } = t;
      if (C === lr)
        return !0;
      if (U)
        return U(w, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: C, clearCofactor: U } = t;
      return C === lr ? this : U ? U(w, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(C = !0) {
      return this.assertValidity(), r(w, this, C);
    }
    toHex(C = !0) {
      return Rc(this.toRawBytes(C));
    }
  }
  w.BASE = new w(t.Gx, t.Gy, e.ONE), w.ZERO = new w(e.ZERO, e.ONE, e.ZERO);
  const y = t.nBitLength, v = gR(w, t.endo ? Math.ceil(y / 2) : y);
  return {
    CURVE: t,
    ProjectivePoint: w,
    normPrivateKeyToScalar: u,
    weierstrassEquation: _,
    isWithinCurveOrder: a
  };
}
function SR(n) {
  const t = UA(n);
  return vu(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function RR(n) {
  const t = SR(n), { Fp: e, n: r } = t, s = e.BYTES + 1, _ = 2 * e.BYTES + 1;
  function a(pt) {
    return Vi < pt && pt < e.ORDER;
  }
  function c(pt) {
    return je(pt, r);
  }
  function u(pt) {
    return ch(pt, r);
  }
  const { ProjectivePoint: l, normPrivateKeyToScalar: f, weierstrassEquation: w, isWithinCurveOrder: y } = mR({
    ...t,
    toBytes(pt, wt, Pt) {
      const Mt = wt.toAffine(), xt = e.toBytes(Mt.x), Nt = ru;
      return Pt ? Nt(Uint8Array.from([wt.hasEvenY() ? 2 : 3]), xt) : Nt(Uint8Array.from([4]), xt, e.toBytes(Mt.y));
    },
    fromBytes(pt) {
      const wt = pt.length, Pt = pt[0], Mt = pt.subarray(1);
      if (wt === s && (Pt === 2 || Pt === 3)) {
        const xt = y_(Mt);
        if (!a(xt))
          throw new Error("Point is not on curve");
        const Nt = w(xt);
        let Ht = e.sqrt(Nt);
        const J = (Ht & lr) === lr;
        return (Pt & 1) === 1 !== J && (Ht = e.neg(Ht)), { x: xt, y: Ht };
      } else if (wt === _ && Pt === 4) {
        const xt = e.fromBytes(Mt.subarray(0, e.BYTES)), Nt = e.fromBytes(Mt.subarray(e.BYTES, 2 * e.BYTES));
        return { x: xt, y: Nt };
      } else
        throw new Error(`Point of length ${wt} was invalid. Expected ${s} compressed bytes or ${_} uncompressed bytes`);
    }
  }), v = (pt) => Rc(Pc(pt, t.nByteLength));
  function x(pt) {
    const wt = r >> lr;
    return pt > wt;
  }
  function C(pt) {
    return x(pt) ? c(-pt) : pt;
  }
  const U = (pt, wt, Pt) => y_(pt.slice(wt, Pt));
  class z {
    constructor(wt, Pt, Mt) {
      this.r = wt, this.s = Pt, this.recovery = Mt, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(wt) {
      const Pt = t.nByteLength;
      return wt = gr("compactSignature", wt, Pt * 2), new z(U(wt, 0, Pt), U(wt, Pt, 2 * Pt));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(wt) {
      const { r: Pt, s: Mt } = Ls.toSig(gr("DER", wt));
      return new z(Pt, Mt);
    }
    assertValidity() {
      if (!y(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!y(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(wt) {
      return new z(this.r, this.s, wt);
    }
    recoverPublicKey(wt) {
      const { r: Pt, s: Mt, recovery: xt } = this, Nt = j(gr("msgHash", wt));
      if (xt == null || ![0, 1, 2, 3].includes(xt))
        throw new Error("recovery id invalid");
      const Ht = xt === 2 || xt === 3 ? Pt + t.n : Pt;
      if (Ht >= e.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const J = (xt & 1) === 0 ? "02" : "03", st = l.fromHex(J + v(Ht)), _t = u(Ht), mt = c(-Nt * _t), H = c(Mt * _t), V = l.BASE.multiplyAndAddUnsafe(st, mt, H);
      if (!V)
        throw new Error("point at infinify");
      return V.assertValidity(), V;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return x(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new z(this.r, c(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Ec(this.toDERHex());
    }
    toDERHex() {
      return Ls.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Ec(this.toCompactHex());
    }
    toCompactHex() {
      return v(this.r) + v(this.s);
    }
  }
  const M = {
    isValidPrivateKey(pt) {
      try {
        return f(pt), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: f,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const pt = GA(t.n);
      return wR(t.randomBytes(pt), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(pt = 8, wt = l.BASE) {
      return wt._setWindowSize(pt), wt.multiply(BigInt(3)), wt;
    }
  };
  function N(pt, wt = !0) {
    return l.fromPrivateKey(pt).toRawBytes(wt);
  }
  function I(pt) {
    const wt = pt instanceof Uint8Array, Pt = typeof pt == "string", Mt = (wt || Pt) && pt.length;
    return wt ? Mt === s || Mt === _ : Pt ? Mt === 2 * s || Mt === 2 * _ : pt instanceof l;
  }
  function G(pt, wt, Pt = !0) {
    if (I(pt))
      throw new Error("first arg must be private key");
    if (!I(wt))
      throw new Error("second arg must be public key");
    return l.fromHex(wt).multiply(f(pt)).toRawBytes(Pt);
  }
  const D = t.bits2int || function(pt) {
    const wt = y_(pt), Pt = pt.length * 8 - t.nBitLength;
    return Pt > 0 ? wt >> BigInt(Pt) : wt;
  }, j = t.bits2int_modN || function(pt) {
    return c(D(pt));
  }, L = Wh(t.nBitLength);
  function X(pt) {
    if (typeof pt != "bigint")
      throw new Error("bigint expected");
    if (!(Vi <= pt && pt < L))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return Pc(pt, t.nByteLength);
  }
  function et(pt, wt, Pt = lt) {
    if (["recovered", "canonical"].some((ut) => ut in Pt))
      throw new Error("sign() legacy options not supported");
    const { hash: Mt, randomBytes: xt } = t;
    let { lowS: Nt, prehash: Ht, extraEntropy: J } = Pt;
    Nt == null && (Nt = !0), pt = gr("msgHash", pt), Ht && (pt = gr("prehashed msgHash", Mt(pt)));
    const st = j(pt), _t = f(wt), mt = [X(_t), X(st)];
    if (J != null) {
      const ut = J === !0 ? xt(e.BYTES) : J;
      mt.push(gr("extraEntropy", ut));
    }
    const H = ru(...mt), V = st;
    function tt(ut) {
      const dt = D(ut);
      if (!y(dt))
        return;
      const B = u(dt), O = l.BASE.multiply(dt).toAffine(), it = c(O.x);
      if (it === Vi)
        return;
      const gt = c(B * c(V + it * _t));
      if (gt === Vi)
        return;
      let Ot = (O.x === it ? 0 : 2) | Number(O.y & lr), vt = gt;
      return Nt && x(gt) && (vt = C(gt), Ot ^= 1), new z(it, vt, Ot);
    }
    return { seed: H, k2sig: tt };
  }
  const lt = { lowS: t.lowS, prehash: !1 }, Y = { lowS: t.lowS, prehash: !1 };
  function Et(pt, wt, Pt = lt) {
    const { seed: Mt, k2sig: xt } = et(pt, wt, Pt), Nt = t;
    return OA(Nt.hash.outputLen, Nt.nByteLength, Nt.hmac)(Mt, xt);
  }
  l.BASE._setWindowSize(8);
  function Ct(pt, wt, Pt, Mt = Y) {
    var O;
    const xt = pt;
    if (wt = gr("msgHash", wt), Pt = gr("publicKey", Pt), "strict" in Mt)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: Nt, prehash: Ht } = Mt;
    let J, st;
    try {
      if (typeof xt == "string" || xt instanceof Uint8Array)
        try {
          J = z.fromDER(xt);
        } catch (it) {
          if (!(it instanceof Ls.Err))
            throw it;
          J = z.fromCompact(xt);
        }
      else if (typeof xt == "object" && typeof xt.r == "bigint" && typeof xt.s == "bigint") {
        const { r: it, s: gt } = xt;
        J = new z(it, gt);
      } else
        throw new Error("PARSE");
      st = l.fromHex(Pt);
    } catch (it) {
      if (it.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Nt && J.hasHighS())
      return !1;
    Ht && (wt = t.hash(wt));
    const { r: _t, s: mt } = J, H = j(wt), V = u(mt), tt = c(H * V), ut = c(_t * V), dt = (O = l.BASE.multiplyAndAddUnsafe(st, tt, ut)) == null ? void 0 : O.toAffine();
    return dt ? c(dt.x) === _t : !1;
  }
  return {
    CURVE: t,
    getPublicKey: N,
    getSharedSecret: G,
    sign: Et,
    verify: Ct,
    ProjectivePoint: l,
    Signature: z,
    utils: M
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function ER(n) {
  return {
    hash: n,
    hmac: (t, ...e) => hA(n, t, fS(...e)),
    randomBytes: lS
  };
}
function PR(n, t) {
  const e = (r) => RR({ ...n, ...ER(r) });
  return Object.freeze({ ...e(t), create: e });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const FA = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), Dw = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), zR = BigInt(1), uh = BigInt(2), Lw = (n, t) => (n + t / uh) / t;
function vR(n) {
  const t = FA, e = BigInt(3), r = BigInt(6), s = BigInt(11), _ = BigInt(22), a = BigInt(23), c = BigInt(44), u = BigInt(88), l = n * n * n % t, f = l * l * n % t, w = rr(f, e, t) * f % t, y = rr(w, e, t) * f % t, v = rr(y, uh, t) * l % t, x = rr(v, s, t) * v % t, C = rr(x, _, t) * x % t, U = rr(C, c, t) * C % t, z = rr(U, u, t) * U % t, M = rr(z, c, t) * C % t, N = rr(M, e, t) * f % t, I = rr(N, a, t) * x % t, G = rr(I, r, t) * l % t, D = rr(G, uh, t);
  if (!fh.eql(fh.sqr(D), n))
    throw new Error("Cannot find square root");
  return D;
}
const fh = hR(FA, void 0, void 0, { sqrt: vR }), is = PR({
  a: BigInt(0),
  b: BigInt(7),
  Fp: fh,
  n: Dw,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (n) => {
      const t = Dw, e = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r = -zR * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), _ = e, a = BigInt("0x100000000000000000000000000000000"), c = Lw(_ * n, t), u = Lw(-r * n, t);
      let l = je(n - c * e - u * s, t), f = je(-c * r - u * _, t);
      const w = l > a, y = f > a;
      if (w && (l = t - l), y && (f = t - f), l > a || f > a)
        throw new Error("splitScalar: Endomorphism failed, k=" + n);
      return { k1neg: w, k1: l, k2neg: y, k2: f };
    }
  }
}, dA);
BigInt(0);
is.ProjectivePoint;
const nu = "0x0000000000000000000000000000000000000000", jw = "0x0000000000000000000000000000000000000000000000000000000000000000", Vw = BigInt(0), Yw = BigInt(1), Hw = BigInt(2), qw = BigInt(27), Qw = BigInt(28), Fu = BigInt(35), O_ = {};
function Ww(n) {
  return S_(Ne(n), 32);
}
var La, ja, Va, a_;
const dr = class dr {
  /**
   *  @private
   */
  constructor(t, e, r, s) {
    nt(this, La);
    nt(this, ja);
    nt(this, Va);
    nt(this, a_);
    Cf(t, O_, "Signature"), K(this, La, e), K(this, ja, r), K(this, Va, s), K(this, a_, null);
  }
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return A(this, La);
  }
  set r(t) {
    W(Pa(t) === 32, "invalid r", "value", t), K(this, La, Rt(t));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return A(this, ja);
  }
  set s(t) {
    W(Pa(t) === 32, "invalid s", "value", t);
    const e = Rt(t);
    W(parseInt(e.substring(0, 3)) < 8, "non-canonical s", "value", e), K(this, ja, e);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return A(this, Va);
  }
  set v(t) {
    const e = Ft(t, "value");
    W(e === 27 || e === 28, "invalid v", "v", t), K(this, Va, e);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return A(this, a_);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const t = this.networkV;
    return t == null ? null : dr.getChainId(t);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const t = Vt(this.s);
    return this.yParity && (t[0] |= 128), Rt(t);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return pe([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return pe([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const t = new dr(O_, this.r, this.s, this.v);
    return this.networkV && K(t, a_, this.networkV), t;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const t = this.networkV;
    return {
      _type: "signature",
      networkV: t != null ? t.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(t) {
    const e = zt(t, "v");
    return e == qw || e == Qw ? Vw : (W(e >= Fu, "invalid EIP-155 v", "v", t), (e - Fu) / Hw);
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(t, e) {
    return zt(t) * Hw + BigInt(35 + e - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(t) {
    const e = zt(t);
    return e === Vw || e === qw ? 27 : e === Yw || e === Qw ? 28 : (W(e >= Fu, "invalid v", "v", t), e & Yw ? 27 : 28);
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(t) {
    function e(l, f) {
      W(l, f, "signature", t);
    }
    if (t == null)
      return new dr(O_, jw, jw, 27);
    if (typeof t == "string") {
      const l = Vt(t, "signature");
      if (l.length === 64) {
        const f = Rt(l.slice(0, 32)), w = l.slice(32, 64), y = w[0] & 128 ? 28 : 27;
        return w[0] &= 127, new dr(O_, f, Rt(w), y);
      }
      if (l.length === 65) {
        const f = Rt(l.slice(0, 32)), w = l.slice(32, 64);
        e((w[0] & 128) === 0, "non-canonical s");
        const y = dr.getNormalizedV(l[64]);
        return new dr(O_, f, Rt(w), y);
      }
      e(!1, "invalid raw signature length");
    }
    if (t instanceof dr)
      return t.clone();
    const r = t.r;
    e(r != null, "missing r");
    const s = Ww(r), _ = function(l, f) {
      if (l != null)
        return Ww(l);
      if (f != null) {
        e(ee(f, 32), "invalid yParityAndS");
        const w = Vt(f);
        return w[0] &= 127, Rt(w);
      }
      e(!1, "missing s");
    }(t.s, t.yParityAndS);
    e((Vt(_)[0] & 128) == 0, "non-canonical s");
    const { networkV: a, v: c } = function(l, f, w) {
      if (l != null) {
        const y = zt(l);
        return {
          networkV: y >= Fu ? y : void 0,
          v: dr.getNormalizedV(y)
        };
      }
      if (f != null)
        return e(ee(f, 32), "invalid yParityAndS"), { v: Vt(f)[0] & 128 ? 28 : 27 };
      if (w != null) {
        switch (Ft(w, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        e(!1, "invalid yParity");
      }
      e(!1, "missing v");
    }(t.v, t.yParityAndS, t.yParity), u = new dr(O_, s, _, c);
    return a && K(u, a_, a), e(t.yParity == null || Ft(t.yParity, "sig.yParity") === u.yParity, "yParity mismatch"), e(t.yParityAndS == null || t.yParityAndS === u.yParityAndS, "yParityAndS mismatch"), u;
  }
};
La = new WeakMap(), ja = new WeakMap(), Va = new WeakMap(), a_ = new WeakMap();
let zr = dr;
var ki;
const Ks = class Ks {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(t) {
    nt(this, ki);
    W(Pa(t) === 32, "invalid private key", "privateKey", "[REDACTED]"), K(this, ki, Rt(t));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return A(this, ki);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return Ks.computePublicKey(A(this, ki));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return Ks.computePublicKey(A(this, ki), !0);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(t) {
    W(Pa(t) === 32, "invalid digest length", "digest", t);
    const e = is.sign(Ie(t), Ie(A(this, ki)), {
      lowS: !0
    });
    return zr.from({
      r: zs(e.r, 32),
      s: zs(e.s, 32),
      v: e.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(t) {
    const e = Ks.computePublicKey(t);
    return Rt(is.getSharedSecret(Ie(A(this, ki)), Vt(e), !1));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(t, e) {
    let r = Vt(t, "key");
    if (r.length === 32) {
      const _ = is.getPublicKey(r, !!e);
      return Rt(_);
    }
    if (r.length === 64) {
      const _ = new Uint8Array(65);
      _[0] = 4, _.set(r, 1), r = _;
    }
    const s = is.ProjectivePoint.fromHex(r);
    return Rt(s.toRawBytes(e));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(t, e) {
    W(Pa(t) === 32, "invalid digest length", "digest", t);
    const r = zr.from(e);
    let s = is.Signature.fromCompact(Ie(pe([r.r, r.s])));
    s = s.addRecoveryBit(r.yParity);
    const _ = s.recoverPublicKey(Ie(t));
    return W(_ != null, "invalid signautre for digest", "signature", e), "0x" + _.toHex(!1);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(t, e, r) {
    const s = is.ProjectivePoint.fromHex(Ks.computePublicKey(t).substring(2)), _ = is.ProjectivePoint.fromHex(Ks.computePublicKey(e).substring(2));
    return "0x" + s.add(_).toHex(!!r);
  }
};
ki = new WeakMap();
let iu = Ks;
const MR = BigInt(0), xR = BigInt(36);
function Jw(n) {
  n = n.toLowerCase();
  const t = n.substring(2).split(""), e = new Uint8Array(40);
  for (let s = 0; s < 40; s++)
    e[s] = t[s].charCodeAt(0);
  const r = Vt(de(e));
  for (let s = 0; s < 40; s += 2)
    r[s >> 1] >> 4 >= 8 && (t[s] = t[s].toUpperCase()), (r[s >> 1] & 15) >= 8 && (t[s + 1] = t[s + 1].toUpperCase());
  return "0x" + t.join("");
}
const Jh = {};
for (let n = 0; n < 10; n++)
  Jh[String(n)] = String(n);
for (let n = 0; n < 26; n++)
  Jh[String.fromCharCode(65 + n)] = String(10 + n);
const $w = 15;
function BR(n) {
  n = n.toUpperCase(), n = n.substring(4) + n.substring(0, 2) + "00";
  let t = n.split("").map((r) => Jh[r]).join("");
  for (; t.length >= $w; ) {
    let r = t.substring(0, $w);
    t = parseInt(r, 10) % 97 + t.substring(r.length);
  }
  let e = String(98 - parseInt(t, 10) % 97);
  for (; e.length < 2; )
    e = "0" + e;
  return e;
}
const CR = function() {
  const n = {};
  for (let t = 0; t < 36; t++) {
    const e = "0123456789abcdefghijklmnopqrstuvwxyz"[t];
    n[e] = BigInt(t);
  }
  return n;
}();
function IR(n) {
  n = n.toLowerCase();
  let t = MR;
  for (let e = 0; e < n.length; e++)
    t = t * xR + CR[n[e]];
  return t;
}
function jt(n) {
  if (W(typeof n == "string", "invalid address", "address", n), n.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    n.startsWith("0x") || (n = "0x" + n);
    const t = Jw(n);
    return W(!n.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || t === n, "bad address checksum", "address", n), t;
  }
  if (n.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    W(n.substring(2, 4) === BR(n), "bad icap checksum", "address", n);
    let t = IR(n.substring(4)).toString(16);
    for (; t.length < 40; )
      t = "0" + t;
    return Jw("0x" + t);
  }
  W(!1, "invalid address", "address", n);
}
function NR(n) {
  const t = jt(n.from);
  let r = zt(n.nonce, "tx.nonce").toString(16);
  return r === "0" ? r = "0x" : r.length % 2 ? r = "0x0" + r : r = "0x" + r, jt(ae(de(R_([t, r])), 12));
}
function KA(n) {
  return n && typeof n.getAddress == "function";
}
function hr(n) {
  try {
    return jt(n), !0;
  } catch {
  }
  return !1;
}
async function El(n, t) {
  const e = await t;
  return (e == null || e === "0x0000000000000000000000000000000000000000") && (ht(typeof n != "string", "unconfigured name", "UNCONFIGURED_NAME", { value: n }), W(!1, "invalid AddressLike value; did not resolve to a value address", "target", n)), jt(e);
}
function ke(n, t) {
  if (typeof n == "string")
    return n.match(/^0x[0-9a-f]{40}$/i) ? jt(n) : (ht(t != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" }), El(n, t.resolveName(n)));
  if (KA(n))
    return El(n, n.getAddress());
  if (n && typeof n.then == "function")
    return El(n, n);
  W(!1, "unsupported addressable value", "target", n);
}
const Mi = {};
function St(n, t) {
  let e = !1;
  return t < 0 && (e = !0, t *= -1), new Me(Mi, `${e ? "" : "u"}int${t}`, n, { signed: e, width: t });
}
function Yt(n, t) {
  return new Me(Mi, `bytes${t || ""}`, n, { size: t });
}
const Zw = Symbol.for("_ethers_typed");
var c_;
const xi = class xi {
  /**
   *  @_ignore:
   */
  constructor(t, e, r, s) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    $(this, "type");
    /**
     *  The actual value.
     */
    $(this, "value");
    nt(this, c_);
    /**
     *  @_ignore:
     */
    $(this, "_typedSymbol");
    s == null && (s = null), Cf(Mi, t, "Typed"), Bt(this, { _typedSymbol: Zw, type: e, value: r }), K(this, c_, s), this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array")
      throw new Error("");
    if (this.type === "dynamicArray")
      throw new Error("");
    return this.type === "tuple" ? `tuple(${this.value.map((t) => t.format()).join(",")})` : this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple")
      throw TypeError("not a tuple");
    return A(this, c_);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array")
      throw TypeError("not an array");
    return A(this, c_) === !0 ? -1 : A(this, c_) === !1 ? this.value.length : null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(t, e) {
    return new xi(Mi, t, e);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(t) {
    return St(t, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(t) {
    return St(t, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(t) {
    return St(t, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(t) {
    return St(t, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(t) {
    return St(t, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(t) {
    return St(t, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(t) {
    return St(t, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(t) {
    return St(t, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(t) {
    return St(t, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(t) {
    return St(t, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(t) {
    return St(t, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(t) {
    return St(t, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(t) {
    return St(t, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(t) {
    return St(t, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(t) {
    return St(t, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(t) {
    return St(t, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(t) {
    return St(t, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(t) {
    return St(t, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(t) {
    return St(t, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(t) {
    return St(t, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(t) {
    return St(t, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(t) {
    return St(t, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(t) {
    return St(t, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(t) {
    return St(t, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(t) {
    return St(t, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(t) {
    return St(t, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(t) {
    return St(t, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(t) {
    return St(t, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(t) {
    return St(t, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(t) {
    return St(t, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(t) {
    return St(t, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(t) {
    return St(t, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(t) {
    return St(t, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(t) {
    return St(t, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(t) {
    return St(t, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(t) {
    return St(t, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(t) {
    return St(t, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(t) {
    return St(t, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(t) {
    return St(t, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(t) {
    return St(t, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(t) {
    return St(t, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(t) {
    return St(t, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(t) {
    return St(t, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(t) {
    return St(t, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(t) {
    return St(t, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(t) {
    return St(t, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(t) {
    return St(t, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(t) {
    return St(t, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(t) {
    return St(t, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(t) {
    return St(t, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(t) {
    return St(t, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(t) {
    return St(t, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(t) {
    return St(t, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(t) {
    return St(t, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(t) {
    return St(t, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(t) {
    return St(t, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(t) {
    return St(t, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(t) {
    return St(t, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(t) {
    return St(t, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(t) {
    return St(t, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(t) {
    return St(t, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(t) {
    return St(t, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(t) {
    return St(t, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(t) {
    return St(t, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(t) {
    return St(t, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(t) {
    return St(t, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(t) {
    return Yt(t, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(t) {
    return Yt(t, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(t) {
    return Yt(t, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(t) {
    return Yt(t, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(t) {
    return Yt(t, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(t) {
    return Yt(t, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(t) {
    return Yt(t, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(t) {
    return Yt(t, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(t) {
    return Yt(t, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(t) {
    return Yt(t, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(t) {
    return Yt(t, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(t) {
    return Yt(t, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(t) {
    return Yt(t, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(t) {
    return Yt(t, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(t) {
    return Yt(t, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(t) {
    return Yt(t, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(t) {
    return Yt(t, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(t) {
    return Yt(t, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(t) {
    return Yt(t, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(t) {
    return Yt(t, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(t) {
    return Yt(t, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(t) {
    return Yt(t, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(t) {
    return Yt(t, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(t) {
    return Yt(t, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(t) {
    return Yt(t, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(t) {
    return Yt(t, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(t) {
    return Yt(t, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(t) {
    return Yt(t, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(t) {
    return Yt(t, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(t) {
    return Yt(t, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(t) {
    return Yt(t, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(t) {
    return Yt(t, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(t) {
    return new xi(Mi, "address", t);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(t) {
    return new xi(Mi, "bool", !!t);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(t) {
    return new xi(Mi, "bytes", t);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(t) {
    return new xi(Mi, "string", t);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(t, e) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(t, e) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(t) {
    return new xi(Mi, "overrides", Object.assign({}, t));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(t) {
    return t && typeof t == "object" && "_typedSymbol" in t && t._typedSymbol === Zw;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(t, e) {
    if (xi.isTyped(t)) {
      if (t.type !== e)
        throw new Error(`invalid type: expecetd ${e}, got ${t.type}`);
      return t.value;
    }
    return t;
  }
};
c_ = new WeakMap();
let Me = xi;
class OR extends $i {
  constructor(t) {
    super("address", "address", t, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(t, e) {
    let r = Me.dereference(e, "string");
    try {
      r = jt(r);
    } catch (s) {
      return this._throwError(s.message, e);
    }
    return t.writeValue(r);
  }
  decode(t) {
    return jt(zs(t.readValue(), 20));
  }
}
class kR extends $i {
  constructor(e) {
    super(e.name, e.type, "_", e.dynamic);
    $(this, "coder");
    this.coder = e;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(e, r) {
    return this.coder.encode(e, r);
  }
  decode(e) {
    return this.coder.decode(e);
  }
}
function DA(n, t, e) {
  let r = [];
  if (Array.isArray(e))
    r = e;
  else if (e && typeof e == "object") {
    let u = {};
    r = t.map((l) => {
      const f = l.localName;
      return ht(f, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder: l }, value: e }), ht(!u[f], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder: l }, value: e }), u[f] = !0, e[f];
    });
  } else
    W(!1, "invalid tuple value", "tuple", e);
  W(t.length === r.length, "types/value length mismatch", "tuple", e);
  let s = new ih(), _ = new ih(), a = [];
  t.forEach((u, l) => {
    let f = r[l];
    if (u.dynamic) {
      let w = _.length;
      u.encode(_, f);
      let y = s.writeUpdatableValue();
      a.push((v) => {
        y(v + w);
      });
    } else
      u.encode(s, f);
  }), a.forEach((u) => {
    u(s.length);
  });
  let c = n.appendWriter(s);
  return c += n.appendWriter(_), c;
}
function LA(n, t) {
  let e = [], r = [], s = n.subReader(0);
  return t.forEach((_) => {
    let a = null;
    if (_.dynamic) {
      let c = n.readIndex(), u = s.subReader(c);
      try {
        a = _.decode(u);
      } catch (l) {
        if (Re(l, "BUFFER_OVERRUN"))
          throw l;
        a = l, a.baseType = _.name, a.name = _.localName, a.type = _.type;
      }
    } else
      try {
        a = _.decode(n);
      } catch (c) {
        if (Re(c, "BUFFER_OVERRUN"))
          throw c;
        a = c, a.baseType = _.name, a.name = _.localName, a.type = _.type;
      }
    if (a == null)
      throw new Error("investigate");
    e.push(a), r.push(_.localName || null);
  }), mc.fromItems(e, r);
}
class TR extends $i {
  constructor(e, r, s) {
    const _ = e.type + "[" + (r >= 0 ? r : "") + "]", a = r === -1 || e.dynamic;
    super("array", _, s, a);
    $(this, "coder");
    $(this, "length");
    Bt(this, { coder: e, length: r });
  }
  defaultValue() {
    const e = this.coder.defaultValue(), r = [];
    for (let s = 0; s < this.length; s++)
      r.push(e);
    return r;
  }
  encode(e, r) {
    const s = Me.dereference(r, "array");
    Array.isArray(s) || this._throwError("expected array value", s);
    let _ = this.length;
    _ === -1 && (_ = s.length, e.writeValue(s.length)), $y(s.length, _, "coder array" + (this.localName ? " " + this.localName : ""));
    let a = [];
    for (let c = 0; c < s.length; c++)
      a.push(this.coder);
    return DA(e, a, s);
  }
  decode(e) {
    let r = this.length;
    r === -1 && (r = e.readIndex(), ht(r * Oe <= e.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: e.bytes, offset: r * Oe, length: e.dataLength }));
    let s = [];
    for (let _ = 0; _ < r; _++)
      s.push(new kR(this.coder));
    return LA(e, s);
  }
}
class GR extends $i {
  constructor(t) {
    super("bool", "bool", t, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(t, e) {
    const r = Me.dereference(e, "bool");
    return t.writeValue(r ? 1 : 0);
  }
  decode(t) {
    return !!t.readValue();
  }
}
class jA extends $i {
  constructor(t, e) {
    super(t, t, e, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(t, e) {
    e = Ie(e);
    let r = t.writeValue(e.length);
    return r += t.writeBytes(e), r;
  }
  decode(t) {
    return t.readBytes(t.readIndex(), !0);
  }
}
class UR extends jA {
  constructor(t) {
    super("bytes", t);
  }
  decode(t) {
    return Rt(super.decode(t));
  }
}
class FR extends $i {
  constructor(e, r) {
    let s = "bytes" + String(e);
    super(s, s, r, !1);
    $(this, "size");
    Bt(this, { size: e }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(e, r) {
    let s = Ie(Me.dereference(r, this.type));
    return s.length !== this.size && this._throwError("incorrect data length", r), e.writeBytes(s);
  }
  decode(e) {
    return Rt(e.readBytes(this.size));
  }
}
const KR = new Uint8Array([]);
class DR extends $i {
  constructor(t) {
    super("null", "", t, !1);
  }
  defaultValue() {
    return null;
  }
  encode(t, e) {
    return e != null && this._throwError("not null", e), t.writeBytes(KR);
  }
  decode(t) {
    return t.readBytes(0), null;
  }
}
const LR = BigInt(0), jR = BigInt(1), VR = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class YR extends $i {
  constructor(e, r, s) {
    const _ = (r ? "int" : "uint") + e * 8;
    super(_, _, s, !1);
    $(this, "size");
    $(this, "signed");
    Bt(this, { size: e, signed: r }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(e, r) {
    let s = zt(Me.dereference(r, this.type)), _ = jc(VR, Oe * 8);
    if (this.signed) {
      let a = jc(_, this.size * 8 - 1);
      (s > a || s < -(a + jR)) && this._throwError("value out-of-bounds", r), s = tA(s, 8 * Oe);
    } else (s < LR || s > jc(_, this.size * 8)) && this._throwError("value out-of-bounds", r);
    return e.writeValue(s);
  }
  decode(e) {
    let r = jc(e.readValue(), this.size * 8);
    return this.signed && (r = Lm(r, this.size * 8)), r;
  }
}
class HR extends jA {
  constructor(t) {
    super("string", t);
  }
  defaultValue() {
    return "";
  }
  encode(t, e) {
    return super.encode(t, qi(Me.dereference(e, "string")));
  }
  decode(t) {
    return uf(super.decode(t));
  }
}
class Ku extends $i {
  constructor(e, r) {
    let s = !1;
    const _ = [];
    e.forEach((c) => {
      c.dynamic && (s = !0), _.push(c.type);
    });
    const a = "tuple(" + _.join(",") + ")";
    super("tuple", a, r, s);
    $(this, "coders");
    Bt(this, { coders: Object.freeze(e.slice()) });
  }
  defaultValue() {
    const e = [];
    this.coders.forEach((s) => {
      e.push(s.defaultValue());
    });
    const r = this.coders.reduce((s, _) => {
      const a = _.localName;
      return a && (s[a] || (s[a] = 0), s[a]++), s;
    }, {});
    return this.coders.forEach((s, _) => {
      let a = s.localName;
      !a || r[a] !== 1 || (a === "length" && (a = "_length"), e[a] == null && (e[a] = e[_]));
    }), Object.freeze(e);
  }
  encode(e, r) {
    const s = Me.dereference(r, "tuple");
    return DA(e, this.coders, s);
  }
  decode(e) {
    return LA(e, this.coders);
  }
}
function E_(n) {
  return de(qi(n));
}
var qR = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const Xw = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]), td = 4;
function QR(n) {
  let t = 0;
  function e() {
    return n[t++] << 8 | n[t++];
  }
  let r = e(), s = 1, _ = [0, 1];
  for (let G = 1; G < r; G++)
    _.push(s += e());
  let a = e(), c = t;
  t += a;
  let u = 0, l = 0;
  function f() {
    return u == 0 && (l = l << 8 | n[t++], u = 8), l >> --u & 1;
  }
  const w = 31, y = 2 ** w, v = y >>> 1, x = v >> 1, C = y - 1;
  let U = 0;
  for (let G = 0; G < w; G++) U = U << 1 | f();
  let z = [], M = 0, N = y;
  for (; ; ) {
    let G = Math.floor(((U - M + 1) * s - 1) / N), D = 0, j = r;
    for (; j - D > 1; ) {
      let et = D + j >>> 1;
      G < _[et] ? j = et : D = et;
    }
    if (D == 0) break;
    z.push(D);
    let L = M + Math.floor(N * _[D] / s), X = M + Math.floor(N * _[D + 1] / s) - 1;
    for (; ((L ^ X) & v) == 0; )
      U = U << 1 & C | f(), L = L << 1 & C, X = X << 1 & C | 1;
    for (; L & ~X & x; )
      U = U & v | U << 1 & C >>> 1 | f(), L = L << 1 ^ v, X = (X ^ v) << 1 | v | 1;
    M = L, N = 1 + X - L;
  }
  let I = r - 4;
  return z.map((G) => {
    switch (G - I) {
      case 3:
        return I + 65792 + (n[c++] << 16 | n[c++] << 8 | n[c++]);
      case 2:
        return I + 256 + (n[c++] << 8 | n[c++]);
      case 1:
        return I + n[c++];
      default:
        return G - 1;
    }
  });
}
function WR(n) {
  let t = 0;
  return () => n[t++];
}
function VA(n) {
  return WR(QR(JR(n)));
}
function JR(n) {
  let t = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((s, _) => t[s.charCodeAt(0)] = _);
  let e = n.length, r = new Uint8Array(6 * e >> 3);
  for (let s = 0, _ = 0, a = 0, c = 0; s < e; s++)
    c = c << 6 | t[n.charCodeAt(s)], a += 6, a >= 8 && (r[_++] = c >> (a -= 8));
  return r;
}
function $R(n) {
  return n & 1 ? ~n >> 1 : n >> 1;
}
function ZR(n, t) {
  let e = Array(n);
  for (let r = 0, s = 0; r < n; r++) e[r] = s += $R(t());
  return e;
}
function su(n, t = 0) {
  let e = [];
  for (; ; ) {
    let r = n(), s = n();
    if (!s) break;
    t += r;
    for (let _ = 0; _ < s; _++)
      e.push(t + _);
    t += s + 1;
  }
  return e;
}
function YA(n) {
  return _u(() => {
    let t = su(n);
    if (t.length) return t;
  });
}
function HA(n) {
  let t = [];
  for (; ; ) {
    let e = n();
    if (e == 0) break;
    t.push(XR(e, n));
  }
  for (; ; ) {
    let e = n() - 1;
    if (e < 0) break;
    t.push(tE(e, n));
  }
  return t.flat();
}
function _u(n) {
  let t = [];
  for (; ; ) {
    let e = n(t.length);
    if (!e) break;
    t.push(e);
  }
  return t;
}
function qA(n, t, e) {
  let r = Array(n).fill().map(() => []);
  for (let s = 0; s < t; s++)
    ZR(n, e).forEach((_, a) => r[a].push(_));
  return r;
}
function XR(n, t) {
  let e = 1 + t(), r = t(), s = _u(t);
  return qA(s.length, 1 + n, t).flatMap((a, c) => {
    let [u, ...l] = a;
    return Array(s[c]).fill().map((f, w) => {
      let y = w * r;
      return [u + w * e, l.map((v) => v + y)];
    });
  });
}
function tE(n, t) {
  let e = 1 + t();
  return qA(e, 1 + n, t).map((s) => [s[0], s.slice(1)]);
}
function eE(n) {
  let t = [], e = su(n);
  return s(r([]), []), t;
  function r(_) {
    let a = n(), c = _u(() => {
      let u = su(n).map((l) => e[l]);
      if (u.length) return r(u);
    });
    return { S: a, B: c, Q: _ };
  }
  function s({ S: _, B: a }, c, u) {
    if (!(_ & 4 && u === c[c.length - 1])) {
      _ & 2 && (u = c[c.length - 1]), _ & 1 && t.push(c);
      for (let l of a)
        for (let f of l.Q)
          s(l, [...c, f], u);
    }
  }
}
function rE(n) {
  return n.toString(16).toUpperCase().padStart(2, "0");
}
function QA(n) {
  return `{${rE(n)}}`;
}
function nE(n) {
  let t = [];
  for (let e = 0, r = n.length; e < r; ) {
    let s = n.codePointAt(e);
    e += s < 65536 ? 1 : 2, t.push(s);
  }
  return t;
}
function zc(n) {
  let e = n.length;
  if (e < 4096) return String.fromCodePoint(...n);
  let r = [];
  for (let s = 0; s < e; )
    r.push(String.fromCodePoint(...n.slice(s, s += 4096)));
  return r.join("");
}
function iE(n, t) {
  let e = n.length, r = e - t.length;
  for (let s = 0; r == 0 && s < e; s++) r = n[s] - t[s];
  return r;
}
var sE = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const ou = 44032, lf = 4352, pf = 4449, hf = 4519, WA = 19, JA = 21, vc = 28, wf = JA * vc, _E = WA * wf, oE = ou + _E, aE = lf + WA, cE = pf + JA, uE = hf + vc;
function Yc(n) {
  return n >> 24 & 255;
}
function $A(n) {
  return n & 16777215;
}
let lh, ed, ph, Ju;
function fE() {
  let n = VA(sE);
  lh = new Map(YA(n).flatMap((t, e) => t.map((r) => [r, e + 1 << 24]))), ed = new Set(su(n)), ph = /* @__PURE__ */ new Map(), Ju = /* @__PURE__ */ new Map();
  for (let [t, e] of HA(n)) {
    if (!ed.has(t) && e.length == 2) {
      let [r, s] = e, _ = Ju.get(r);
      _ || (_ = /* @__PURE__ */ new Map(), Ju.set(r, _)), _.set(s, t);
    }
    ph.set(t, e.reverse());
  }
}
function ZA(n) {
  return n >= ou && n < oE;
}
function lE(n, t) {
  if (n >= lf && n < aE && t >= pf && t < cE)
    return ou + (n - lf) * wf + (t - pf) * vc;
  if (ZA(n) && t > hf && t < uE && (n - ou) % vc == 0)
    return n + (t - hf);
  {
    let e = Ju.get(n);
    return e && (e = e.get(t), e) ? e : -1;
  }
}
function XA(n) {
  lh || fE();
  let t = [], e = [], r = !1;
  function s(_) {
    let a = lh.get(_);
    a && (r = !0, _ |= a), t.push(_);
  }
  for (let _ of n)
    for (; ; ) {
      if (_ < 128)
        t.push(_);
      else if (ZA(_)) {
        let a = _ - ou, c = a / wf | 0, u = a % wf / vc | 0, l = a % vc;
        s(lf + c), s(pf + u), l > 0 && s(hf + l);
      } else {
        let a = ph.get(_);
        a ? e.push(...a) : s(_);
      }
      if (!e.length) break;
      _ = e.pop();
    }
  if (r && t.length > 1) {
    let _ = Yc(t[0]);
    for (let a = 1; a < t.length; a++) {
      let c = Yc(t[a]);
      if (c == 0 || _ <= c) {
        _ = c;
        continue;
      }
      let u = a - 1;
      for (; ; ) {
        let l = t[u + 1];
        if (t[u + 1] = t[u], t[u] = l, !u || (_ = Yc(t[--u]), _ <= c)) break;
      }
      _ = Yc(t[a]);
    }
  }
  return t;
}
function pE(n) {
  let t = [], e = [], r = -1, s = 0;
  for (let _ of n) {
    let a = Yc(_), c = $A(_);
    if (r == -1)
      a == 0 ? r = c : t.push(c);
    else if (s > 0 && s >= a)
      a == 0 ? (t.push(r, ...e), e.length = 0, r = c) : e.push(c), s = a;
    else {
      let u = lE(r, c);
      u >= 0 ? r = u : s == 0 && a == 0 ? (t.push(r), r = c) : (e.push(c), s = a);
    }
  }
  return r >= 0 && t.push(r, ...e), t;
}
function t2(n) {
  return XA(n).map($A);
}
function hE(n) {
  return pE(XA(n));
}
const rd = 45, e2 = ".", r2 = 65039, n2 = 1, df = (n) => Array.from(n);
function au(n, t) {
  return n.P.has(t) || n.Q.has(t);
}
class wE extends Array {
  get is_emoji() {
    return !0;
  }
  // free tagging system
}
let hh, i2, js, wh, s2, za, Pl, U_, Ns, nd, dh;
function $h() {
  if (hh) return;
  let n = VA(qR);
  const t = () => su(n), e = () => new Set(t()), r = (f, w) => w.forEach((y) => f.add(y));
  hh = new Map(HA(n)), i2 = e(), js = t(), wh = new Set(t().map((f) => js[f])), js = new Set(js), s2 = e(), e();
  let s = YA(n), _ = n();
  const a = () => {
    let f = /* @__PURE__ */ new Set();
    return t().forEach((w) => r(f, s[w])), r(f, t()), f;
  };
  za = _u((f) => {
    let w = _u(n).map((y) => y + 96);
    if (w.length) {
      let y = f >= _;
      w[0] -= 32, w = zc(w), y && (w = `Restricted[${w}]`);
      let v = a(), x = a(), C = !n();
      return { N: w, P: v, Q: x, M: C, R: y };
    }
  }), Pl = e(), U_ = /* @__PURE__ */ new Map();
  let c = t().concat(df(Pl)).sort((f, w) => f - w);
  c.forEach((f, w) => {
    let y = n(), v = c[w] = y ? c[w - y] : { V: [], M: /* @__PURE__ */ new Map() };
    v.V.push(f), Pl.has(f) || U_.set(f, v);
  });
  for (let { V: f, M: w } of new Set(U_.values())) {
    let y = [];
    for (let x of f) {
      let C = za.filter((z) => au(z, x)), U = y.find(({ G: z }) => C.some((M) => z.has(M)));
      U || (U = { G: /* @__PURE__ */ new Set(), V: [] }, y.push(U)), U.V.push(x), r(U.G, C);
    }
    let v = y.flatMap((x) => df(x.G));
    for (let { G: x, V: C } of y) {
      let U = new Set(v.filter((z) => !x.has(z)));
      for (let z of C)
        w.set(z, U);
    }
  }
  Ns = /* @__PURE__ */ new Set();
  let u = /* @__PURE__ */ new Set();
  const l = (f) => Ns.has(f) ? u.add(f) : Ns.add(f);
  for (let f of za) {
    for (let w of f.P) l(w);
    for (let w of f.Q) l(w);
  }
  for (let f of Ns)
    !U_.has(f) && !u.has(f) && U_.set(f, n2);
  r(Ns, t2(Ns)), nd = eE(n).map((f) => wE.from(f)).sort(iE), dh = /* @__PURE__ */ new Map();
  for (let f of nd) {
    let w = [dh];
    for (let y of f) {
      let v = w.map((x) => {
        let C = x.get(y);
        return C || (C = /* @__PURE__ */ new Map(), x.set(y, C)), C;
      });
      y === r2 ? w.push(...v) : w = v;
    }
    for (let y of w)
      y.V = f;
  }
}
function Zh(n) {
  return (_2(n) ? "" : `${Xh(Uf([n]))} `) + QA(n);
}
function Xh(n) {
  return `"${n}"‎`;
}
function dE(n) {
  if (n.length >= 4 && n[2] == rd && n[3] == rd)
    throw new Error(`invalid label extension: "${zc(n.slice(0, 4))}"`);
}
function gE(n) {
  for (let e = n.lastIndexOf(95); e > 0; )
    if (n[--e] !== 95)
      throw new Error("underscore allowed only at start");
}
function bE(n) {
  let t = n[0], e = Xw.get(t);
  if (e) throw Xc(`leading ${e}`);
  let r = n.length, s = -1;
  for (let _ = 1; _ < r; _++) {
    t = n[_];
    let a = Xw.get(t);
    if (a) {
      if (s == _) throw Xc(`${e} + ${a}`);
      s = _ + 1, e = a;
    }
  }
  if (s == r) throw Xc(`trailing ${e}`);
}
function Uf(n, t = 1 / 0, e = QA) {
  let r = [];
  yE(n[0]) && r.push("◌"), n.length > t && (t >>= 1, n = [...n.slice(0, t), 8230, ...n.slice(-t)]);
  let s = 0, _ = n.length;
  for (let a = 0; a < _; a++) {
    let c = n[a];
    _2(c) && (r.push(zc(n.slice(s, a))), r.push(e(c)), s = a + 1);
  }
  return r.push(zc(n.slice(s, _))), r.join("");
}
function yE(n) {
  return $h(), js.has(n);
}
function _2(n) {
  return $h(), s2.has(n);
}
function AE(n) {
  return EE(mE(n, hE, vE));
}
function mE(n, t, e) {
  if (!n) return [];
  $h();
  let r = 0;
  return n.split(e2).map((s) => {
    let _ = nE(s), a = {
      input: _,
      offset: r
      // codepoint, not substring!
    };
    r += _.length + 1;
    try {
      let c = a.tokens = zE(_, t, e), u = c.length, l;
      if (!u)
        throw new Error("empty label");
      let f = a.output = c.flat();
      if (gE(f), !(a.emoji = u > 1 || c[0].is_emoji) && f.every((y) => y < 128))
        dE(f), l = "ASCII";
      else {
        let y = c.flatMap((v) => v.is_emoji ? [] : v);
        if (!y.length)
          l = "Emoji";
        else {
          if (js.has(f[0])) throw Xc("leading combining mark");
          for (let C = 1; C < u; C++) {
            let U = c[C];
            if (!U.is_emoji && js.has(U[0]))
              throw Xc(`emoji + combining mark: "${zc(c[C - 1])} + ${Uf([U[0]])}"`);
          }
          bE(f);
          let v = df(new Set(y)), [x] = RE(v);
          PE(x, y), SE(x, v), l = x.N;
        }
      }
      a.type = l;
    } catch (c) {
      a.error = c;
    }
    return a;
  });
}
function SE(n, t) {
  let e, r = [];
  for (let s of t) {
    let _ = U_.get(s);
    if (_ === n2) return;
    if (_) {
      let a = _.M.get(s);
      if (e = e ? e.filter((c) => a.has(c)) : df(a), !e.length) return;
    } else
      r.push(s);
  }
  if (e) {
    for (let s of e)
      if (r.every((_) => au(s, _)))
        throw new Error(`whole-script confusable: ${n.N}/${s.N}`);
  }
}
function RE(n) {
  let t = za;
  for (let e of n) {
    let r = t.filter((s) => au(s, e));
    if (!r.length)
      throw za.some((s) => au(s, e)) ? a2(t[0], e) : o2(e);
    if (t = r, r.length == 1) break;
  }
  return t;
}
function EE(n) {
  return n.map(({ input: t, error: e, output: r }) => {
    if (e) {
      let s = e.message;
      throw new Error(n.length == 1 ? s : `Invalid label ${Xh(Uf(t, 63))}: ${s}`);
    }
    return zc(r);
  }).join(e2);
}
function o2(n) {
  return new Error(`disallowed character: ${Zh(n)}`);
}
function a2(n, t) {
  let e = Zh(t), r = za.find((s) => s.P.has(t));
  return r && (e = `${r.N} ${e}`), new Error(`illegal mixture: ${n.N} + ${e}`);
}
function Xc(n) {
  return new Error(`illegal placement: ${n}`);
}
function PE(n, t) {
  for (let e of t)
    if (!au(n, e))
      throw a2(n, e);
  if (n.M) {
    let e = t2(t);
    for (let r = 1, s = e.length; r < s; r++)
      if (wh.has(e[r])) {
        let _ = r + 1;
        for (let a; _ < s && wh.has(a = e[_]); _++)
          for (let c = r; c < _; c++)
            if (e[c] == a)
              throw new Error(`duplicate non-spacing marks: ${Zh(a)}`);
        if (_ - r > td)
          throw new Error(`excessive non-spacing marks: ${Xh(Uf(e.slice(r - 1, _)))} (${_ - r}/${td})`);
        r = _;
      }
  }
}
function zE(n, t, e) {
  let r = [], s = [];
  for (n = n.slice().reverse(); n.length; ) {
    let _ = ME(n);
    if (_)
      s.length && (r.push(t(s)), s = []), r.push(e(_));
    else {
      let a = n.pop();
      if (Ns.has(a))
        s.push(a);
      else {
        let c = hh.get(a);
        if (c)
          s.push(...c);
        else if (!i2.has(a))
          throw o2(a);
      }
    }
  }
  return s.length && r.push(t(s)), r;
}
function vE(n) {
  return n.filter((t) => t != r2);
}
function ME(n, t) {
  let e = dh, r, s = n.length;
  for (; s && (e = e.get(n[--s]), !!e); ) {
    let { V: _ } = e;
    _ && (r = _, n.length = s);
  }
  return r;
}
const c2 = new Uint8Array(32);
c2.fill(0);
function id(n) {
  return W(n.length !== 0, "invalid ENS name; empty component", "comp", n), n;
}
function u2(n) {
  const t = qi(xE(n)), e = [];
  if (n.length === 0)
    return e;
  let r = 0;
  for (let s = 0; s < t.length; s++)
    t[s] === 46 && (e.push(id(t.slice(r, s))), r = s + 1);
  return W(r < t.length, "invalid ENS name; empty component", "name", n), e.push(id(t.slice(r))), e;
}
function xE(n) {
  try {
    if (n.length === 0)
      throw new Error("empty label");
    return AE(n);
  } catch (t) {
    W(!1, `invalid ENS name (${t.message})`, "name", n);
  }
}
function gh(n) {
  W(typeof n == "string", "invalid ENS name; not a string", "name", n), W(n.length, "invalid ENS name (empty label)", "name", n);
  let t = c2;
  const e = u2(n);
  for (; e.length; )
    t = de(pe([t, de(e.pop())]));
  return Rt(t);
}
function BE(n, t) {
  const e = t;
  return W(e <= 255, "DNS encoded label cannot exceed 255", "length", e), Rt(pe(u2(n).map((r) => {
    W(r.length <= e, `label ${JSON.stringify(n)} exceeds ${e} bytes`, "name", n);
    const s = new Uint8Array(r.length + 1);
    return s.set(r, 1), s[0] = s.length - 1, s;
  }))) + "00";
}
function zl(n, t) {
  return {
    address: jt(n),
    storageKeys: t.map((e, r) => (W(ee(e, 32), "invalid slot", `storageKeys[${r}]`, e), e.toLowerCase()))
  };
}
function C_(n) {
  if (Array.isArray(n))
    return n.map((e, r) => Array.isArray(e) ? (W(e.length === 2, "invalid slot set", `value[${r}]`, e), zl(e[0], e[1])) : (W(e != null && typeof e == "object", "invalid address-slot set", "value", n), zl(e.address, e.storageKeys)));
  W(n != null && typeof n == "object", "invalid access list", "value", n);
  const t = Object.keys(n).map((e) => {
    const r = n[e].reduce((s, _) => (s[_] = !0, s), {});
    return zl(e, Object.keys(r).sort());
  });
  return t.sort((e, r) => e.address.localeCompare(r.address)), t;
}
function CE(n) {
  let t;
  return typeof n == "string" ? t = iu.computePublicKey(n, !1) : t = n.publicKey, jt(de("0x" + t.substring(4)).substring(26));
}
function f2(n, t) {
  return CE(iu.recoverPublicKey(n, t));
}
const ye = BigInt(0), IE = BigInt(2), NE = BigInt(27), OE = BigInt(28), kE = BigInt(35), TE = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), vl = 4096 * 32;
function sd(n, t) {
  let e = n.toString(16);
  for (; e.length < 2; )
    e = "0" + e;
  return e += Ic(t).substring(4), "0x" + e;
}
function Ff(n) {
  return n === "0x" ? null : jt(n);
}
function tw(n, t) {
  try {
    return C_(n);
  } catch (e) {
    W(!1, e.message, t, n);
  }
}
function Mu(n, t) {
  return n === "0x" ? 0 : Ft(n, t);
}
function le(n, t) {
  if (n === "0x")
    return ye;
  const e = zt(n, t);
  return W(e <= TE, "value exceeds uint size", t, e), e;
}
function ne(n, t) {
  const e = zt(n, "value"), r = Ne(e);
  return W(r.length <= 32, "value too large", `tx.${t}`, e), r;
}
function ew(n) {
  return C_(n).map((t) => [t.address, t.storageKeys]);
}
function GE(n, t) {
  W(Array.isArray(n), `invalid ${t}`, "value", n);
  for (let e = 0; e < n.length; e++)
    W(ee(n[e], 32), "invalid ${ param } hash", `value[${e}]`, n[e]);
  return n;
}
function UE(n) {
  const t = Of(n);
  W(Array.isArray(t) && (t.length === 9 || t.length === 6), "invalid field count for legacy transaction", "data", n);
  const e = {
    type: 0,
    nonce: Mu(t[0], "nonce"),
    gasPrice: le(t[1], "gasPrice"),
    gasLimit: le(t[2], "gasLimit"),
    to: Ff(t[3]),
    value: le(t[4], "value"),
    data: Rt(t[5]),
    chainId: ye
  };
  if (t.length === 6)
    return e;
  const r = le(t[6], "v"), s = le(t[7], "r"), _ = le(t[8], "s");
  if (s === ye && _ === ye)
    e.chainId = r;
  else {
    let a = (r - kE) / IE;
    a < ye && (a = ye), e.chainId = a, W(a !== ye || r === NE || r === OE, "non-canonical legacy v", "v", t[6]), e.signature = zr.from({
      r: S_(t[7], 32),
      s: S_(t[8], 32),
      v: r
    });
  }
  return e;
}
function FE(n, t) {
  const e = [
    ne(n.nonce, "nonce"),
    ne(n.gasPrice || 0, "gasPrice"),
    ne(n.gasLimit, "gasLimit"),
    n.to || "0x",
    ne(n.value, "value"),
    n.data
  ];
  let r = ye;
  if (n.chainId != ye)
    r = zt(n.chainId, "tx.chainId"), W(!t || t.networkV == null || t.legacyChainId === r, "tx.chainId/sig.v mismatch", "sig", t);
  else if (n.signature) {
    const _ = n.signature.legacyChainId;
    _ != null && (r = _);
  }
  if (!t)
    return r !== ye && (e.push(Ne(r)), e.push("0x"), e.push("0x")), R_(e);
  let s = BigInt(27 + t.yParity);
  return r !== ye ? s = zr.getChainIdV(r, t.v) : BigInt(t.v) !== s && W(!1, "tx.chainId/sig.v mismatch", "sig", t), e.push(Ne(s)), e.push(Ne(t.r)), e.push(Ne(t.s)), R_(e);
}
function rw(n, t) {
  let e;
  try {
    if (e = Mu(t[0], "yParity"), e !== 0 && e !== 1)
      throw new Error("bad yParity");
  } catch {
    W(!1, "invalid yParity", "yParity", t[0]);
  }
  const r = S_(t[1], 32), s = S_(t[2], 32), _ = zr.from({ r, s, yParity: e });
  n.signature = _;
}
function KE(n) {
  const t = Of(Vt(n).slice(1));
  W(Array.isArray(t) && (t.length === 9 || t.length === 12), "invalid field count for transaction type: 2", "data", Rt(n));
  const e = {
    type: 2,
    chainId: le(t[0], "chainId"),
    nonce: Mu(t[1], "nonce"),
    maxPriorityFeePerGas: le(t[2], "maxPriorityFeePerGas"),
    maxFeePerGas: le(t[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: le(t[4], "gasLimit"),
    to: Ff(t[5]),
    value: le(t[6], "value"),
    data: Rt(t[7]),
    accessList: tw(t[8], "accessList")
  };
  return t.length === 9 || rw(e, t.slice(9)), e;
}
function DE(n, t) {
  const e = [
    ne(n.chainId, "chainId"),
    ne(n.nonce, "nonce"),
    ne(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    ne(n.maxFeePerGas || 0, "maxFeePerGas"),
    ne(n.gasLimit, "gasLimit"),
    n.to || "0x",
    ne(n.value, "value"),
    n.data,
    ew(n.accessList || [])
  ];
  return t && (e.push(ne(t.yParity, "yParity")), e.push(Ne(t.r)), e.push(Ne(t.s))), pe(["0x02", R_(e)]);
}
function LE(n) {
  const t = Of(Vt(n).slice(1));
  W(Array.isArray(t) && (t.length === 8 || t.length === 11), "invalid field count for transaction type: 1", "data", Rt(n));
  const e = {
    type: 1,
    chainId: le(t[0], "chainId"),
    nonce: Mu(t[1], "nonce"),
    gasPrice: le(t[2], "gasPrice"),
    gasLimit: le(t[3], "gasLimit"),
    to: Ff(t[4]),
    value: le(t[5], "value"),
    data: Rt(t[6]),
    accessList: tw(t[7], "accessList")
  };
  return t.length === 8 || rw(e, t.slice(8)), e;
}
function jE(n, t) {
  const e = [
    ne(n.chainId, "chainId"),
    ne(n.nonce, "nonce"),
    ne(n.gasPrice || 0, "gasPrice"),
    ne(n.gasLimit, "gasLimit"),
    n.to || "0x",
    ne(n.value, "value"),
    n.data,
    ew(n.accessList || [])
  ];
  return t && (e.push(ne(t.yParity, "recoveryParam")), e.push(Ne(t.r)), e.push(Ne(t.s))), pe(["0x01", R_(e)]);
}
function VE(n) {
  let t = Of(Vt(n).slice(1)), e = "3", r = null;
  if (t.length === 4 && Array.isArray(t[0])) {
    e = "3 (network format)";
    const _ = t[1], a = t[2], c = t[3];
    W(Array.isArray(_), "invalid network format: blobs not an array", "fields[1]", _), W(Array.isArray(a), "invalid network format: commitments not an array", "fields[2]", a), W(Array.isArray(c), "invalid network format: proofs not an array", "fields[3]", c), W(_.length === a.length, "invalid network format: blobs/commitments length mismatch", "fields", t), W(_.length === c.length, "invalid network format: blobs/proofs length mismatch", "fields", t), r = [];
    for (let u = 0; u < t[1].length; u++)
      r.push({
        data: _[u],
        commitment: a[u],
        proof: c[u]
      });
    t = t[0];
  }
  W(Array.isArray(t) && (t.length === 11 || t.length === 14), `invalid field count for transaction type: ${e}`, "data", Rt(n));
  const s = {
    type: 3,
    chainId: le(t[0], "chainId"),
    nonce: Mu(t[1], "nonce"),
    maxPriorityFeePerGas: le(t[2], "maxPriorityFeePerGas"),
    maxFeePerGas: le(t[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: le(t[4], "gasLimit"),
    to: Ff(t[5]),
    value: le(t[6], "value"),
    data: Rt(t[7]),
    accessList: tw(t[8], "accessList"),
    maxFeePerBlobGas: le(t[9], "maxFeePerBlobGas"),
    blobVersionedHashes: t[10]
  };
  r && (s.blobs = r), W(s.to != null, `invalid address for transaction type: ${e}`, "data", n), W(Array.isArray(s.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", n);
  for (let _ = 0; _ < s.blobVersionedHashes.length; _++)
    W(ee(s.blobVersionedHashes[_], 32), `invalid blobVersionedHash at index ${_}: must be length 32`, "data", n);
  return t.length === 11 || rw(s, t.slice(11)), s;
}
function YE(n, t, e) {
  const r = [
    ne(n.chainId, "chainId"),
    ne(n.nonce, "nonce"),
    ne(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    ne(n.maxFeePerGas || 0, "maxFeePerGas"),
    ne(n.gasLimit, "gasLimit"),
    n.to || nu,
    ne(n.value, "value"),
    n.data,
    ew(n.accessList || []),
    ne(n.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    GE(n.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  return t && (r.push(ne(t.yParity, "yParity")), r.push(Ne(t.r)), r.push(Ne(t.s)), e) ? pe([
    "0x03",
    R_([
      r,
      e.map((s) => s.data),
      e.map((s) => s.commitment),
      e.map((s) => s.proof)
    ])
  ]) : pe(["0x03", R_(r)]);
}
var Fr, Ya, Ha, qa, Qa, Wa, Ja, $a, Za, Xa, tc, ec, u_, cs, Ti, us, rc, $u;
const Bi = class Bi {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    nt(this, rc);
    nt(this, Fr);
    nt(this, Ya);
    nt(this, Ha);
    nt(this, qa);
    nt(this, Qa);
    nt(this, Wa);
    nt(this, Ja);
    nt(this, $a);
    nt(this, Za);
    nt(this, Xa);
    nt(this, tc);
    nt(this, ec);
    nt(this, u_);
    nt(this, cs);
    nt(this, Ti);
    nt(this, us);
    K(this, Fr, null), K(this, Ya, null), K(this, qa, 0), K(this, Qa, ye), K(this, Wa, null), K(this, Ja, null), K(this, $a, null), K(this, Ha, "0x"), K(this, Za, ye), K(this, Xa, ye), K(this, tc, null), K(this, ec, null), K(this, u_, null), K(this, cs, null), K(this, us, null), K(this, Ti, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return A(this, Fr);
  }
  set type(t) {
    switch (t) {
      case null:
        K(this, Fr, null);
        break;
      case 0:
      case "legacy":
        K(this, Fr, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        K(this, Fr, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        K(this, Fr, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        K(this, Fr, 3);
        break;
      default:
        W(!1, "unsupported transaction type", "type", t);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const t = A(this, Ya);
    return t == null && this.type === 3 ? nu : t;
  }
  set to(t) {
    K(this, Ya, t == null ? null : jt(t));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return A(this, qa);
  }
  set nonce(t) {
    K(this, qa, Ft(t, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return A(this, Qa);
  }
  set gasLimit(t) {
    K(this, Qa, zt(t));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const t = A(this, Wa);
    return t == null && (this.type === 0 || this.type === 1) ? ye : t;
  }
  set gasPrice(t) {
    K(this, Wa, t == null ? null : zt(t, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const t = A(this, Ja);
    return t ?? (this.type === 2 || this.type === 3 ? ye : null);
  }
  set maxPriorityFeePerGas(t) {
    K(this, Ja, t == null ? null : zt(t, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const t = A(this, $a);
    return t ?? (this.type === 2 || this.type === 3 ? ye : null);
  }
  set maxFeePerGas(t) {
    K(this, $a, t == null ? null : zt(t, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return A(this, Ha);
  }
  set data(t) {
    K(this, Ha, Rt(t));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return A(this, Za);
  }
  set value(t) {
    K(this, Za, zt(t, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return A(this, Xa);
  }
  set chainId(t) {
    K(this, Xa, zt(t));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return A(this, tc) || null;
  }
  set signature(t) {
    K(this, tc, t == null ? null : zr.from(t));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const t = A(this, ec) || null;
    return t ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null);
  }
  set accessList(t) {
    K(this, ec, t == null ? null : C_(t));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const t = A(this, u_);
    return t == null && this.type === 3 ? ye : t;
  }
  set maxFeePerBlobGas(t) {
    K(this, u_, t == null ? null : zt(t, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let t = A(this, cs);
    return t == null && this.type === 3 ? [] : t;
  }
  set blobVersionedHashes(t) {
    if (t != null) {
      W(Array.isArray(t), "blobVersionedHashes must be an Array", "value", t), t = t.slice();
      for (let e = 0; e < t.length; e++)
        W(ee(t[e], 32), "invalid blobVersionedHash", `value[${e}]`, t[e]);
    }
    K(this, cs, t);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    return A(this, us) == null ? null : A(this, us).map((t) => Object.assign({}, t));
  }
  set blobs(t) {
    if (t == null) {
      K(this, us, null);
      return;
    }
    const e = [], r = [];
    for (let s = 0; s < t.length; s++) {
      const _ = t[s];
      if (Kh(_)) {
        ht(A(this, Ti), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let a = Vt(_);
        if (W(a.length <= vl, "blob is too large", `blobs[${s}]`, _), a.length !== vl) {
          const l = new Uint8Array(vl);
          l.set(a), a = l;
        }
        const c = A(this, Ti).blobToKzgCommitment(a), u = Rt(A(this, Ti).computeBlobKzgProof(a, c));
        e.push({
          data: Rt(a),
          commitment: Rt(c),
          proof: u
        }), r.push(sd(1, c));
      } else {
        const a = Rt(_.commitment);
        e.push({
          data: Rt(_.data),
          commitment: a,
          proof: Rt(_.proof)
        }), r.push(sd(1, a));
      }
    }
    K(this, us, e), K(this, cs, r);
  }
  get kzg() {
    return A(this, Ti);
  }
  set kzg(t) {
    K(this, Ti, t);
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    return this.signature == null ? null : de(At(this, rc, $u).call(this, !0, !1));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return de(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    return this.signature == null ? null : f2(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    return this.signature == null ? null : iu.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return At(this, rc, $u).call(this, !0, !0);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return At(this, rc, $u).call(this, !1, !1);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const t = this.inferTypes();
    return t.indexOf(2) >= 0 ? 2 : t.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const t = this.gasPrice != null, e = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null, r = this.accessList != null, s = A(this, u_) != null || A(this, cs);
    this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && ht(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this }), ht(!e || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this }), ht(this.type !== 0 || !r, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const _ = [];
    return this.type != null ? _.push(this.type) : e ? _.push(2) : t ? (_.push(1), r || _.push(0)) : r ? (_.push(1), _.push(2)) : (s && this.to || (_.push(0), _.push(1), _.push(2)), _.push(3)), _.sort(), _;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return Bi.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const t = (e) => e == null ? null : e.toString();
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: t(this.gasLimit),
      gasPrice: t(this.gasPrice),
      maxPriorityFeePerGas: t(this.maxPriorityFeePerGas),
      maxFeePerGas: t(this.maxFeePerGas),
      value: t(this.value),
      chainId: t(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(t) {
    if (t == null)
      return new Bi();
    if (typeof t == "string") {
      const r = Vt(t);
      if (r[0] >= 127)
        return Bi.from(UE(r));
      switch (r[0]) {
        case 1:
          return Bi.from(LE(r));
        case 2:
          return Bi.from(KE(r));
        case 3:
          return Bi.from(VE(r));
      }
      ht(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const e = new Bi();
    return t.type != null && (e.type = t.type), t.to != null && (e.to = t.to), t.nonce != null && (e.nonce = t.nonce), t.gasLimit != null && (e.gasLimit = t.gasLimit), t.gasPrice != null && (e.gasPrice = t.gasPrice), t.maxPriorityFeePerGas != null && (e.maxPriorityFeePerGas = t.maxPriorityFeePerGas), t.maxFeePerGas != null && (e.maxFeePerGas = t.maxFeePerGas), t.maxFeePerBlobGas != null && (e.maxFeePerBlobGas = t.maxFeePerBlobGas), t.data != null && (e.data = t.data), t.value != null && (e.value = t.value), t.chainId != null && (e.chainId = t.chainId), t.signature != null && (e.signature = zr.from(t.signature)), t.accessList != null && (e.accessList = t.accessList), t.blobVersionedHashes != null && (e.blobVersionedHashes = t.blobVersionedHashes), t.kzg != null && (e.kzg = t.kzg), t.blobs != null && (e.blobs = t.blobs), t.hash != null && (W(e.isSigned(), "unsigned transaction cannot define '.hash'", "tx", t), W(e.hash === t.hash, "hash mismatch", "tx", t)), t.from != null && (W(e.isSigned(), "unsigned transaction cannot define '.from'", "tx", t), W(e.from.toLowerCase() === (t.from || "").toLowerCase(), "from mismatch", "tx", t)), e;
  }
};
Fr = new WeakMap(), Ya = new WeakMap(), Ha = new WeakMap(), qa = new WeakMap(), Qa = new WeakMap(), Wa = new WeakMap(), Ja = new WeakMap(), $a = new WeakMap(), Za = new WeakMap(), Xa = new WeakMap(), tc = new WeakMap(), ec = new WeakMap(), u_ = new WeakMap(), cs = new WeakMap(), Ti = new WeakMap(), us = new WeakMap(), rc = new WeakSet(), $u = function(t, e) {
  ht(!t || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const r = t ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return FE(this, r);
    case 1:
      return jE(this, r);
    case 2:
      return DE(this, r);
    case 3:
      return YE(this, r, e ? this.blobs : null);
  }
  ht(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
let gf = Bi;
const l2 = new Uint8Array(32);
l2.fill(0);
const HE = BigInt(-1), p2 = BigInt(0), h2 = BigInt(1), qE = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function QE(n) {
  const t = Vt(n), e = t.length % 32;
  return e ? pe([t, l2.slice(e)]) : Rt(t);
}
const WE = zs(h2, 32), JE = zs(p2, 32), _d = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, Ml = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function od(n) {
  return function(t) {
    return W(typeof t == "string", `invalid domain value for ${JSON.stringify(n)}`, `domain.${n}`, t), t;
  };
}
const $E = {
  name: od("name"),
  version: od("version"),
  chainId: function(n) {
    const t = zt(n, "domain.chainId");
    return W(t >= 0, "invalid chain ID", "domain.chainId", n), Number.isSafeInteger(t) ? Number(t) : L_(t);
  },
  verifyingContract: function(n) {
    try {
      return jt(n).toLowerCase();
    } catch {
    }
    W(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", n);
  },
  salt: function(n) {
    const t = Vt(n, "domain.salt");
    return W(t.length === 32, 'invalid domain value "salt"', "domain.salt", n), Rt(t);
  }
};
function xl(n) {
  {
    const t = n.match(/^(u?)int(\d+)$/);
    if (t) {
      const e = t[1] === "", r = parseInt(t[2]);
      W(r % 8 === 0 && r !== 0 && r <= 256 && t[2] === String(r), "invalid numeric width", "type", n);
      const s = jc(qE, e ? r - 1 : r), _ = e ? (s + h2) * HE : p2;
      return function(a) {
        const c = zt(a, "value");
        return W(c >= _ && c <= s, `value out-of-bounds for ${n}`, "value", c), zs(e ? tA(c, 256) : c, 32);
      };
    }
  }
  {
    const t = n.match(/^bytes(\d+)$/);
    if (t) {
      const e = parseInt(t[1]);
      return W(e !== 0 && e <= 32 && t[1] === String(e), "invalid bytes width", "type", n), function(r) {
        const s = Vt(r);
        return W(s.length === e, `invalid length for ${n}`, "value", r), QE(r);
      };
    }
  }
  switch (n) {
    case "address":
      return function(t) {
        return S_(jt(t), 32);
      };
    case "bool":
      return function(t) {
        return t ? WE : JE;
      };
    case "bytes":
      return function(t) {
        return de(t);
      };
    case "string":
      return function(t) {
        return E_(t);
      };
  }
  return null;
}
function ad(n, t) {
  return `${n}(${t.map(({ name: e, type: r }) => r + " " + e).join(",")})`;
}
function Du(n) {
  const t = n.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  return t ? {
    base: t[1],
    index: t[2] + t[4],
    array: {
      base: t[1],
      prefix: t[1] + t[2],
      count: t[5] ? parseInt(t[5]) : -1
    }
  } : { base: n };
}
var bu, Gi, nc, Ef, w2;
const ir = class ir {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(t) {
    nt(this, Ef);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    $(this, "primaryType");
    nt(this, bu);
    nt(this, Gi);
    nt(this, nc);
    K(this, Gi, /* @__PURE__ */ new Map()), K(this, nc, /* @__PURE__ */ new Map());
    const e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), _ = {};
    Object.keys(t).forEach((u) => {
      _[u] = t[u].map(({ name: l, type: f }) => {
        let { base: w, index: y } = Du(f);
        return w === "int" && !t.int && (w = "int256"), w === "uint" && !t.uint && (w = "uint256"), { name: l, type: w + (y || "") };
      }), e.set(u, /* @__PURE__ */ new Set()), r.set(u, []), s.set(u, /* @__PURE__ */ new Set());
    }), K(this, bu, JSON.stringify(_));
    for (const u in _) {
      const l = /* @__PURE__ */ new Set();
      for (const f of _[u]) {
        W(!l.has(f.name), `duplicate variable name ${JSON.stringify(f.name)} in ${JSON.stringify(u)}`, "types", t), l.add(f.name);
        const w = Du(f.type).base;
        W(w !== u, `circular type reference to ${JSON.stringify(w)}`, "types", t), !xl(w) && (W(r.has(w), `unknown type ${JSON.stringify(w)}`, "types", t), r.get(w).push(u), e.get(u).add(w));
      }
    }
    const a = Array.from(r.keys()).filter((u) => r.get(u).length === 0);
    W(a.length !== 0, "missing primary type", "types", t), W(a.length === 1, `ambiguous primary types or unused types: ${a.map((u) => JSON.stringify(u)).join(", ")}`, "types", t), Bt(this, { primaryType: a[0] });
    function c(u, l) {
      W(!l.has(u), `circular type reference to ${JSON.stringify(u)}`, "types", t), l.add(u);
      for (const f of e.get(u))
        if (r.has(f)) {
          c(f, l);
          for (const w of l)
            s.get(w).add(f);
        }
      l.delete(u);
    }
    c(this.primaryType, /* @__PURE__ */ new Set());
    for (const [u, l] of s) {
      const f = Array.from(l);
      f.sort(), A(this, Gi).set(u, ad(u, _[u]) + f.map((w) => ad(w, _[w])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(A(this, bu));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(t) {
    let e = A(this, nc).get(t);
    return e || (e = At(this, Ef, w2).call(this, t), A(this, nc).set(t, e)), e;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(t) {
    const e = A(this, Gi).get(t);
    return W(e, `unknown type: ${JSON.stringify(t)}`, "name", t), e;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(t, e) {
    return this.getEncoder(t)(e);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(t, e) {
    return de(this.encodeData(t, e));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(t) {
    return this.encodeData(this.primaryType, t);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(t) {
    return this.hashStruct(this.primaryType, t);
  }
  /**
   *  @_ignore:
   */
  _visit(t, e, r) {
    if (xl(t))
      return r(t, e);
    const s = Du(t).array;
    if (s)
      return W(s.count === -1 || s.count === e.length, `array length mismatch; expected length ${s.count}`, "value", e), e.map((a) => this._visit(s.prefix, a, r));
    const _ = this.types[t];
    if (_)
      return _.reduce((a, { name: c, type: u }) => (a[c] = this._visit(u, e[c], r), a), {});
    W(!1, `unknown type: ${t}`, "type", t);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(t, e) {
    return this._visit(this.primaryType, t, e);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(t) {
    return new ir(t);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(t) {
    return ir.from(t).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(t, e, r) {
    return ir.from(e).hashStruct(t, r);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(t) {
    const e = [];
    for (const r in t) {
      if (t[r] == null)
        continue;
      const s = _d[r];
      W(s, `invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", t), e.push({ name: r, type: s });
    }
    return e.sort((r, s) => Ml.indexOf(r.name) - Ml.indexOf(s.name)), ir.hashStruct("EIP712Domain", { EIP712Domain: e }, t);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(t, e, r) {
    return pe([
      "0x1901",
      ir.hashDomain(t),
      ir.from(e).hash(r)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(t, e, r) {
    return de(ir.encode(t, e, r));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(t, e, r, s) {
    t = Object.assign({}, t);
    for (const c in t)
      t[c] == null && delete t[c];
    const _ = {};
    t.verifyingContract && !ee(t.verifyingContract, 20) && (_[t.verifyingContract] = "0x");
    const a = ir.from(e);
    a.visit(r, (c, u) => (c === "address" && !ee(u, 20) && (_[u] = "0x"), u));
    for (const c in _)
      _[c] = await s(c);
    return t.verifyingContract && _[t.verifyingContract] && (t.verifyingContract = _[t.verifyingContract]), r = a.visit(r, (c, u) => c === "address" && _[u] ? _[u] : u), { domain: t, value: r };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(t, e, r) {
    ir.hashDomain(t);
    const s = {}, _ = [];
    Ml.forEach((u) => {
      const l = t[u];
      l != null && (s[u] = $E[u](l), _.push({ name: u, type: _d[u] }));
    });
    const a = ir.from(e);
    e = a.types;
    const c = Object.assign({}, e);
    return W(c.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", e), c.EIP712Domain = _, a.encode(r), {
      types: c,
      domain: s,
      primaryType: a.primaryType,
      message: a.visit(r, (u, l) => {
        if (u.match(/^bytes(\d*)/))
          return Rt(Vt(l));
        if (u.match(/^u?int/))
          return zt(l).toString();
        switch (u) {
          case "address":
            return l.toLowerCase();
          case "bool":
            return !!l;
          case "string":
            return W(typeof l == "string", "invalid string", "value", l), l;
        }
        W(!1, "unsupported type", "type", u);
      })
    };
  }
};
bu = new WeakMap(), Gi = new WeakMap(), nc = new WeakMap(), Ef = new WeakSet(), w2 = function(t) {
  {
    const s = xl(t);
    if (s)
      return s;
  }
  const e = Du(t).array;
  if (e) {
    const s = e.prefix, _ = this.getEncoder(s);
    return (a) => {
      W(e.count === -1 || e.count === a.length, `array length mismatch; expected length ${e.count}`, "value", a);
      let c = a.map(_);
      return A(this, Gi).has(s) && (c = c.map(de)), de(pe(c));
    };
  }
  const r = this.types[t];
  if (r) {
    const s = E_(A(this, Gi).get(t));
    return (_) => {
      const a = r.map(({ name: c, type: u }) => {
        const l = this.getEncoder(u)(_[c]);
        return A(this, Gi).has(u) ? de(l) : l;
      });
      return a.unshift(s), pe(a);
    };
  }
  W(!1, `unknown type: ${t}`, "type", t);
};
let cu = ir;
function d2(n, t, e, r) {
  return f2(cu.hash(n, t, e), r);
}
function Te(n) {
  const t = /* @__PURE__ */ new Set();
  return n.forEach((e) => t.add(e)), Object.freeze(t);
}
const ZE = "external public payable override", XE = Te(ZE.split(" ")), g2 = "constant external internal payable private public pure view override", tP = Te(g2.split(" ")), b2 = "constructor error event fallback function receive struct", y2 = Te(b2.split(" ")), A2 = "calldata memory storage payable indexed", eP = Te(A2.split(" ")), rP = "tuple returns", nP = [b2, A2, rP, g2].join(" "), iP = Te(nP.split(" ")), sP = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
}, _P = new RegExp("^(\\s*)"), oP = new RegExp("^([0-9]+)"), aP = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"), m2 = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"), S2 = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var me, Ar, yu, bh;
const Pf = class Pf {
  constructor(t) {
    nt(this, yu);
    nt(this, me);
    nt(this, Ar);
    K(this, me, 0), K(this, Ar, t.slice());
  }
  get offset() {
    return A(this, me);
  }
  get length() {
    return A(this, Ar).length - A(this, me);
  }
  clone() {
    return new Pf(A(this, Ar));
  }
  reset() {
    K(this, me, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(t) {
    const e = this.peek();
    if (e.type !== "KEYWORD" || !t.has(e.text))
      throw new Error(`expected keyword ${e.text}`);
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(t) {
    if (this.peek().type !== t) {
      const e = this.peek();
      throw new Error(`expected ${t}; got ${e.type} ${JSON.stringify(e.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const t = this.peek();
    if (t.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const e = At(this, yu, bh).call(this, A(this, me) + 1, t.match + 1);
    return K(this, me, t.match + 1), e;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const t = this.peek();
    if (t.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const e = [];
    for (; A(this, me) < t.match - 1; ) {
      const r = this.peek().linkNext;
      e.push(At(this, yu, bh).call(this, A(this, me) + 1, r)), K(this, me, r);
    }
    return K(this, me, t.match + 1), e;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (A(this, me) >= A(this, Ar).length)
      throw new Error("out-of-bounds");
    return A(this, Ar)[A(this, me)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(t) {
    const e = this.peekType("KEYWORD");
    return e != null && t.has(e) ? e : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(t) {
    if (this.length === 0)
      return null;
    const e = this.peek();
    return e.type === t ? e.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const t = this.peek();
    return Fc(this, me)._++, t;
  }
  toString() {
    const t = [];
    for (let e = A(this, me); e < A(this, Ar).length; e++) {
      const r = A(this, Ar)[e];
      t.push(`${r.type}:${r.text}`);
    }
    return `<TokenString ${t.join(" ")}>`;
  }
};
me = new WeakMap(), Ar = new WeakMap(), yu = new WeakSet(), bh = function(t = 0, e = 0) {
  return new Pf(A(this, Ar).slice(t, e).map((r) => Object.freeze(Object.assign({}, r, {
    match: r.match - t,
    linkBack: r.linkBack - t,
    linkNext: r.linkNext - t
  }))));
};
let vr = Pf;
function xs(n) {
  const t = [], e = (a) => {
    const c = _ < n.length ? JSON.stringify(n[_]) : "$EOI";
    throw new Error(`invalid token ${c} at ${_}: ${a}`);
  };
  let r = [], s = [], _ = 0;
  for (; _ < n.length; ) {
    let a = n.substring(_), c = a.match(_P);
    c && (_ += c[1].length, a = n.substring(_));
    const u = { depth: r.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset: _, value: -1 };
    t.push(u);
    let l = sP[a[0]] || "";
    if (l) {
      if (u.type = l, u.text = a[0], _++, l === "OPEN_PAREN")
        r.push(t.length - 1), s.push(t.length - 1);
      else if (l == "CLOSE_PAREN")
        r.length === 0 && e("no matching open bracket"), u.match = r.pop(), t[u.match].match = t.length - 1, u.depth--, u.linkBack = s.pop(), t[u.linkBack].linkNext = t.length - 1;
      else if (l === "COMMA")
        u.linkBack = s.pop(), t[u.linkBack].linkNext = t.length - 1, s.push(t.length - 1);
      else if (l === "OPEN_BRACKET")
        u.type = "BRACKET";
      else if (l === "CLOSE_BRACKET") {
        let f = t.pop().text;
        if (t.length > 0 && t[t.length - 1].type === "NUMBER") {
          const w = t.pop().text;
          f = w + f, t[t.length - 1].value = Ft(w);
        }
        if (t.length === 0 || t[t.length - 1].type !== "BRACKET")
          throw new Error("missing opening bracket");
        t[t.length - 1].text += f;
      }
      continue;
    }
    if (c = a.match(aP), c) {
      if (u.text = c[1], _ += u.text.length, iP.has(u.text)) {
        u.type = "KEYWORD";
        continue;
      }
      if (u.text.match(S2)) {
        u.type = "TYPE";
        continue;
      }
      u.type = "ID";
      continue;
    }
    if (c = a.match(oP), c) {
      u.text = c[1], u.type = "NUMBER", _ += u.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(a[0])} at position ${_}`);
  }
  return new vr(t.map((a) => Object.freeze(a)));
}
function cd(n, t) {
  let e = [];
  for (const r in t.keys())
    n.has(r) && e.push(r);
  if (e.length > 1)
    throw new Error(`conflicting types: ${e.join(", ")}`);
}
function Kf(n, t) {
  if (t.peekKeyword(y2)) {
    const e = t.pop().text;
    if (e !== n)
      throw new Error(`expected ${n}, got ${e}`);
  }
  return t.popType("ID");
}
function Ji(n, t) {
  const e = /* @__PURE__ */ new Set();
  for (; ; ) {
    const r = n.peekType("KEYWORD");
    if (r == null || t && !t.has(r))
      break;
    if (n.pop(), e.has(r))
      throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
    e.add(r);
  }
  return Object.freeze(e);
}
function R2(n) {
  let t = Ji(n, tP);
  return cd(t, Te("constant payable nonpayable".split(" "))), cd(t, Te("pure view payable nonpayable".split(" "))), t.has("view") ? "view" : t.has("pure") ? "pure" : t.has("payable") ? "payable" : t.has("nonpayable") ? "nonpayable" : t.has("constant") ? "view" : "nonpayable";
}
function Qi(n, t) {
  return n.popParams().map((e) => Ee.from(e, t));
}
function E2(n) {
  if (n.peekType("AT")) {
    if (n.pop(), n.peekType("NUMBER"))
      return zt(n.pop().text);
    throw new Error("invalid gas");
  }
  return null;
}
function P_(n) {
  if (n.length)
    throw new Error(`unexpected tokens at offset ${n.offset}: ${n.toString()}`);
}
const cP = new RegExp(/^(.*)\[([0-9]*)\]$/);
function ud(n) {
  const t = n.match(S2);
  if (W(t, "invalid type", "type", n), n === "uint")
    return "uint256";
  if (n === "int")
    return "int256";
  if (t[2]) {
    const e = parseInt(t[2]);
    W(e !== 0 && e <= 32, "invalid bytes length", "type", n);
  } else if (t[3]) {
    const e = parseInt(t[3]);
    W(e !== 0 && e <= 256 && e % 8 === 0, "invalid numeric width", "type", n);
  }
  return n;
}
const se = {}, Ye = Symbol.for("_ethers_internal"), fd = "_ParamTypeInternal", ld = "_ErrorInternal", pd = "_EventInternal", hd = "_ConstructorInternal", wd = "_FallbackInternal", dd = "_FunctionInternal", gd = "_StructInternal";
var ic, Zu;
const sr = class sr {
  /**
   *  @private
   */
  constructor(t, e, r, s, _, a, c, u) {
    nt(this, ic);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    $(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    $(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    $(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    $(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    $(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    $(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    $(this, "arrayChildren");
    if (Cf(t, se, "ParamType"), Object.defineProperty(this, Ye, { value: fd }), a && (a = Object.freeze(a.slice())), s === "array") {
      if (c == null || u == null)
        throw new Error("");
    } else if (c != null || u != null)
      throw new Error("");
    if (s === "tuple") {
      if (a == null)
        throw new Error("");
    } else if (a != null)
      throw new Error("");
    Bt(this, {
      name: e,
      type: r,
      baseType: s,
      indexed: _,
      components: a,
      arrayLength: c,
      arrayChildren: u
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(t) {
    if (t == null && (t = "sighash"), t === "json") {
      const r = this.name || "";
      if (this.isArray()) {
        const _ = JSON.parse(this.arrayChildren.format("json"));
        return _.name = r, _.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`, JSON.stringify(_);
      }
      const s = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: r
      };
      return typeof this.indexed == "boolean" && (s.indexed = this.indexed), this.isTuple() && (s.components = this.components.map((_) => JSON.parse(_.format(t)))), JSON.stringify(s);
    }
    let e = "";
    return this.isArray() ? (e += this.arrayChildren.format(t), e += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? e += "(" + this.components.map((r) => r.format(t)).join(t === "full" ? ", " : ",") + ")" : e += this.type, t !== "sighash" && (this.indexed === !0 && (e += " indexed"), t === "full" && this.name && (e += " " + this.name)), e;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(t, e) {
    if (this.isArray()) {
      if (!Array.isArray(t))
        throw new Error("invalid array value");
      if (this.arrayLength !== -1 && t.length !== this.arrayLength)
        throw new Error("array is wrong length");
      const r = this;
      return t.map((s) => r.arrayChildren.walk(s, e));
    }
    if (this.isTuple()) {
      if (!Array.isArray(t))
        throw new Error("invalid tuple value");
      if (t.length !== this.components.length)
        throw new Error("array is wrong length");
      const r = this;
      return t.map((s, _) => r.components[_].walk(s, e));
    }
    return e(this.type, t);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(t, e) {
    const r = [], s = [t];
    return At(this, ic, Zu).call(this, r, t, e, (_) => {
      s[0] = _;
    }), r.length && await Promise.all(r), s[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(t, e) {
    if (sr.isParamType(t))
      return t;
    if (typeof t == "string")
      try {
        return sr.from(xs(t), e);
      } catch {
        W(!1, "invalid param type", "obj", t);
      }
    else if (t instanceof vr) {
      let c = "", u = "", l = null;
      Ji(t, Te(["tuple"])).has("tuple") || t.peekType("OPEN_PAREN") ? (u = "tuple", l = t.popParams().map((C) => sr.from(C)), c = `tuple(${l.map((C) => C.format()).join(",")})`) : (c = ud(t.popType("TYPE")), u = c);
      let f = null, w = null;
      for (; t.length && t.peekType("BRACKET"); ) {
        const C = t.pop();
        f = new sr(se, "", c, u, null, l, w, f), w = C.value, c += C.text, u = "array", l = null;
      }
      let y = null;
      if (Ji(t, eP).has("indexed")) {
        if (!e)
          throw new Error("");
        y = !0;
      }
      const x = t.peekType("ID") ? t.pop().text : "";
      if (t.length)
        throw new Error("leftover tokens");
      return new sr(se, x, c, u, y, l, w, f);
    }
    const r = t.name;
    W(!r || typeof r == "string" && r.match(m2), "invalid name", "obj.name", r);
    let s = t.indexed;
    s != null && (W(e, "parameter cannot be indexed", "obj.indexed", t.indexed), s = !!s);
    let _ = t.type, a = _.match(cP);
    if (a) {
      const c = parseInt(a[2] || "-1"), u = sr.from({
        type: a[1],
        components: t.components
      });
      return new sr(se, r || "", _, "array", s, null, c, u);
    }
    if (_ === "tuple" || _.startsWith(
      "tuple("
      /* fix: ) */
    ) || _.startsWith(
      "("
      /* fix: ) */
    )) {
      const c = t.components != null ? t.components.map((l) => sr.from(l)) : null;
      return new sr(se, r || "", _, "tuple", s, c, null, null);
    }
    return _ = ud(t.type), new sr(se, r || "", _, _, s, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(t) {
    return t && t[Ye] === fd;
  }
};
ic = new WeakSet(), Zu = function(t, e, r, s) {
  if (this.isArray()) {
    if (!Array.isArray(e))
      throw new Error("invalid array value");
    if (this.arrayLength !== -1 && e.length !== this.arrayLength)
      throw new Error("array is wrong length");
    const a = this.arrayChildren, c = e.slice();
    c.forEach((u, l) => {
      var f;
      At(f = a, ic, Zu).call(f, t, u, r, (w) => {
        c[l] = w;
      });
    }), s(c);
    return;
  }
  if (this.isTuple()) {
    const a = this.components;
    let c;
    if (Array.isArray(e))
      c = e.slice();
    else {
      if (e == null || typeof e != "object")
        throw new Error("invalid tuple value");
      c = a.map((u) => {
        if (!u.name)
          throw new Error("cannot use object value with unnamed components");
        if (!(u.name in e))
          throw new Error(`missing value for component ${u.name}`);
        return e[u.name];
      });
    }
    if (c.length !== this.components.length)
      throw new Error("array is wrong length");
    c.forEach((u, l) => {
      var f;
      At(f = a[l], ic, Zu).call(f, t, u, r, (w) => {
        c[l] = w;
      });
    }), s(c);
    return;
  }
  const _ = r(this.type, e);
  _.then ? t.push(async function() {
    s(await _);
  }()) : s(_);
};
let Ee = sr;
class z_ {
  /**
   *  @private
   */
  constructor(t, e, r) {
    /**
     *  The type of the fragment.
     */
    $(this, "type");
    /**
     *  The inputs for the fragment.
     */
    $(this, "inputs");
    Cf(t, se, "Fragment"), r = Object.freeze(r.slice()), Bt(this, { type: e, inputs: r });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(t) {
    if (typeof t == "string") {
      try {
        z_.from(JSON.parse(t));
      } catch {
      }
      return z_.from(xs(t));
    }
    if (t instanceof vr)
      switch (t.peekKeyword(y2)) {
        case "constructor":
          return Yi.from(t);
        case "error":
          return Ve.from(t);
        case "event":
          return Ri.from(t);
        case "fallback":
        case "receive":
          return Ci.from(t);
        case "function":
          return Ei.from(t);
        case "struct":
          return A_.from(t);
      }
    else if (typeof t == "object") {
      switch (t.type) {
        case "constructor":
          return Yi.from(t);
        case "error":
          return Ve.from(t);
        case "event":
          return Ri.from(t);
        case "fallback":
        case "receive":
          return Ci.from(t);
        case "function":
          return Ei.from(t);
        case "struct":
          return A_.from(t);
      }
      ht(!1, `unsupported type: ${t.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    W(!1, "unsupported frgament object", "obj", t);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(t) {
    return Yi.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(t) {
    return Ve.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(t) {
    return Ri.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(t) {
    return Ei.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(t) {
    return A_.isFragment(t);
  }
}
class Df extends z_ {
  /**
   *  @private
   */
  constructor(e, r, s, _) {
    super(e, r, _);
    /**
     *  The name of the fragment.
     */
    $(this, "name");
    W(typeof s == "string" && s.match(m2), "invalid identifier", "name", s), _ = Object.freeze(_.slice()), Bt(this, { name: s });
  }
}
function uu(n, t) {
  return "(" + t.map((e) => e.format(n)).join(n === "full" ? ", " : ",") + ")";
}
class Ve extends Df {
  /**
   *  @private
   */
  constructor(t, e, r) {
    super(t, "error", e, r), Object.defineProperty(this, Ye, { value: ld });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return E_(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(t) {
    if (t == null && (t = "sighash"), t === "json")
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(t)))
      });
    const e = [];
    return t !== "sighash" && e.push("error"), e.push(this.name + uu(t, this.inputs)), e.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(t) {
    if (Ve.isFragment(t))
      return t;
    if (typeof t == "string")
      return Ve.from(xs(t));
    if (t instanceof vr) {
      const e = Kf("error", t), r = Qi(t);
      return P_(t), new Ve(se, e, r);
    }
    return new Ve(se, t.name, t.inputs ? t.inputs.map(Ee.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(t) {
    return t && t[Ye] === ld;
  }
}
class Ri extends Df {
  /**
   *  @private
   */
  constructor(e, r, s, _) {
    super(e, "event", r, s);
    /**
     *  Whether this event is anonymous.
     */
    $(this, "anonymous");
    Object.defineProperty(this, Ye, { value: pd }), Bt(this, { anonymous: _ });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return E_(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((s) => JSON.parse(s.format(e)))
      });
    const r = [];
    return e !== "sighash" && r.push("event"), r.push(this.name + uu(e, this.inputs)), e !== "sighash" && this.anonymous && r.push("anonymous"), r.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(e, r) {
    return r = (r || []).map((_) => Ee.from(_)), new Ri(se, e, r, !1).topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(e) {
    if (Ri.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return Ri.from(xs(e));
      } catch {
        W(!1, "invalid event fragment", "obj", e);
      }
    else if (e instanceof vr) {
      const r = Kf("event", e), s = Qi(e, !0), _ = !!Ji(e, Te(["anonymous"])).has("anonymous");
      return P_(e), new Ri(se, r, s, _);
    }
    return new Ri(se, e.name, e.inputs ? e.inputs.map((r) => Ee.from(r, !0)) : [], !!e.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(e) {
    return e && e[Ye] === pd;
  }
}
class Yi extends z_ {
  /**
   *  @private
   */
  constructor(e, r, s, _, a) {
    super(e, r, s);
    /**
     *  Whether the constructor can receive an endowment.
     */
    $(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    $(this, "gas");
    Object.defineProperty(this, Ye, { value: hd }), Bt(this, { payable: _, gas: a });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(e) {
    if (ht(e != null && e !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" }), e === "json")
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((s) => JSON.parse(s.format(e)))
      });
    const r = [`constructor${uu(e, this.inputs)}`];
    return this.payable && r.push("payable"), this.gas != null && r.push(`@${this.gas.toString()}`), r.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(e) {
    if (Yi.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return Yi.from(xs(e));
      } catch {
        W(!1, "invalid constuctor fragment", "obj", e);
      }
    else if (e instanceof vr) {
      Ji(e, Te(["constructor"]));
      const r = Qi(e), s = !!Ji(e, XE).has("payable"), _ = E2(e);
      return P_(e), new Yi(se, "constructor", r, s, _);
    }
    return new Yi(se, "constructor", e.inputs ? e.inputs.map(Ee.from) : [], !!e.payable, e.gas != null ? e.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(e) {
    return e && e[Ye] === hd;
  }
}
class Ci extends z_ {
  constructor(e, r, s) {
    super(e, "fallback", r);
    /**
     *  If the function can be sent value during invocation.
     */
    $(this, "payable");
    Object.defineProperty(this, Ye, { value: wd }), Bt(this, { payable: s });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(e) {
    const r = this.inputs.length === 0 ? "receive" : "fallback";
    if (e === "json") {
      const s = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type: r, stateMutability: s });
    }
    return `${r}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(e) {
    if (Ci.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return Ci.from(xs(e));
      } catch {
        W(!1, "invalid fallback fragment", "obj", e);
      }
    else if (e instanceof vr) {
      const r = e.toString(), s = e.peekKeyword(Te(["fallback", "receive"]));
      if (W(s, "type must be fallback or receive", "obj", r), e.popKeyword(Te(["fallback", "receive"])) === "receive") {
        const u = Qi(e);
        return W(u.length === 0, "receive cannot have arguments", "obj.inputs", u), Ji(e, Te(["payable"])), P_(e), new Ci(se, [], !0);
      }
      let a = Qi(e);
      a.length ? W(a.length === 1 && a[0].type === "bytes", "invalid fallback inputs", "obj.inputs", a.map((u) => u.format("minimal")).join(", ")) : a = [Ee.from("bytes")];
      const c = R2(e);
      if (W(c === "nonpayable" || c === "payable", "fallback cannot be constants", "obj.stateMutability", c), Ji(e, Te(["returns"])).has("returns")) {
        const u = Qi(e);
        W(u.length === 1 && u[0].type === "bytes", "invalid fallback outputs", "obj.outputs", u.map((l) => l.format("minimal")).join(", "));
      }
      return P_(e), new Ci(se, a, c === "payable");
    }
    if (e.type === "receive")
      return new Ci(se, [], !0);
    if (e.type === "fallback") {
      const r = [Ee.from("bytes")], s = e.stateMutability === "payable";
      return new Ci(se, r, s);
    }
    W(!1, "invalid fallback description", "obj", e);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(e) {
    return e && e[Ye] === wd;
  }
}
class Ei extends Df {
  /**
   *  @private
   */
  constructor(e, r, s, _, a, c) {
    super(e, "function", r, _);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    $(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    $(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    $(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    $(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    $(this, "gas");
    Object.defineProperty(this, Ye, { value: dd }), a = Object.freeze(a.slice()), Bt(this, { constant: s === "view" || s === "pure", gas: c, outputs: a, payable: s === "payable", stateMutability: s });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return E_(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((s) => JSON.parse(s.format(e))),
        outputs: this.outputs.map((s) => JSON.parse(s.format(e)))
      });
    const r = [];
    return e !== "sighash" && r.push("function"), r.push(this.name + uu(e, this.inputs)), e !== "sighash" && (this.stateMutability !== "nonpayable" && r.push(this.stateMutability), this.outputs && this.outputs.length && (r.push("returns"), r.push(uu(e, this.outputs))), this.gas != null && r.push(`@${this.gas.toString()}`)), r.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(e, r) {
    return r = (r || []).map((_) => Ee.from(_)), new Ei(se, e, "view", r, [], null).selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(e) {
    if (Ei.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return Ei.from(xs(e));
      } catch {
        W(!1, "invalid function fragment", "obj", e);
      }
    else if (e instanceof vr) {
      const s = Kf("function", e), _ = Qi(e), a = R2(e);
      let c = [];
      Ji(e, Te(["returns"])).has("returns") && (c = Qi(e));
      const u = E2(e);
      return P_(e), new Ei(se, s, a, _, c, u);
    }
    let r = e.stateMutability;
    return r == null && (r = "payable", typeof e.constant == "boolean" ? (r = "view", e.constant || (r = "payable", typeof e.payable == "boolean" && !e.payable && (r = "nonpayable"))) : typeof e.payable == "boolean" && !e.payable && (r = "nonpayable")), new Ei(se, e.name, r, e.inputs ? e.inputs.map(Ee.from) : [], e.outputs ? e.outputs.map(Ee.from) : [], e.gas != null ? e.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(e) {
    return e && e[Ye] === dd;
  }
}
class A_ extends Df {
  /**
   *  @private
   */
  constructor(t, e, r) {
    super(t, "struct", e, r), Object.defineProperty(this, Ye, { value: gd });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(t) {
    if (typeof t == "string")
      try {
        return A_.from(xs(t));
      } catch {
        W(!1, "invalid struct fragment", "obj", t);
      }
    else if (t instanceof vr) {
      const e = Kf("struct", t), r = Qi(t);
      return P_(t), new A_(se, e, r);
    }
    return new A_(se, t.name, t.inputs ? t.inputs.map(Ee.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(t) {
    return t && t[Ye] === gd;
  }
}
const Br = /* @__PURE__ */ new Map();
Br.set(0, "GENERIC_PANIC");
Br.set(1, "ASSERT_FALSE");
Br.set(17, "OVERFLOW");
Br.set(18, "DIVIDE_BY_ZERO");
Br.set(33, "ENUM_RANGE_ERROR");
Br.set(34, "BAD_STORAGE_DATA");
Br.set(49, "STACK_UNDERFLOW");
Br.set(50, "ARRAY_RANGE_ERROR");
Br.set(65, "OUT_OF_MEMORY");
Br.set(81, "UNINITIALIZED_FUNCTION_CALL");
const uP = new RegExp(/^bytes([0-9]*)$/), fP = new RegExp(/^(u?int)([0-9]*)$/);
let Bl = null, bd = 1024;
function lP(n, t, e, r) {
  let s = "missing revert data", _ = null;
  const a = null;
  let c = null;
  if (e) {
    s = "execution reverted";
    const l = Vt(e);
    if (e = Rt(e), l.length === 0)
      s += " (no data present; likely require(false) occurred", _ = "require(false)";
    else if (l.length % 32 !== 4)
      s += " (could not decode reason; invalid data length)";
    else if (Rt(l.slice(0, 4)) === "0x08c379a0")
      try {
        _ = r.decode(["string"], l.slice(4))[0], c = {
          signature: "Error(string)",
          name: "Error",
          args: [_]
        }, s += `: ${JSON.stringify(_)}`;
      } catch {
        s += " (could not decode reason; invalid string data)";
      }
    else if (Rt(l.slice(0, 4)) === "0x4e487b71")
      try {
        const f = Number(r.decode(["uint256"], l.slice(4))[0]);
        c = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [f]
        }, _ = `Panic due to ${Br.get(f) || "UNKNOWN"}(${f})`, s += `: ${_}`;
      } catch {
        s += " (could not decode panic code)";
      }
    else
      s += " (unknown custom error)";
  }
  const u = {
    to: t.to ? jt(t.to) : null,
    data: t.data || "0x"
  };
  return t.from && (u.from = jt(t.from)), oe(s, "CALL_EXCEPTION", {
    action: n,
    data: e,
    reason: _,
    transaction: u,
    invocation: a,
    revert: c
  });
}
var fs, F_;
const zf = class zf {
  constructor() {
    nt(this, fs);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(t) {
    const e = t.map((s) => At(this, fs, F_).call(this, Ee.from(s)));
    return new Ku(e, "_").defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(t, e) {
    $y(e.length, t.length, "types/values length mismatch");
    const r = t.map((a) => At(this, fs, F_).call(this, Ee.from(a))), s = new Ku(r, "_"), _ = new ih();
    return s.encode(_, e), _.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(t, e, r) {
    const s = t.map((a) => At(this, fs, F_).call(this, Ee.from(a)));
    return new Ku(s, "_").decode(new sh(e, r, bd));
  }
  static _setDefaultMaxInflation(t) {
    W(typeof t == "number" && Number.isInteger(t), "invalid defaultMaxInflation factor", "value", t), bd = t;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    return Bl == null && (Bl = new zf()), Bl;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(t, e, r) {
    return lP(t, e, r, zf.defaultAbiCoder());
  }
};
fs = new WeakSet(), F_ = function(t) {
  if (t.isArray())
    return new TR(At(this, fs, F_).call(this, t.arrayChildren), t.arrayLength, t.name);
  if (t.isTuple())
    return new Ku(t.components.map((r) => At(this, fs, F_).call(this, r)), t.name);
  switch (t.baseType) {
    case "address":
      return new OR(t.name);
    case "bool":
      return new GR(t.name);
    case "string":
      return new HR(t.name);
    case "bytes":
      return new UR(t.name);
    case "":
      return new DR(t.name);
  }
  let e = t.type.match(fP);
  if (e) {
    let r = parseInt(e[2] || "256");
    return W(r !== 0 && r <= 256 && r % 8 === 0, "invalid " + e[1] + " bit length", "param", t), new YR(r / 8, e[1] === "int", t.name);
  }
  if (e = t.type.match(uP), e) {
    let r = parseInt(e[1]);
    return W(r !== 0 && r <= 32, "invalid bytes length", "param", t), new FR(r, t.name);
  }
  W(!1, "invalid type", "type", t.type);
};
let Mc = zf;
class pP {
  /**
   *  @_ignore:
   */
  constructor(t, e, r) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    $(this, "fragment");
    /**
     *  The name of the Event.
     */
    $(this, "name");
    /**
     *  The full Event signature.
     */
    $(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    $(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    $(this, "args");
    const s = t.name, _ = t.format();
    Bt(this, {
      fragment: t,
      name: s,
      signature: _,
      topic: e,
      args: r
    });
  }
}
class hP {
  /**
   *  @_ignore:
   */
  constructor(t, e, r, s) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    $(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    $(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    $(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    $(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    $(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    $(this, "value");
    const _ = t.name, a = t.format();
    Bt(this, {
      fragment: t,
      name: _,
      args: r,
      signature: a,
      selector: e,
      value: s
    });
  }
}
class wP {
  /**
   *  @_ignore:
   */
  constructor(t, e, r) {
    /**
     *  The matching fragment.
     */
    $(this, "fragment");
    /**
     *  The name of the Error.
     */
    $(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    $(this, "args");
    /**
     *  The full Error signature.
     */
    $(this, "signature");
    /**
     *  The selector for the Error.
     */
    $(this, "selector");
    const s = t.name, _ = t.format();
    Bt(this, {
      fragment: t,
      name: s,
      args: r,
      signature: _,
      selector: e
    });
  }
}
class yd {
  /**
   *  @_ignore:
   */
  constructor(t) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    $(this, "hash");
    /**
     *  @_ignore:
     */
    $(this, "_isIndexed");
    Bt(this, { hash: t, _isIndexed: !0 });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(t) {
    return !!(t && t._isIndexed);
  }
}
const Ad = {
  0: "generic panic",
  1: "assert(false)",
  17: "arithmetic overflow",
  18: "division or modulo by zero",
  33: "enum overflow",
  34: "invalid encoded storage byte array accessed",
  49: "out-of-bounds array access; popping on an empty array",
  50: "out-of-bounds access of an array or bytesN",
  65: "out of memory",
  81: "uninitialized function"
}, md = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (n) => `reverted with reason string ${JSON.stringify(n)}`
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (n) => {
      let t = "unknown panic code";
      return n >= 0 && n <= 255 && Ad[n.toString()] && (t = Ad[n.toString()]), `reverted with panic code 0x${n.toString(16)} (${t})`;
    }
  }
};
var Kr, Dr, Lr, Pe, vi, Xu, tf;
const Ds = class Ds {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(t) {
    nt(this, vi);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    $(this, "fragments");
    /**
     *  The Contract constructor.
     */
    $(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    $(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    $(this, "receive");
    nt(this, Kr);
    nt(this, Dr);
    nt(this, Lr);
    //    #structs: Map<string, StructFragment>;
    nt(this, Pe);
    let e = [];
    typeof t == "string" ? e = JSON.parse(t) : e = t, K(this, Lr, /* @__PURE__ */ new Map()), K(this, Kr, /* @__PURE__ */ new Map()), K(this, Dr, /* @__PURE__ */ new Map());
    const r = [];
    for (const a of e)
      try {
        r.push(z_.from(a));
      } catch (c) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, c.message);
      }
    Bt(this, {
      fragments: Object.freeze(r)
    });
    let s = null, _ = !1;
    K(this, Pe, this.getAbiCoder()), this.fragments.forEach((a, c) => {
      let u;
      switch (a.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          Bt(this, { deploy: a });
          return;
        case "fallback":
          a.inputs.length === 0 ? _ = !0 : (W(!s || a.payable !== s.payable, "conflicting fallback fragments", `fragments[${c}]`, a), s = a, _ = s.payable);
          return;
        case "function":
          u = A(this, Lr);
          break;
        case "event":
          u = A(this, Dr);
          break;
        case "error":
          u = A(this, Kr);
          break;
        default:
          return;
      }
      const l = a.format();
      u.has(l) || u.set(l, a);
    }), this.deploy || Bt(this, {
      deploy: Yi.from("constructor()")
    }), Bt(this, { fallback: s, receive: _ });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(t) {
    const e = t ? "minimal" : "full";
    return this.fragments.map((s) => s.format(e));
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const t = this.fragments.map((e) => e.format("json"));
    return JSON.stringify(t.map((e) => JSON.parse(e)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return Mc.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(t) {
    const e = At(this, vi, Xu).call(this, t, null, !1);
    return W(e, "no matching function", "key", t), e.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(t) {
    return !!At(this, vi, Xu).call(this, t, null, !1);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(t, e) {
    return At(this, vi, Xu).call(this, t, e || null, !0);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(t) {
    const e = Array.from(A(this, Lr).keys());
    e.sort((r, s) => r.localeCompare(s));
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      t(A(this, Lr).get(s), r);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(t) {
    const e = At(this, vi, tf).call(this, t, null, !1);
    return W(e, "no matching event", "key", t), e.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(t) {
    return !!At(this, vi, tf).call(this, t, null, !1);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(t, e) {
    return At(this, vi, tf).call(this, t, e || null, !0);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(t) {
    const e = Array.from(A(this, Dr).keys());
    e.sort((r, s) => r.localeCompare(s));
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      t(A(this, Dr).get(s), r);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(t, e) {
    if (ee(t)) {
      const s = t.toLowerCase();
      if (md[s])
        return Ve.from(md[s].signature);
      for (const _ of A(this, Kr).values())
        if (s === _.selector)
          return _;
      return null;
    }
    if (t.indexOf("(") === -1) {
      const s = [];
      for (const [_, a] of A(this, Kr))
        _.split(
          "("
          /* fix:) */
        )[0] === t && s.push(a);
      if (s.length === 0)
        return t === "Error" ? Ve.from("error Error(string)") : t === "Panic" ? Ve.from("error Panic(uint256)") : null;
      if (s.length > 1) {
        const _ = s.map((a) => JSON.stringify(a.format())).join(", ");
        W(!1, `ambiguous error description (i.e. ${_})`, "name", t);
      }
      return s[0];
    }
    if (t = Ve.from(t).format(), t === "Error(string)")
      return Ve.from("error Error(string)");
    if (t === "Panic(uint256)")
      return Ve.from("error Panic(uint256)");
    const r = A(this, Kr).get(t);
    return r || null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(t) {
    const e = Array.from(A(this, Kr).keys());
    e.sort((r, s) => r.localeCompare(s));
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      t(A(this, Kr).get(s), r);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(t, e) {
    return A(this, Pe).decode(t, e);
  }
  _encodeParams(t, e) {
    return A(this, Pe).encode(t, e);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(t) {
    return this._encodeParams(this.deploy.inputs, t || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(t, e) {
    if (typeof t == "string") {
      const r = this.getError(t);
      W(r, "unknown error", "fragment", t), t = r;
    }
    return W(ae(e, 0, 4) === t.selector, `data signature does not match error ${t.name}.`, "data", e), this._decodeParams(t.inputs, ae(e, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(t, e) {
    if (typeof t == "string") {
      const r = this.getError(t);
      W(r, "unknown error", "fragment", t), t = r;
    }
    return pe([
      t.selector,
      this._encodeParams(t.inputs, e || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(t, e) {
    if (typeof t == "string") {
      const r = this.getFunction(t);
      W(r, "unknown function", "fragment", t), t = r;
    }
    return W(ae(e, 0, 4) === t.selector, `data signature does not match function ${t.name}.`, "data", e), this._decodeParams(t.inputs, ae(e, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(t, e) {
    if (typeof t == "string") {
      const r = this.getFunction(t);
      W(r, "unknown function", "fragment", t), t = r;
    }
    return pe([
      t.selector,
      this._encodeParams(t.inputs, e || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(t, e) {
    if (typeof t == "string") {
      const _ = this.getFunction(t);
      W(_, "unknown function", "fragment", t), t = _;
    }
    let r = "invalid length for result data";
    const s = Ie(e);
    if (s.length % 32 === 0)
      try {
        return A(this, Pe).decode(t.outputs, s);
      } catch {
        r = "could not decode result data";
      }
    ht(!1, r, "BAD_DATA", {
      value: Rt(s),
      info: { method: t.name, signature: t.format() }
    });
  }
  makeError(t, e) {
    const r = Vt(t, "data"), s = Mc.getBuiltinCallException("call", e, r);
    if (s.message.startsWith("execution reverted (unknown custom error)")) {
      const c = Rt(r.slice(0, 4)), u = this.getError(c);
      if (u)
        try {
          const l = A(this, Pe).decode(u.inputs, r.slice(4));
          s.revert = {
            name: u.name,
            signature: u.format(),
            args: l
          }, s.reason = s.revert.signature, s.message = `execution reverted: ${s.reason}`;
        } catch {
          s.message = "execution reverted (coult not decode custom error)";
        }
    }
    const a = this.parseTransaction(e);
    return a && (s.invocation = {
      method: a.name,
      signature: a.signature,
      args: a.args
    }), s;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(t, e) {
    if (typeof t == "string") {
      const r = this.getFunction(t);
      W(r, "unknown function", "fragment", t), t = r;
    }
    return Rt(A(this, Pe).encode(t.outputs, e || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(t, e) {
    if (typeof t == "string") {
      const _ = this.getEvent(t);
      W(_, "unknown event", "eventFragment", t), t = _;
    }
    ht(e.length <= t.inputs.length, `too many arguments for ${t.format()}`, "UNEXPECTED_ARGUMENT", { count: e.length, expectedCount: t.inputs.length });
    const r = [];
    t.anonymous || r.push(t.topicHash);
    const s = (_, a) => _.type === "string" ? E_(a) : _.type === "bytes" ? de(Rt(a)) : (_.type === "bool" && typeof a == "boolean" ? a = a ? "0x01" : "0x00" : _.type.match(/^u?int/) ? a = zs(a) : _.type.match(/^bytes/) ? a = Dm(a, 32) : _.type === "address" && A(this, Pe).encode(["address"], [a]), S_(Rt(a), 32));
    for (e.forEach((_, a) => {
      const c = t.inputs[a];
      if (!c.indexed) {
        W(_ == null, "cannot filter non-indexed parameters; must be null", "contract." + c.name, _);
        return;
      }
      _ == null ? r.push(null) : c.baseType === "array" || c.baseType === "tuple" ? W(!1, "filtering with tuples or arrays not supported", "contract." + c.name, _) : Array.isArray(_) ? r.push(_.map((u) => s(c, u))) : r.push(s(c, _));
    }); r.length && r[r.length - 1] === null; )
      r.pop();
    return r;
  }
  encodeEventLog(t, e) {
    if (typeof t == "string") {
      const a = this.getEvent(t);
      W(a, "unknown event", "eventFragment", t), t = a;
    }
    const r = [], s = [], _ = [];
    return t.anonymous || r.push(t.topicHash), W(e.length === t.inputs.length, "event arguments/values mismatch", "values", e), t.inputs.forEach((a, c) => {
      const u = e[c];
      if (a.indexed)
        if (a.type === "string")
          r.push(E_(u));
        else if (a.type === "bytes")
          r.push(de(u));
        else {
          if (a.baseType === "tuple" || a.baseType === "array")
            throw new Error("not implemented");
          r.push(A(this, Pe).encode([a.type], [u]));
        }
      else
        s.push(a), _.push(u);
    }), {
      data: A(this, Pe).encode(s, _),
      topics: r
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(t, e, r) {
    if (typeof t == "string") {
      const v = this.getEvent(t);
      W(v, "unknown event", "eventFragment", t), t = v;
    }
    if (r != null && !t.anonymous) {
      const v = t.topicHash;
      W(ee(r[0], 32) && r[0].toLowerCase() === v, "fragment/topic mismatch", "topics[0]", r[0]), r = r.slice(1);
    }
    const s = [], _ = [], a = [];
    t.inputs.forEach((v, x) => {
      v.indexed ? v.type === "string" || v.type === "bytes" || v.baseType === "tuple" || v.baseType === "array" ? (s.push(Ee.from({ type: "bytes32", name: v.name })), a.push(!0)) : (s.push(v), a.push(!1)) : (_.push(v), a.push(!1));
    });
    const c = r != null ? A(this, Pe).decode(s, pe(r)) : null, u = A(this, Pe).decode(_, e, !0), l = [], f = [];
    let w = 0, y = 0;
    return t.inputs.forEach((v, x) => {
      let C = null;
      if (v.indexed)
        if (c == null)
          C = new yd(null);
        else if (a[x])
          C = new yd(c[y++]);
        else
          try {
            C = c[y++];
          } catch (U) {
            C = U;
          }
      else
        try {
          C = u[w++];
        } catch (U) {
          C = U;
        }
      l.push(C), f.push(v.name || null);
    }), mc.fromItems(l, f);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(t) {
    const e = Vt(t.data, "tx.data"), r = zt(t.value != null ? t.value : 0, "tx.value"), s = this.getFunction(Rt(e.slice(0, 4)));
    if (!s)
      return null;
    const _ = A(this, Pe).decode(s.inputs, e.slice(4));
    return new hP(s, s.selector, _, r);
  }
  parseCallResult(t) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(t) {
    const e = this.getEvent(t.topics[0]);
    return !e || e.anonymous ? null : new pP(e, e.topicHash, this.decodeEventLog(e, t.data, t.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(t) {
    const e = Rt(t), r = this.getError(ae(e, 0, 4));
    if (!r)
      return null;
    const s = A(this, Pe).decode(r.inputs, ae(e, 4));
    return new wP(r, r.selector, s);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(t) {
    return t instanceof Ds ? t : typeof t == "string" ? new Ds(JSON.parse(t)) : typeof t.formatJson == "function" ? new Ds(t.formatJson()) : typeof t.format == "function" ? new Ds(t.format("json")) : new Ds(t);
  }
};
Kr = new WeakMap(), Dr = new WeakMap(), Lr = new WeakMap(), Pe = new WeakMap(), vi = new WeakSet(), // Find a function definition by any means necessary (unless it is ambiguous)
Xu = function(t, e, r) {
  if (ee(t)) {
    const _ = t.toLowerCase();
    for (const a of A(this, Lr).values())
      if (_ === a.selector)
        return a;
    return null;
  }
  if (t.indexOf("(") === -1) {
    const _ = [];
    for (const [a, c] of A(this, Lr))
      a.split(
        "("
        /* fix:) */
      )[0] === t && _.push(c);
    if (e) {
      const a = e.length > 0 ? e[e.length - 1] : null;
      let c = e.length, u = !0;
      Me.isTyped(a) && a.type === "overrides" && (u = !1, c--);
      for (let l = _.length - 1; l >= 0; l--) {
        const f = _[l].inputs.length;
        f !== c && (!u || f !== c - 1) && _.splice(l, 1);
      }
      for (let l = _.length - 1; l >= 0; l--) {
        const f = _[l].inputs;
        for (let w = 0; w < e.length; w++)
          if (Me.isTyped(e[w])) {
            if (w >= f.length) {
              if (e[w].type === "overrides")
                continue;
              _.splice(l, 1);
              break;
            }
            if (e[w].type !== f[w].baseType) {
              _.splice(l, 1);
              break;
            }
          }
      }
    }
    if (_.length === 1 && e && e.length !== _[0].inputs.length) {
      const a = e[e.length - 1];
      (a == null || Array.isArray(a) || typeof a != "object") && _.splice(0, 1);
    }
    if (_.length === 0)
      return null;
    if (_.length > 1 && r) {
      const a = _.map((c) => JSON.stringify(c.format())).join(", ");
      W(!1, `ambiguous function description (i.e. matches ${a})`, "key", t);
    }
    return _[0];
  }
  const s = A(this, Lr).get(Ei.from(t).format());
  return s || null;
}, // Find an event definition by any means necessary (unless it is ambiguous)
tf = function(t, e, r) {
  if (ee(t)) {
    const _ = t.toLowerCase();
    for (const a of A(this, Dr).values())
      if (_ === a.topicHash)
        return a;
    return null;
  }
  if (t.indexOf("(") === -1) {
    const _ = [];
    for (const [a, c] of A(this, Dr))
      a.split(
        "("
        /* fix:) */
      )[0] === t && _.push(c);
    if (e) {
      for (let a = _.length - 1; a >= 0; a--)
        _[a].inputs.length < e.length && _.splice(a, 1);
      for (let a = _.length - 1; a >= 0; a--) {
        const c = _[a].inputs;
        for (let u = 0; u < e.length; u++)
          if (Me.isTyped(e[u]) && e[u].type !== c[u].baseType) {
            _.splice(a, 1);
            break;
          }
      }
    }
    if (_.length === 0)
      return null;
    if (_.length > 1 && r) {
      const a = _.map((c) => JSON.stringify(c.format())).join(", ");
      W(!1, `ambiguous event description (i.e. matches ${a})`, "key", t);
    }
    return _[0];
  }
  const s = A(this, Dr).get(Ri.from(t).format());
  return s || null;
};
let yh = Ds;
const P2 = BigInt(0);
function va(n) {
  return n ?? null;
}
function ue(n) {
  return n == null ? null : n.toString();
}
class Sd {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(t, e, r) {
    /**
     *  The gas price for legacy networks.
     */
    $(this, "gasPrice");
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    $(this, "maxFeePerGas");
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    $(this, "maxPriorityFeePerGas");
    Bt(this, {
      gasPrice: va(t),
      maxFeePerGas: va(e),
      maxPriorityFeePerGas: va(r)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice: t, maxFeePerGas: e, maxPriorityFeePerGas: r } = this;
    return {
      _type: "FeeData",
      gasPrice: ue(t),
      maxFeePerGas: ue(e),
      maxPriorityFeePerGas: ue(r)
    };
  }
}
function bf(n) {
  const t = {};
  n.to && (t.to = n.to), n.from && (t.from = n.from), n.data && (t.data = Rt(n.data));
  const e = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const s of e)
    !(s in n) || n[s] == null || (t[s] = zt(n[s], `request.${s}`));
  const r = "type,nonce".split(/,/);
  for (const s of r)
    !(s in n) || n[s] == null || (t[s] = Ft(n[s], `request.${s}`));
  return n.accessList && (t.accessList = C_(n.accessList)), "blockTag" in n && (t.blockTag = n.blockTag), "enableCcipRead" in n && (t.enableCcipRead = !!n.enableCcipRead), "customData" in n && (t.customData = n.customData), "blobVersionedHashes" in n && n.blobVersionedHashes && (t.blobVersionedHashes = n.blobVersionedHashes.slice()), "kzg" in n && (t.kzg = n.kzg), "blobs" in n && n.blobs && (t.blobs = n.blobs.map((s) => Kh(s) ? Rt(s) : Object.assign({}, s))), t;
}
var Ui;
class dP {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(t, e) {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    $(this, "provider");
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    $(this, "number");
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    $(this, "hash");
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    $(this, "timestamp");
    /**
     *  The block hash of the parent block.
     */
    $(this, "parentHash");
    /**
     *  The hash tree root of the parent beacon block for the given
     *  execution block. See [[link-eip-4788]].
     */
    $(this, "parentBeaconBlockRoot");
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    $(this, "nonce");
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    $(this, "difficulty");
    /**
     *  The total gas limit for this block.
     */
    $(this, "gasLimit");
    /**
     *  The total gas used in this block.
     */
    $(this, "gasUsed");
    /**
     *  The root hash for the global state after applying changes
     *  in this block.
     */
    $(this, "stateRoot");
    /**
     *  The hash of the transaction receipts trie.
     */
    $(this, "receiptsRoot");
    /**
     *  The total amount of blob gas consumed by the transactions
     *  within the block. See [[link-eip-4844]].
     */
    $(this, "blobGasUsed");
    /**
     *  The running total of blob gas consumed in excess of the
     *  target, prior to the block. See [[link-eip-4844]].
     */
    $(this, "excessBlobGas");
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    $(this, "miner");
    /**
     *  The latest RANDAO mix of the post beacon state of
     *  the previous block.
     */
    $(this, "prevRandao");
    /**
     *  Any extra data the validator wished to include.
     */
    $(this, "extraData");
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    $(this, "baseFeePerGas");
    nt(this, Ui);
    K(this, Ui, t.transactions.map((r) => typeof r != "string" ? new fu(r, e) : r)), Bt(this, {
      provider: e,
      hash: va(t.hash),
      number: t.number,
      timestamp: t.timestamp,
      parentHash: t.parentHash,
      parentBeaconBlockRoot: t.parentBeaconBlockRoot,
      nonce: t.nonce,
      difficulty: t.difficulty,
      gasLimit: t.gasLimit,
      gasUsed: t.gasUsed,
      blobGasUsed: t.blobGasUsed,
      excessBlobGas: t.excessBlobGas,
      miner: t.miner,
      prevRandao: va(t.prevRandao),
      extraData: t.extraData,
      baseFeePerGas: va(t.baseFeePerGas),
      stateRoot: t.stateRoot,
      receiptsRoot: t.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return A(this, Ui).map((t) => typeof t == "string" ? t : t.hash);
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const t = A(this, Ui).slice();
    return t.length === 0 ? [] : (ht(typeof t[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    }), t);
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas: t, difficulty: e, extraData: r, gasLimit: s, gasUsed: _, hash: a, miner: c, prevRandao: u, nonce: l, number: f, parentHash: w, parentBeaconBlockRoot: y, stateRoot: v, receiptsRoot: x, timestamp: C, transactions: U } = this;
    return {
      _type: "Block",
      baseFeePerGas: ue(t),
      difficulty: ue(e),
      extraData: r,
      gasLimit: ue(s),
      gasUsed: ue(_),
      blobGasUsed: ue(this.blobGasUsed),
      excessBlobGas: ue(this.excessBlobGas),
      hash: a,
      miner: c,
      prevRandao: u,
      nonce: l,
      number: f,
      parentHash: w,
      timestamp: C,
      parentBeaconBlockRoot: y,
      stateRoot: v,
      receiptsRoot: x,
      transactions: U
    };
  }
  [Symbol.iterator]() {
    let t = 0;
    const e = this.transactions;
    return {
      next: () => t < this.length ? {
        value: e[t++],
        done: !1
      } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return A(this, Ui).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    return this.timestamp == null ? null : new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(t) {
    let e;
    if (typeof t == "number")
      e = A(this, Ui)[t];
    else {
      const r = t.toLowerCase();
      for (const s of A(this, Ui))
        if (typeof s == "string") {
          if (s !== r)
            continue;
          e = s;
          break;
        } else {
          if (s.hash === r)
            continue;
          e = s;
          break;
        }
    }
    if (e == null)
      throw new Error("no such tx");
    return typeof e == "string" ? await this.provider.getTransaction(e) : e;
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(t) {
    const e = this.prefetchedTransactions;
    if (typeof t == "number")
      return e[t];
    t = t.toLowerCase();
    for (const r of e)
      if (r.hash === t)
        return r;
    W(!1, "no matching transaction", "indexOrHash", t);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined())
      throw new Error("");
    return gP(this);
  }
}
Ui = new WeakMap();
class xu {
  /**
   *  @_ignore:
   */
  constructor(t, e) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    $(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    $(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    $(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    $(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    $(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    $(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    $(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    $(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    $(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    $(this, "transactionIndex");
    this.provider = e;
    const r = Object.freeze(t.topics.slice());
    Bt(this, {
      transactionHash: t.transactionHash,
      blockHash: t.blockHash,
      blockNumber: t.blockNumber,
      removed: t.removed,
      address: t.address,
      data: t.data,
      topics: r,
      index: t.index,
      transactionIndex: t.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address: t, blockHash: e, blockNumber: r, data: s, index: _, removed: a, topics: c, transactionHash: u, transactionIndex: l } = this;
    return {
      _type: "log",
      address: t,
      blockHash: e,
      blockNumber: r,
      data: s,
      index: _,
      removed: a,
      topics: c,
      transactionHash: u,
      transactionIndex: l
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const t = await this.provider.getBlock(this.blockHash);
    return ht(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const t = await this.provider.getTransaction(this.transactionHash);
    return ht(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const t = await this.provider.getTransactionReceipt(this.transactionHash);
    return ht(!!t, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), t;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return bP(this);
  }
}
var Au;
class z2 {
  /**
   *  @_ignore:
   */
  constructor(t, e) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    $(this, "provider");
    /**
     *  The address the transaction was sent to.
     */
    $(this, "to");
    /**
     *  The sender of the transaction.
     */
    $(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    $(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    $(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    $(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    $(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    $(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    $(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    $(this, "gasUsed");
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    $(this, "blobGasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    $(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    $(this, "gasPrice");
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    $(this, "blobGasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    $(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    $(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    $(this, "root");
    nt(this, Au);
    K(this, Au, Object.freeze(t.logs.map((s) => new xu(s, e))));
    let r = P2;
    t.effectiveGasPrice != null ? r = t.effectiveGasPrice : t.gasPrice != null && (r = t.gasPrice), Bt(this, {
      provider: e,
      to: t.to,
      from: t.from,
      contractAddress: t.contractAddress,
      hash: t.hash,
      index: t.index,
      blockHash: t.blockHash,
      blockNumber: t.blockNumber,
      logsBloom: t.logsBloom,
      gasUsed: t.gasUsed,
      cumulativeGasUsed: t.cumulativeGasUsed,
      blobGasUsed: t.blobGasUsed,
      gasPrice: r,
      blobGasPrice: t.blobGasPrice,
      type: t.type,
      //byzantium: tx.byzantium,
      status: t.status,
      root: t.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return A(this, Au);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to: t,
      from: e,
      contractAddress: r,
      hash: s,
      index: _,
      blockHash: a,
      blockNumber: c,
      logsBloom: u,
      logs: l,
      //byzantium, 
      status: f,
      root: w
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash: a,
      blockNumber: c,
      //byzantium, 
      contractAddress: r,
      cumulativeGasUsed: ue(this.cumulativeGasUsed),
      from: e,
      gasPrice: ue(this.gasPrice),
      blobGasUsed: ue(this.blobGasUsed),
      blobGasPrice: ue(this.blobGasPrice),
      gasUsed: ue(this.gasUsed),
      hash: s,
      index: _,
      logs: l,
      logsBloom: u,
      root: w,
      status: f,
      to: t
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let t = 0;
    return {
      next: () => t < this.length ? { value: this.logs[t++], done: !1 } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const t = await this.provider.getBlock(this.blockHash);
    if (t == null)
      throw new Error("TODO");
    return t;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const t = await this.provider.getTransaction(this.hash);
    if (t == null)
      throw new Error("TODO");
    return t;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return M2(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(t) {
    return ht(!t || t.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" }), v2(this, t);
  }
}
Au = new WeakMap();
var ls;
const Aw = class Aw {
  /**
   *  @_ignore:
   */
  constructor(t, e) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    $(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    $(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    $(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    $(this, "index");
    /**
     *  The transaction hash.
     */
    $(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    $(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    $(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    $(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    $(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    $(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    $(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    $(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    $(this, "maxFeePerGas");
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    $(this, "maxFeePerBlobGas");
    /**
     *  The data.
     */
    $(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    $(this, "value");
    /**
     *  The chain ID.
     */
    $(this, "chainId");
    /**
     *  The signature.
     */
    $(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    $(this, "accessList");
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    $(this, "blobVersionedHashes");
    nt(this, ls);
    this.provider = e, this.blockNumber = t.blockNumber != null ? t.blockNumber : null, this.blockHash = t.blockHash != null ? t.blockHash : null, this.hash = t.hash, this.index = t.index, this.type = t.type, this.from = t.from, this.to = t.to || null, this.gasLimit = t.gasLimit, this.nonce = t.nonce, this.data = t.data, this.value = t.value, this.gasPrice = t.gasPrice, this.maxPriorityFeePerGas = t.maxPriorityFeePerGas != null ? t.maxPriorityFeePerGas : null, this.maxFeePerGas = t.maxFeePerGas != null ? t.maxFeePerGas : null, this.maxFeePerBlobGas = t.maxFeePerBlobGas != null ? t.maxFeePerBlobGas : null, this.chainId = t.chainId, this.signature = t.signature, this.accessList = t.accessList != null ? t.accessList : null, this.blobVersionedHashes = t.blobVersionedHashes != null ? t.blobVersionedHashes : null, K(this, ls, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber: t, blockHash: e, index: r, hash: s, type: _, to: a, from: c, nonce: u, data: l, signature: f, accessList: w, blobVersionedHashes: y } = this;
    return {
      _type: "TransactionResponse",
      accessList: w,
      blockNumber: t,
      blockHash: e,
      blobVersionedHashes: y,
      chainId: ue(this.chainId),
      data: l,
      from: c,
      gasLimit: ue(this.gasLimit),
      gasPrice: ue(this.gasPrice),
      hash: s,
      maxFeePerGas: ue(this.maxFeePerGas),
      maxPriorityFeePerGas: ue(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: ue(this.maxFeePerBlobGas),
      nonce: u,
      signature: f,
      to: a,
      index: r,
      type: _,
      value: ue(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let t = this.blockNumber;
    if (t == null) {
      const r = await this.getTransaction();
      r && (t = r.blockNumber);
    }
    if (t == null)
      return null;
    const e = this.provider.getBlock(t);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx: e, blockNumber: r } = await Ce({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      return e == null || e.blockNumber == null ? 0 : r - e.blockNumber + 1;
    }
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(t, e) {
    const r = t ?? 1, s = e ?? 0;
    let _ = A(this, ls), a = -1, c = _ === -1;
    const u = async () => {
      if (c)
        return null;
      const { blockNumber: y, nonce: v } = await Ce({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (v < this.nonce) {
        _ = y;
        return;
      }
      if (c)
        return null;
      const x = await this.getTransaction();
      if (!(x && x.blockNumber != null))
        for (a === -1 && (a = _ - 3, a < A(this, ls) && (a = A(this, ls))); a <= y; ) {
          if (c)
            return null;
          const C = await this.provider.getBlock(a, !0);
          if (C == null)
            return;
          for (const U of C)
            if (U === this.hash)
              return;
          for (let U = 0; U < C.length; U++) {
            const z = await C.getTransaction(U);
            if (z.from === this.from && z.nonce === this.nonce) {
              if (c)
                return null;
              const M = await this.provider.getTransactionReceipt(z.hash);
              if (M == null || y - M.blockNumber + 1 < r)
                return;
              let N = "replaced";
              z.data === this.data && z.to === this.to && z.value === this.value ? N = "repriced" : z.data === "0x" && z.from === z.to && z.value === P2 && (N = "cancelled"), ht(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                cancelled: N === "replaced" || N === "cancelled",
                reason: N,
                replacement: z.replaceableTransaction(_),
                hash: z.hash,
                receipt: M
              });
            }
          }
          a++;
        }
    }, l = (y) => {
      if (y == null || y.status !== 0)
        return y;
      ht(!1, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: y.to,
          from: y.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: y
      });
    }, f = await this.provider.getTransactionReceipt(this.hash);
    if (r === 0)
      return l(f);
    if (f) {
      if (await f.confirmations() >= r)
        return l(f);
    } else if (await u(), r === 0)
      return null;
    return await new Promise((y, v) => {
      const x = [], C = () => {
        x.forEach((z) => z());
      };
      if (x.push(() => {
        c = !0;
      }), s > 0) {
        const z = setTimeout(() => {
          C(), v(oe("wait for transaction timeout", "TIMEOUT"));
        }, s);
        x.push(() => {
          clearTimeout(z);
        });
      }
      const U = async (z) => {
        if (await z.confirmations() >= r) {
          C();
          try {
            y(l(z));
          } catch (M) {
            v(M);
          }
        }
      };
      if (x.push(() => {
        this.provider.off(this.hash, U);
      }), this.provider.on(this.hash, U), _ >= 0) {
        const z = async () => {
          try {
            await u();
          } catch (M) {
            if (Re(M, "TRANSACTION_REPLACED")) {
              C(), v(M);
              return;
            }
          }
          c || this.provider.once("block", z);
        };
        x.push(() => {
          this.provider.off("block", z);
        }), this.provider.once("block", z);
      }
    });
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    return ht(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), M2(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(t) {
    return ht(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), ht(!t || t.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), v2(this, t);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(t) {
    W(Number.isInteger(t) && t >= 0, "invalid startBlock", "startBlock", t);
    const e = new Aw(this, this.provider);
    return K(e, ls, t), e;
  }
};
ls = new WeakMap();
let fu = Aw;
function gP(n) {
  return { orphan: "drop-block", hash: n.hash, number: n.number };
}
function v2(n, t) {
  return { orphan: "reorder-transaction", tx: n, other: t };
}
function M2(n) {
  return { orphan: "drop-transaction", tx: n };
}
function bP(n) {
  return { orphan: "drop-log", log: {
    transactionHash: n.transactionHash,
    blockHash: n.blockHash,
    blockNumber: n.blockNumber,
    address: n.address,
    data: n.data,
    topics: Object.freeze(n.topics.slice()),
    index: n.index
  } };
}
class nw extends xu {
  /**
   * @_ignore:
   */
  constructor(e, r, s) {
    super(e, e.provider);
    /**
     *  The Contract Interface.
     */
    $(this, "interface");
    /**
     *  The matching event.
     */
    $(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    $(this, "args");
    const _ = r.decodeEventLog(s, e.data, e.topics);
    Bt(this, { args: _, fragment: s, interface: r });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class x2 extends xu {
  /**
   * @_ignore:
   */
  constructor(e, r) {
    super(e, e.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    $(this, "error");
    Bt(this, { error: r });
  }
}
var sc;
class yP extends z2 {
  /**
   *  @_ignore:
   */
  constructor(e, r, s) {
    super(s, r);
    nt(this, sc);
    K(this, sc, e);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((e) => {
      const r = e.topics.length ? A(this, sc).getEvent(e.topics[0]) : null;
      if (r)
        try {
          return new nw(e, A(this, sc), r);
        } catch (s) {
          return new x2(e, s);
        }
      return e;
    });
  }
}
sc = new WeakMap();
var mu;
class iw extends fu {
  /**
   *  @_ignore:
   */
  constructor(e, r, s) {
    super(s, r);
    nt(this, mu);
    K(this, mu, e);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(e, r) {
    const s = await super.wait(e, r);
    return s == null ? null : new yP(A(this, mu), this.provider, s);
  }
}
mu = new WeakMap();
class B2 extends eA {
  /**
   *  @_event:
   */
  constructor(e, r, s, _) {
    super(e, r, s);
    /**
     *  The log with no matching events.
     */
    $(this, "log");
    Bt(this, { log: _ });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class AP extends B2 {
  /**
   *  @_ignore:
   */
  constructor(t, e, r, s, _) {
    super(t, e, r, new nw(_, t.interface, s));
    const a = t.interface.decodeEventLog(s, this.log.data, this.log.topics);
    Bt(this, { args: a, fragment: s });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const Rd = BigInt(0);
function C2(n) {
  return n && typeof n.call == "function";
}
function I2(n) {
  return n && typeof n.estimateGas == "function";
}
function Lf(n) {
  return n && typeof n.resolveName == "function";
}
function N2(n) {
  return n && typeof n.sendTransaction == "function";
}
function O2(n) {
  if (n != null) {
    if (Lf(n))
      return n;
    if (n.provider)
      return n.provider;
  }
}
var Su;
class mP {
  constructor(t, e, r) {
    nt(this, Su);
    $(this, "fragment");
    if (Bt(this, { fragment: e }), e.inputs.length < r.length)
      throw new Error("too many arguments");
    const s = v_(t.runner, "resolveName"), _ = Lf(s) ? s : null;
    K(this, Su, async function() {
      const a = await Promise.all(e.inputs.map((c, u) => r[u] == null ? null : c.walkAsync(r[u], (f, w) => f === "address" ? Array.isArray(w) ? Promise.all(w.map((y) => ke(y, _))) : ke(w, _) : w)));
      return t.interface.encodeFilterTopics(e, a);
    }());
  }
  getTopicFilter() {
    return A(this, Su);
  }
}
Su = new WeakMap();
function v_(n, t) {
  return n == null ? null : typeof n[t] == "function" ? n : n.provider && typeof n.provider[t] == "function" ? n.provider : null;
}
function Vs(n) {
  return n == null ? null : n.provider || null;
}
async function k2(n, t) {
  const e = Me.dereference(n, "overrides");
  W(typeof e == "object", "invalid overrides parameter", "overrides", n);
  const r = bf(e);
  return W(r.to == null || (t || []).indexOf("to") >= 0, "cannot override to", "overrides.to", r.to), W(r.data == null || (t || []).indexOf("data") >= 0, "cannot override data", "overrides.data", r.data), r.from && (r.from = r.from), r;
}
async function SP(n, t, e) {
  const r = v_(n, "resolveName"), s = Lf(r) ? r : null;
  return await Promise.all(t.map((_, a) => _.walkAsync(e[a], (c, u) => (u = Me.dereference(u, c), c === "address" ? ke(u, s) : u))));
}
function RP(n) {
  const t = async function(a) {
    const c = await k2(a, ["data"]);
    c.to = await n.getAddress(), c.from && (c.from = await ke(c.from, O2(n.runner)));
    const u = n.interface, l = zt(c.value || Rd, "overrides.value") === Rd, f = (c.data || "0x") === "0x";
    u.fallback && !u.fallback.payable && u.receive && !f && !l && W(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", a), W(u.fallback || f, "cannot send data to receive-only contract", "overrides.data", c.data);
    const w = u.receive || u.fallback && u.fallback.payable;
    return W(w || l, "cannot send value to non-payable fallback", "overrides.value", c.value), W(u.fallback || f, "cannot send data to receive-only contract", "overrides.data", c.data), c;
  }, e = async function(a) {
    const c = v_(n.runner, "call");
    ht(C2(c), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const u = await t(a);
    try {
      return await c.call(u);
    } catch (l) {
      throw Fh(l) && l.data ? n.interface.makeError(l.data, u) : l;
    }
  }, r = async function(a) {
    const c = n.runner;
    ht(N2(c), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const u = await c.sendTransaction(await t(a)), l = Vs(n.runner);
    return new iw(n.interface, l, u);
  }, s = async function(a) {
    const c = v_(n.runner, "estimateGas");
    return ht(I2(c), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await c.estimateGas(await t(a));
  }, _ = async (a) => await r(a);
  return Bt(_, {
    _contract: n,
    estimateGas: s,
    populateTransaction: t,
    send: r,
    staticCall: e
  }), _;
}
function EP(n, t) {
  const e = function(...l) {
    const f = n.interface.getFunction(t, l);
    return ht(f, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: t, args: l }
    }), f;
  }, r = async function(...l) {
    const f = e(...l);
    let w = {};
    if (f.inputs.length + 1 === l.length && (w = await k2(l.pop()), w.from && (w.from = await ke(w.from, O2(n.runner)))), f.inputs.length !== l.length)
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    const y = await SP(n.runner, f.inputs, l);
    return Object.assign({}, w, await Ce({
      to: n.getAddress(),
      data: n.interface.encodeFunctionData(f, y)
    }));
  }, s = async function(...l) {
    const f = await c(...l);
    return f.length === 1 ? f[0] : f;
  }, _ = async function(...l) {
    const f = n.runner;
    ht(N2(f), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const w = await f.sendTransaction(await r(...l)), y = Vs(n.runner);
    return new iw(n.interface, y, w);
  }, a = async function(...l) {
    const f = v_(n.runner, "estimateGas");
    return ht(I2(f), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await f.estimateGas(await r(...l));
  }, c = async function(...l) {
    const f = v_(n.runner, "call");
    ht(C2(f), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const w = await r(...l);
    let y = "0x";
    try {
      y = await f.call(w);
    } catch (x) {
      throw Fh(x) && x.data ? n.interface.makeError(x.data, w) : x;
    }
    const v = e(...l);
    return n.interface.decodeFunctionResult(v, y);
  }, u = async (...l) => e(...l).constant ? await s(...l) : await _(...l);
  return Bt(u, {
    name: n.interface.getFunctionName(t),
    _contract: n,
    _key: t,
    getFragment: e,
    estimateGas: a,
    populateTransaction: r,
    send: _,
    staticCall: s,
    staticCallResult: c
  }), Object.defineProperty(u, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const l = n.interface.getFunction(t);
      return ht(l, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: t }
      }), l;
    }
  }), u;
}
function PP(n, t) {
  const e = function(...s) {
    const _ = n.interface.getEvent(t, s);
    return ht(_, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: t, args: s }
    }), _;
  }, r = function(...s) {
    return new mP(n, e(...s), s);
  };
  return Bt(r, {
    name: n.interface.getEventName(t),
    _contract: n,
    _key: t,
    getFragment: e
  }), Object.defineProperty(r, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const s = n.interface.getEvent(t);
      return ht(s, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: t }
      }), s;
    }
  }), r;
}
const yf = Symbol.for("_ethersInternal_contract"), T2 = /* @__PURE__ */ new WeakMap();
function zP(n, t) {
  T2.set(n[yf], t);
}
function qe(n) {
  return T2.get(n[yf]);
}
function vP(n) {
  return n && typeof n == "object" && "getTopicFilter" in n && typeof n.getTopicFilter == "function" && n.fragment;
}
async function sw(n, t) {
  let e, r = null;
  if (Array.isArray(t)) {
    const _ = function(a) {
      if (ee(a, 32))
        return a;
      const c = n.interface.getEvent(a);
      return W(c, "unknown fragment", "name", a), c.topicHash;
    };
    e = t.map((a) => a == null ? null : Array.isArray(a) ? a.map(_) : _(a));
  } else t === "*" ? e = [null] : typeof t == "string" ? ee(t, 32) ? e = [t] : (r = n.interface.getEvent(t), W(r, "unknown fragment", "event", t), e = [r.topicHash]) : vP(t) ? e = await t.getTopicFilter() : "fragment" in t ? (r = t.fragment, e = [r.topicHash]) : W(!1, "unknown event name", "event", t);
  e = e.map((_) => {
    if (_ == null)
      return null;
    if (Array.isArray(_)) {
      const a = Array.from(new Set(_.map((c) => c.toLowerCase())).values());
      return a.length === 1 ? a[0] : (a.sort(), a);
    }
    return _.toLowerCase();
  });
  const s = e.map((_) => _ == null ? "null" : Array.isArray(_) ? _.join("|") : _).join("&");
  return { fragment: r, tag: s, topics: e };
}
async function Hc(n, t) {
  const { subs: e } = qe(n);
  return e.get((await sw(n, t)).tag) || null;
}
async function Ed(n, t, e) {
  const r = Vs(n.runner);
  ht(r, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation: t });
  const { fragment: s, tag: _, topics: a } = await sw(n, e), { addr: c, subs: u } = qe(n);
  let l = u.get(_);
  if (!l) {
    const w = { address: c || n, topics: a }, y = (U) => {
      let z = s;
      if (z == null)
        try {
          z = n.interface.getEvent(U.topics[0]);
        } catch {
        }
      if (z) {
        const M = z, N = s ? n.interface.decodeEventLog(s, U.data, U.topics) : [];
        mh(n, e, N, (I) => new AP(n, I, e, M, U));
      } else
        mh(n, e, [], (M) => new B2(n, M, e, U));
    };
    let v = [];
    l = { tag: _, listeners: [], start: () => {
      v.length || v.push(r.on(w, y));
    }, stop: async () => {
      if (v.length == 0)
        return;
      let U = v;
      v = [], await Promise.all(U), r.off(w, y);
    } }, u.set(_, l);
  }
  return l;
}
let Ah = Promise.resolve();
async function MP(n, t, e, r) {
  await Ah;
  const s = await Hc(n, t);
  if (!s)
    return !1;
  const _ = s.listeners.length;
  return s.listeners = s.listeners.filter(({ listener: a, once: c }) => {
    const u = Array.from(e);
    r && u.push(r(c ? null : a));
    try {
      a.call(n, ...u);
    } catch {
    }
    return !c;
  }), s.listeners.length === 0 && (s.stop(), qe(n).subs.delete(s.tag)), _ > 0;
}
async function mh(n, t, e, r) {
  try {
    await Ah;
  } catch {
  }
  const s = MP(n, t, e, r);
  return Ah = s, await s;
}
const Lu = ["then"];
var Qy;
Qy = yf;
const eu = class eu {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(t, e, r, s) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    $(this, "target");
    /**
     *  The contract Interface.
     */
    $(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    $(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    $(this, "filters");
    /**
     *  @_ignore:
     */
    $(this, Qy);
    /**
     *  The fallback or receive function if any.
     */
    $(this, "fallback");
    W(typeof t == "string" || KA(t), "invalid value for Contract target", "target", t), r == null && (r = null);
    const _ = yh.from(e);
    Bt(this, { target: t, runner: r, interface: _ }), Object.defineProperty(this, yf, { value: {} });
    let a, c = null, u = null;
    if (s) {
      const w = Vs(r);
      u = new iw(this.interface, w, s);
    }
    let l = /* @__PURE__ */ new Map();
    if (typeof t == "string")
      if (ee(t))
        c = t, a = Promise.resolve(t);
      else {
        const w = v_(r, "resolveName");
        if (!Lf(w))
          throw oe("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        a = w.resolveName(t).then((y) => {
          if (y == null)
            throw oe("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: t
            });
          return qe(this).addr = y, y;
        });
      }
    else
      a = t.getAddress().then((w) => {
        if (w == null)
          throw new Error("TODO");
        return qe(this).addr = w, w;
      });
    zP(this, { addrPromise: a, addr: c, deployTx: u, subs: l });
    const f = new Proxy({}, {
      get: (w, y, v) => {
        if (typeof y == "symbol" || Lu.indexOf(y) >= 0)
          return Reflect.get(w, y, v);
        try {
          return this.getEvent(y);
        } catch (x) {
          if (!Re(x, "INVALID_ARGUMENT") || x.argument !== "key")
            throw x;
        }
      },
      has: (w, y) => Lu.indexOf(y) >= 0 ? Reflect.has(w, y) : Reflect.has(w, y) || this.interface.hasEvent(String(y))
    });
    return Bt(this, { filters: f }), Bt(this, {
      fallback: _.receive || _.fallback ? RP(this) : null
    }), new Proxy(this, {
      get: (w, y, v) => {
        if (typeof y == "symbol" || y in w || Lu.indexOf(y) >= 0)
          return Reflect.get(w, y, v);
        try {
          return w.getFunction(y);
        } catch (x) {
          if (!Re(x, "INVALID_ARGUMENT") || x.argument !== "key")
            throw x;
        }
      },
      has: (w, y) => typeof y == "symbol" || y in w || Lu.indexOf(y) >= 0 ? Reflect.has(w, y) : w.interface.hasFunction(y)
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(t) {
    return new eu(this.target, this.interface, t);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(t) {
    return new eu(t, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await qe(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const t = Vs(this.runner);
    ht(t, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const e = await t.getCode(await this.getAddress());
    return e === "0x" ? null : e;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const t = this.deploymentTransaction();
    if (t)
      return await t.wait(), this;
    if (await this.getDeployedCode() != null)
      return this;
    const r = Vs(this.runner);
    return ht(r != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" }), new Promise((s, _) => {
      const a = async () => {
        try {
          if (await this.getDeployedCode() != null)
            return s(this);
          r.once("block", a);
        } catch (c) {
          _(c);
        }
      };
      a();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return qe(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(t) {
    return typeof t != "string" && (t = t.format()), EP(this, t);
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(t) {
    return typeof t != "string" && (t = t.format()), PP(this, t);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(t) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(t, e, r) {
    e == null && (e = 0), r == null && (r = "latest");
    const { addr: s, addrPromise: _ } = qe(this), a = s || await _, { fragment: c, topics: u } = await sw(this, t), l = { address: a, topics: u, fromBlock: e, toBlock: r }, f = Vs(this.runner);
    return ht(f, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" }), (await f.getLogs(l)).map((w) => {
      let y = c;
      if (y == null)
        try {
          y = this.interface.getEvent(w.topics[0]);
        } catch {
        }
      if (y)
        try {
          return new nw(w, this.interface, y);
        } catch (v) {
          return new x2(w, v);
        }
      return new xu(w, f);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(t, e) {
    const r = await Ed(this, "on", t);
    return r.listeners.push({ listener: e, once: !1 }), r.start(), this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(t, e) {
    const r = await Ed(this, "once", t);
    return r.listeners.push({ listener: e, once: !0 }), r.start(), this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(t, ...e) {
    return await mh(this, t, e, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(t) {
    if (t) {
      const s = await Hc(this, t);
      return s ? s.listeners.length : 0;
    }
    const { subs: e } = qe(this);
    let r = 0;
    for (const { listeners: s } of e.values())
      r += s.length;
    return r;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(t) {
    if (t) {
      const s = await Hc(this, t);
      return s ? s.listeners.map(({ listener: _ }) => _) : [];
    }
    const { subs: e } = qe(this);
    let r = [];
    for (const { listeners: s } of e.values())
      r = r.concat(s.map(({ listener: _ }) => _));
    return r;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(t, e) {
    const r = await Hc(this, t);
    if (!r)
      return this;
    if (e) {
      const s = r.listeners.map(({ listener: _ }) => _).indexOf(e);
      s >= 0 && r.listeners.splice(s, 1);
    }
    return (e == null || r.listeners.length === 0) && (r.stop(), qe(this).subs.delete(r.tag)), this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(t) {
    if (t) {
      const e = await Hc(this, t);
      if (!e)
        return this;
      e.stop(), qe(this).subs.delete(e.tag);
    } else {
      const { subs: e } = qe(this);
      for (const { tag: r, stop: s } of e.values())
        s(), e.delete(r);
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(t, e) {
    return await this.on(t, e);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(t, e) {
    return await this.off(t, e);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(t) {
    class e extends eu {
      constructor(s, _ = null) {
        super(s, t, _);
      }
    }
    return e;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(t, e, r) {
    return r == null && (r = null), new this(t, e, r);
  }
};
let Sh = eu;
function xP() {
  return Sh;
}
class Pr extends xP() {
}
function Cl(n) {
  return n.match(/^ipfs:\/\/ipfs\//i) ? n = n.substring(12) : n.match(/^ipfs:\/\//i) ? n = n.substring(7) : W(!1, "unsupported IPFS format", "link", n), `https://gateway.ipfs.io/ipfs/${n}`;
}
class BP {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(t) {
    /**
     *  The name.
     */
    $(this, "name");
    Bt(this, { name: t });
  }
  connect(t) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(t) {
    return !1;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(t, e) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(t, e) {
    throw new Error("unsupported coin");
  }
}
const G2 = new RegExp("^(ipfs)://(.*)$", "i"), Pd = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  G2,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
var ps, f_, hs, K_, vf, U2;
const Ra = class Ra {
  constructor(t, e, r) {
    nt(this, hs);
    /**
     *  The connected provider.
     */
    $(this, "provider");
    /**
     *  The address of the resolver.
     */
    $(this, "address");
    /**
     *  The name this resolver was resolved against.
     */
    $(this, "name");
    // For EIP-2544 names, the ancestor that provided the resolver
    nt(this, ps);
    nt(this, f_);
    Bt(this, { provider: t, address: e, name: r }), K(this, ps, null), K(this, f_, new Pr(e, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], t));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    return A(this, ps) == null && K(this, ps, (async () => {
      try {
        return await A(this, f_).supportsInterface("0x9061b923");
      } catch (t) {
        if (Re(t, "CALL_EXCEPTION"))
          return !1;
        throw K(this, ps, null), t;
      }
    })()), await A(this, ps);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(t) {
    if (t == null && (t = 60), t === 60)
      try {
        const _ = await At(this, hs, K_).call(this, "addr(bytes32)");
        return _ == null || _ === nu ? null : _;
      } catch (_) {
        if (Re(_, "CALL_EXCEPTION"))
          return null;
        throw _;
      }
    if (t >= 0 && t < 2147483648) {
      let _ = t + 2147483648;
      const a = await At(this, hs, K_).call(this, "addr(bytes32,uint)", [_]);
      if (ee(a, 20))
        return jt(a);
    }
    let e = null;
    for (const _ of this.provider.plugins)
      if (_ instanceof BP && _.supportsCoinType(t)) {
        e = _;
        break;
      }
    if (e == null)
      return null;
    const r = await At(this, hs, K_).call(this, "addr(bytes32,uint)", [t]);
    if (r == null || r === "0x")
      return null;
    const s = await e.decodeAddress(t, r);
    if (s != null)
      return s;
    ht(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${t})`,
      info: { coinType: t, data: r }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(t) {
    const e = await At(this, hs, K_).call(this, "text(bytes32,string)", [t]);
    return e == null || e === "0x" ? null : e;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const t = await At(this, hs, K_).call(this, "contenthash(bytes32)");
    if (t == null || t === "0x")
      return null;
    const e = t.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (e) {
      const s = e[1] === "e3010170" ? "ipfs" : "ipns", _ = parseInt(e[4], 16);
      if (e[5].length === _ * 2)
        return `${s}://${Vm("0x" + e[2])}`;
    }
    const r = t.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (r && r[1].length === 64)
      return `bzz://${r[1]}`;
    ht(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: t }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    return (await this._getAvatar()).url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const t = [{ type: "name", value: this.name }];
    try {
      const e = await this.getText("avatar");
      if (e == null)
        return t.push({ type: "!avatar", value: "" }), { url: null, linkage: t };
      t.push({ type: "avatar", value: e });
      for (let r = 0; r < Pd.length; r++) {
        const s = e.match(Pd[r]);
        if (s == null)
          continue;
        const _ = s[1].toLowerCase();
        switch (_) {
          case "https":
          case "data":
            return t.push({ type: "url", value: e }), { linkage: t, url: e };
          case "ipfs": {
            const a = Cl(e);
            return t.push({ type: "ipfs", value: e }), t.push({ type: "url", value: a }), { linkage: t, url: a };
          }
          case "erc721":
          case "erc1155": {
            const a = _ === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            t.push({ type: _, value: e });
            const c = await this.getAddress();
            if (c == null)
              return t.push({ type: "!owner", value: "" }), { url: null, linkage: t };
            const u = (s[2] || "").split("/");
            if (u.length !== 2)
              return t.push({ type: `!${_}caip`, value: s[2] || "" }), { url: null, linkage: t };
            const l = u[1], f = new Pr(u[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (_ === "erc721") {
              const C = await f.ownerOf(l);
              if (c !== C)
                return t.push({ type: "!owner", value: C }), { url: null, linkage: t };
              t.push({ type: "owner", value: C });
            } else if (_ === "erc1155") {
              const C = await f.balanceOf(c, l);
              if (!C)
                return t.push({ type: "!balance", value: "0" }), { url: null, linkage: t };
              t.push({ type: "balance", value: C.toString() });
            }
            let w = await f[a](l);
            if (w == null || w === "0x")
              return t.push({ type: "!metadata-url", value: "" }), { url: null, linkage: t };
            t.push({ type: "metadata-url-base", value: w }), _ === "erc1155" && (w = w.replace("{id}", zs(l, 32).substring(2)), t.push({ type: "metadata-url-expanded", value: w })), w.match(/^ipfs:/i) && (w = Cl(w)), t.push({ type: "metadata-url", value: w });
            let y = {};
            const v = await new Wi(w).send();
            v.assertOk();
            try {
              y = v.bodyJson;
            } catch {
              try {
                t.push({ type: "!metadata", value: v.bodyText });
              } catch {
                const z = v.body;
                return z && t.push({ type: "!metadata", value: Rt(z) }), { url: null, linkage: t };
              }
              return { url: null, linkage: t };
            }
            if (!y)
              return t.push({ type: "!metadata", value: "" }), { url: null, linkage: t };
            t.push({ type: "metadata", value: JSON.stringify(y) });
            let x = y.image;
            if (typeof x != "string")
              return t.push({ type: "!imageUrl", value: "" }), { url: null, linkage: t };
            if (!x.match(/^(https:\/\/|data:)/i)) {
              if (x.match(G2) == null)
                return t.push({ type: "!imageUrl-ipfs", value: x }), { url: null, linkage: t };
              t.push({ type: "imageUrl-ipfs", value: x }), x = Cl(x);
            }
            return t.push({ type: "url", value: x }), { linkage: t, url: x };
          }
        }
      }
    } catch {
    }
    return { linkage: t, url: null };
  }
  static async getEnsAddress(t) {
    const e = await t.getNetwork(), r = e.getPlugin("org.ethers.plugins.network.Ens");
    return ht(r, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network: e }
    }), r.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(t, e) {
    var s;
    let r = e;
    for (; ; ) {
      if (r === "" || r === "." || e !== "eth" && r === "eth")
        return null;
      const _ = await At(s = Ra, vf, U2).call(s, t, r);
      if (_ != null) {
        const a = new Ra(t, _, e);
        return r !== e && !await a.supportsWildcard() ? null : a;
      }
      r = r.split(".").slice(1).join(".");
    }
  }
};
ps = new WeakMap(), f_ = new WeakMap(), hs = new WeakSet(), K_ = async function(t, e) {
  e = (e || []).slice();
  const r = A(this, f_).interface;
  e.unshift(gh(this.name));
  let s = null;
  await this.supportsWildcard() && (s = r.getFunction(t), ht(s, "missing fragment", "UNKNOWN_ERROR", {
    info: { funcName: t }
  }), e = [
    BE(this.name, 255),
    r.encodeFunctionData(s, e)
  ], t = "resolve(bytes,bytes)"), e.push({
    enableCcipRead: !0
  });
  try {
    const _ = await A(this, f_)[t](...e);
    return s ? r.decodeFunctionResult(s, _)[0] : _;
  } catch (_) {
    if (!Re(_, "CALL_EXCEPTION"))
      throw _;
  }
  return null;
}, vf = new WeakSet(), U2 = async function(t, e) {
  const r = await Ra.getEnsAddress(t);
  try {
    const _ = await new Pr(r, [
      "function resolver(bytes32) view returns (address)"
    ], t).resolver(gh(e), {
      enableCcipRead: !0
    });
    return _ === nu ? null : _;
  } catch (s) {
    throw s;
  }
  return null;
}, nt(Ra, vf);
let Af = Ra;
const zd = BigInt(0);
function Lt(n, t) {
  return function(e) {
    return e == null ? t : n(e);
  };
}
function jf(n, t) {
  return (e) => {
    if (t && e == null)
      return null;
    if (!Array.isArray(e))
      throw new Error("not an array");
    return e.map((r) => n(r));
  };
}
function Bu(n, t) {
  return (e) => {
    const r = {};
    for (const s in n) {
      let _ = s;
      if (t && s in t && !(_ in e)) {
        for (const a of t[s])
          if (a in e) {
            _ = a;
            break;
          }
      }
      try {
        const a = n[s](e[_]);
        a !== void 0 && (r[s] = a);
      } catch (a) {
        const c = a instanceof Error ? a.message : "not-an-error";
        ht(!1, `invalid value for value.${s} (${c})`, "BAD_DATA", { value: e });
      }
    }
    return r;
  };
}
function CP(n) {
  switch (n) {
    case !0:
    case "true":
      return !0;
    case !1:
    case "false":
      return !1;
  }
  W(!1, `invalid boolean; ${JSON.stringify(n)}`, "value", n);
}
function xc(n) {
  return W(ee(n, !0), "invalid data", "value", n), n;
}
function Se(n) {
  return W(ee(n, 32), "invalid hash", "value", n), n;
}
const IP = Bu({
  address: jt,
  blockHash: Se,
  blockNumber: Ft,
  data: xc,
  index: Ft,
  removed: Lt(CP, !1),
  topics: jf(Se),
  transactionHash: Se,
  transactionIndex: Ft
}, {
  index: ["logIndex"]
});
function NP(n) {
  return IP(n);
}
const OP = Bu({
  hash: Lt(Se),
  parentHash: Se,
  parentBeaconBlockRoot: Lt(Se, null),
  number: Ft,
  timestamp: Ft,
  nonce: Lt(xc),
  difficulty: zt,
  gasLimit: zt,
  gasUsed: zt,
  stateRoot: Lt(Se, null),
  receiptsRoot: Lt(Se, null),
  blobGasUsed: Lt(zt, null),
  excessBlobGas: Lt(zt, null),
  miner: Lt(jt),
  prevRandao: Lt(Se, null),
  extraData: xc,
  baseFeePerGas: Lt(zt)
}, {
  prevRandao: ["mixHash"]
});
function kP(n) {
  const t = OP(n);
  return t.transactions = n.transactions.map((e) => typeof e == "string" ? e : F2(e)), t;
}
const TP = Bu({
  transactionIndex: Ft,
  blockNumber: Ft,
  transactionHash: Se,
  address: jt,
  topics: jf(Se),
  data: xc,
  index: Ft,
  blockHash: Se
}, {
  index: ["logIndex"]
});
function GP(n) {
  return TP(n);
}
const UP = Bu({
  to: Lt(jt, null),
  from: Lt(jt, null),
  contractAddress: Lt(jt, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: Ft,
  root: Lt(Rt),
  gasUsed: zt,
  blobGasUsed: Lt(zt, null),
  logsBloom: Lt(xc),
  blockHash: Se,
  hash: Se,
  logs: jf(GP),
  blockNumber: Ft,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: zt,
  effectiveGasPrice: Lt(zt),
  blobGasPrice: Lt(zt, null),
  status: Lt(Ft),
  type: Lt(Ft, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function FP(n) {
  return UP(n);
}
function F2(n) {
  n.to && zt(n.to) === zd && (n.to = "0x0000000000000000000000000000000000000000");
  const t = Bu({
    hash: Se,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: Lt(Ft, void 0),
    type: (e) => e === "0x" || e == null ? 0 : Ft(e),
    accessList: Lt(C_, null),
    blobVersionedHashes: Lt(jf(Se, !0), null),
    blockHash: Lt(Se, null),
    blockNumber: Lt(Ft, null),
    transactionIndex: Lt(Ft, null),
    from: jt,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: Lt(zt),
    maxPriorityFeePerGas: Lt(zt),
    maxFeePerGas: Lt(zt),
    maxFeePerBlobGas: Lt(zt, null),
    gasLimit: zt,
    to: Lt(jt, null),
    value: zt,
    nonce: Ft,
    data: xc,
    creates: Lt(jt, null),
    chainId: Lt(zt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(n);
  if (t.to == null && t.creates == null && (t.creates = NR(t)), (n.type === 1 || n.type === 2) && n.accessList == null && (t.accessList = []), n.signature ? t.signature = zr.from(n.signature) : t.signature = zr.from(n), t.chainId == null) {
    const e = t.signature.legacyChainId;
    e != null && (t.chainId = e);
  }
  return t.blockHash && zt(t.blockHash) === zd && (t.blockHash = null), t;
}
const KP = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class Cu {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(t) {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    $(this, "name");
    Bt(this, { name: t });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new Cu(this.name);
  }
}
class Vf extends Cu {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(e, r) {
    e == null && (e = 0);
    super(`org.ethers.network.plugins.GasCost#${e || 0}`);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    $(this, "effectiveBlock");
    /**
     *  The transactions base fee.
     */
    $(this, "txBase");
    /**
     *  The fee for creating a new account.
     */
    $(this, "txCreate");
    /**
     *  The fee per zero-byte in the data.
     */
    $(this, "txDataZero");
    /**
     *  The fee per non-zero-byte in the data.
     */
    $(this, "txDataNonzero");
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    $(this, "txAccessListStorageKey");
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    $(this, "txAccessListAddress");
    const s = { effectiveBlock: e };
    function _(a, c) {
      let u = (r || {})[a];
      u == null && (u = c), W(typeof u == "number", `invalud value for ${a}`, "costs", r), s[a] = u;
    }
    _("txBase", 21e3), _("txCreate", 32e3), _("txDataZero", 4), _("txDataNonzero", 16), _("txAccessListStorageKey", 1900), _("txAccessListAddress", 2400), Bt(this, s);
  }
  clone() {
    return new Vf(this.effectiveBlock, this);
  }
}
class Yf extends Cu {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(e, r) {
    super("org.ethers.plugins.network.Ens");
    /**
     *  The ENS Registrty Contract address.
     */
    $(this, "address");
    /**
     *  The chain ID that the ENS contract lives on.
     */
    $(this, "targetNetwork");
    Bt(this, {
      address: e || KP,
      targetNetwork: r ?? 1
    });
  }
  clone() {
    return new Yf(this.address, this.targetNetwork);
  }
}
var Ru, Eu;
class DP extends Cu {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(e, r) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    nt(this, Ru);
    nt(this, Eu);
    K(this, Ru, e), K(this, Eu, r);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return A(this, Ru);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return A(this, Eu);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
Ru = new WeakMap(), Eu = new WeakMap();
const Il = /* @__PURE__ */ new Map();
var _c, oc, ws;
const Ea = class Ea {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(t, e) {
    nt(this, _c);
    nt(this, oc);
    nt(this, ws);
    K(this, _c, t), K(this, oc, zt(e)), K(this, ws, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return A(this, _c);
  }
  set name(t) {
    K(this, _c, t);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return A(this, oc);
  }
  set chainId(t) {
    K(this, oc, zt(t, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(t) {
    if (t == null)
      return !1;
    if (typeof t == "string") {
      try {
        return this.chainId === zt(t);
      } catch {
      }
      return this.name === t;
    }
    if (typeof t == "number" || typeof t == "bigint") {
      try {
        return this.chainId === zt(t);
      } catch {
      }
      return !1;
    }
    if (typeof t == "object") {
      if (t.chainId != null) {
        try {
          return this.chainId === zt(t.chainId);
        } catch {
        }
        return !1;
      }
      return t.name != null ? this.name === t.name : !1;
    }
    return !1;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(A(this, ws).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(t) {
    if (A(this, ws).get(t.name))
      throw new Error(`cannot replace existing plugin: ${t.name} `);
    return A(this, ws).set(t.name, t.clone()), this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(t) {
    return A(this, ws).get(t) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(t) {
    return this.plugins.filter((e) => e.name.split("#")[0] === t);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const t = new Ea(this.name, this.chainId);
    return this.plugins.forEach((e) => {
      t.attachPlugin(e.clone());
    }), t;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(t) {
    const e = this.getPlugin("org.ethers.plugins.network.GasCost") || new Vf();
    let r = e.txBase;
    if (t.to == null && (r += e.txCreate), t.data)
      for (let s = 2; s < t.data.length; s += 2)
        t.data.substring(s, s + 2) === "00" ? r += e.txDataZero : r += e.txDataNonzero;
    if (t.accessList) {
      const s = C_(t.accessList);
      for (const _ in s)
        r += e.txAccessListAddress + e.txAccessListStorageKey * s[_].storageKeys.length;
    }
    return r;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(t) {
    if (LP(), t == null)
      return Ea.from("mainnet");
    if (typeof t == "number" && (t = BigInt(t)), typeof t == "string" || typeof t == "bigint") {
      const e = Il.get(t);
      if (e)
        return e();
      if (typeof t == "bigint")
        return new Ea("unknown", t);
      W(!1, "unknown network", "network", t);
    }
    if (typeof t.clone == "function")
      return t.clone();
    if (typeof t == "object") {
      W(typeof t.name == "string" && typeof t.chainId == "number", "invalid network object name or chainId", "network", t);
      const e = new Ea(t.name, t.chainId);
      return (t.ensAddress || t.ensNetwork != null) && e.attachPlugin(new Yf(t.ensAddress, t.ensNetwork)), e;
    }
    W(!1, "invalid network", "network", t);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(t, e) {
    typeof t == "number" && (t = BigInt(t));
    const r = Il.get(t);
    r && W(!1, `conflicting network for ${JSON.stringify(r.name)}`, "nameOrChainId", t), Il.set(t, e);
  }
};
_c = new WeakMap(), oc = new WeakMap(), ws = new WeakMap();
let Pi = Ea;
function vd(n, t) {
  const e = String(n);
  if (!e.match(/^[0-9.]+$/))
    throw new Error(`invalid gwei value: ${n}`);
  const r = e.split(".");
  if (r.length === 1 && r.push(""), r.length !== 2)
    throw new Error(`invalid gwei value: ${n}`);
  for (; r[1].length < t; )
    r[1] += "0";
  if (r[1].length > 9) {
    let s = BigInt(r[1].substring(0, 9));
    r[1].substring(9).match(/^0+$/) || s++, r[1] = s.toString();
  }
  return BigInt(r[0] + r[1]);
}
function Md(n) {
  return new DP(n, async (t, e, r) => {
    r.setHeader("User-Agent", "ethers");
    let s;
    try {
      const [_, a] = await Promise.all([
        r.send(),
        t()
      ]);
      s = _;
      const c = s.bodyJson.standard;
      return {
        gasPrice: a.gasPrice,
        maxFeePerGas: vd(c.maxFee, 9),
        maxPriorityFeePerGas: vd(c.maxPriorityFee, 9)
      };
    } catch (_) {
      ht(!1, `error encountered with polygon gas station (${JSON.stringify(r.url)})`, "SERVER_ERROR", { request: r, response: s, error: _ });
    }
  });
}
let xd = !1;
function LP() {
  if (xd)
    return;
  xd = !0;
  function n(t, e, r) {
    const s = function() {
      const _ = new Pi(t, e);
      return r.ensNetwork != null && _.attachPlugin(new Yf(null, r.ensNetwork)), _.attachPlugin(new Vf()), (r.plugins || []).forEach((a) => {
        _.attachPlugin(a);
      }), _;
    };
    Pi.register(t, s), Pi.register(e, s), r.altNames && r.altNames.forEach((_) => {
      Pi.register(_, s);
    });
  }
  n("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }), n("ropsten", 3, { ensNetwork: 3 }), n("rinkeby", 4, { ensNetwork: 4 }), n("goerli", 5, { ensNetwork: 5 }), n("kovan", 42, { ensNetwork: 42 }), n("sepolia", 11155111, { ensNetwork: 11155111 }), n("holesky", 17e3, { ensNetwork: 17e3 }), n("classic", 61, {}), n("classicKotti", 6, {}), n("arbitrum", 42161, {
    ensNetwork: 1
  }), n("arbitrum-goerli", 421613, {}), n("arbitrum-sepolia", 421614, {}), n("base", 8453, { ensNetwork: 1 }), n("base-goerli", 84531, {}), n("base-sepolia", 84532, {}), n("bnb", 56, { ensNetwork: 1 }), n("bnbt", 97, {}), n("linea", 59144, { ensNetwork: 1 }), n("linea-goerli", 59140, {}), n("linea-sepolia", 59141, {}), n("matic", 137, {
    ensNetwork: 1,
    plugins: [
      Md("https://gasstation.polygon.technology/v2")
    ]
  }), n("matic-amoy", 80002, {}), n("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      Md("https://gasstation-testnet.polygon.technology/v2")
    ]
  }), n("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  }), n("optimism-goerli", 420, {}), n("optimism-sepolia", 11155420, {}), n("xdai", 100, { ensNetwork: 1 });
}
function Rh(n) {
  return JSON.parse(JSON.stringify(n));
}
var Fi, ar, ds, jr, ac, ef;
class jP {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(t) {
    nt(this, ac);
    nt(this, Fi);
    nt(this, ar);
    nt(this, ds);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    nt(this, jr);
    K(this, Fi, t), K(this, ar, null), K(this, ds, 4e3), K(this, jr, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return A(this, ds);
  }
  set pollingInterval(t) {
    K(this, ds, t);
  }
  start() {
    A(this, ar) || (K(this, ar, A(this, Fi)._setTimeout(At(this, ac, ef).bind(this), A(this, ds))), At(this, ac, ef).call(this));
  }
  stop() {
    A(this, ar) && (A(this, Fi)._clearTimeout(A(this, ar)), K(this, ar, null));
  }
  pause(t) {
    this.stop(), t && K(this, jr, -2);
  }
  resume() {
    this.start();
  }
}
Fi = new WeakMap(), ar = new WeakMap(), ds = new WeakMap(), jr = new WeakMap(), ac = new WeakSet(), ef = async function() {
  try {
    const t = await A(this, Fi).getBlockNumber();
    if (A(this, jr) === -2) {
      K(this, jr, t);
      return;
    }
    if (t !== A(this, jr)) {
      for (let e = A(this, jr) + 1; e <= t; e++) {
        if (A(this, ar) == null)
          return;
        await A(this, Fi).emit("block", e);
      }
      K(this, jr, t);
    }
  } catch {
  }
  A(this, ar) != null && K(this, ar, A(this, Fi)._setTimeout(At(this, ac, ef).bind(this), A(this, ds)));
};
var l_, p_, gs;
class _w {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(t) {
    nt(this, l_);
    nt(this, p_);
    nt(this, gs);
    K(this, l_, t), K(this, gs, !1), K(this, p_, (e) => {
      this._poll(e, A(this, l_));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(t, e) {
    throw new Error("sub-classes must override this");
  }
  start() {
    A(this, gs) || (K(this, gs, !0), A(this, p_).call(this, -2), A(this, l_).on("block", A(this, p_)));
  }
  stop() {
    A(this, gs) && (K(this, gs, !1), A(this, l_).off("block", A(this, p_)));
  }
  pause(t) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
l_ = new WeakMap(), p_ = new WeakMap(), gs = new WeakMap();
var cc, Ki;
class VP extends _w {
  constructor(e, r) {
    super(e);
    nt(this, cc);
    nt(this, Ki);
    K(this, cc, r), K(this, Ki, -2);
  }
  pause(e) {
    e && K(this, Ki, -2), super.pause(e);
  }
  async _poll(e, r) {
    const s = await r.getBlock(A(this, cc));
    s != null && (A(this, Ki) === -2 ? K(this, Ki, s.number) : s.number > A(this, Ki) && (r.emit(A(this, cc), s.number), K(this, Ki, s.number)));
  }
}
cc = new WeakMap(), Ki = new WeakMap();
var Mf;
class YP extends _w {
  constructor(e, r) {
    super(e);
    nt(this, Mf);
    K(this, Mf, Rh(r));
  }
  async _poll(e, r) {
    throw new Error("@TODO");
  }
}
Mf = new WeakMap();
var uc;
class HP extends _w {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(e, r) {
    super(e);
    nt(this, uc);
    K(this, uc, r);
  }
  async _poll(e, r) {
    const s = await r.getTransactionReceipt(A(this, uc));
    s && r.emit(A(this, uc), s);
  }
}
uc = new WeakMap();
var Di, fc, lc, bs, cr, xf, K2;
class ow {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(t, e) {
    nt(this, xf);
    nt(this, Di);
    nt(this, fc);
    nt(this, lc);
    nt(this, bs);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    nt(this, cr);
    K(this, Di, t), K(this, fc, Rh(e)), K(this, lc, At(this, xf, K2).bind(this)), K(this, bs, !1), K(this, cr, -2);
  }
  start() {
    A(this, bs) || (K(this, bs, !0), A(this, cr) === -2 && A(this, Di).getBlockNumber().then((t) => {
      K(this, cr, t);
    }), A(this, Di).on("block", A(this, lc)));
  }
  stop() {
    A(this, bs) && (K(this, bs, !1), A(this, Di).off("block", A(this, lc)));
  }
  pause(t) {
    this.stop(), t && K(this, cr, -2);
  }
  resume() {
    this.start();
  }
}
Di = new WeakMap(), fc = new WeakMap(), lc = new WeakMap(), bs = new WeakMap(), cr = new WeakMap(), xf = new WeakSet(), K2 = async function(t) {
  if (A(this, cr) === -2)
    return;
  const e = Rh(A(this, fc));
  e.fromBlock = A(this, cr) + 1, e.toBlock = t;
  const r = await A(this, Di).getLogs(e);
  if (r.length === 0) {
    A(this, cr) < t - 60 && K(this, cr, t - 60);
    return;
  }
  for (const s of r)
    A(this, Di).emit(A(this, fc), s), K(this, cr, s.blockNumber);
};
const qP = BigInt(2), QP = 10;
function ju(n) {
  return n && typeof n.then == "function";
}
function rf(n, t) {
  return n + ":" + JSON.stringify(t, (e, r) => {
    if (r == null)
      return "null";
    if (typeof r == "bigint")
      return `bigint:${r.toString()}`;
    if (typeof r == "string")
      return r.toLowerCase();
    if (typeof r == "object" && !Array.isArray(r)) {
      const s = Object.keys(r);
      return s.sort(), s.reduce((_, a) => (_[a] = r[a], _), {});
    }
    return r;
  });
}
class D2 {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(t) {
    /**
     *  The name fof the event.
     */
    $(this, "name");
    Bt(this, { name: t });
  }
  start() {
  }
  stop() {
  }
  pause(t) {
  }
  resume() {
  }
}
function WP(n) {
  return JSON.parse(JSON.stringify(n));
}
function Eh(n) {
  return n = Array.from(new Set(n).values()), n.sort(), n;
}
async function Nl(n, t) {
  if (n == null)
    throw new Error("invalid event");
  if (Array.isArray(n) && (n = { topics: n }), typeof n == "string")
    switch (n) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe":
        return { type: n, tag: n };
    }
  if (ee(n, 32)) {
    const e = n.toLowerCase();
    return { type: "transaction", tag: rf("tx", { hash: e }), hash: e };
  }
  if (n.orphan) {
    const e = n;
    return { type: "orphan", tag: rf("orphan", e), filter: WP(e) };
  }
  if (n.address || n.topics) {
    const e = n, r = {
      topics: (e.topics || []).map((s) => s == null ? null : Array.isArray(s) ? Eh(s.map((_) => _.toLowerCase())) : s.toLowerCase())
    };
    if (e.address) {
      const s = [], _ = [], a = (c) => {
        ee(c) ? s.push(c) : _.push((async () => {
          s.push(await ke(c, t));
        })());
      };
      Array.isArray(e.address) ? e.address.forEach(a) : a(e.address), _.length && await Promise.all(_), r.address = Eh(s.map((c) => c.toLowerCase()));
    }
    return { filter: r, tag: rf("event", r), type: "event" };
  }
  W(!1, "unknown ProviderEvent", "event", n);
}
function Ol() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const JP = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var ze, ys, ve, pc, Ze, h_, As, Li, Pu, ur, hc, wc, Ut, He, Ph, zh, qc, vh, Qc, nf;
class $P {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(t, e) {
    nt(this, Ut);
    nt(this, ze);
    nt(this, ys);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    nt(this, ve);
    nt(this, pc);
    nt(this, Ze);
    nt(this, h_);
    nt(this, As);
    // The most recent block number if running an event or -1 if no "block" event
    nt(this, Li);
    nt(this, Pu);
    nt(this, ur);
    nt(this, hc);
    nt(this, wc);
    if (K(this, wc, Object.assign({}, JP, e || {})), t === "any")
      K(this, h_, !0), K(this, Ze, null);
    else if (t) {
      const r = Pi.from(t);
      K(this, h_, !1), K(this, Ze, Promise.resolve(r)), setTimeout(() => {
        this.emit("network", r, null);
      }, 0);
    } else
      K(this, h_, !1), K(this, Ze, null);
    K(this, Li, -1), K(this, As, /* @__PURE__ */ new Map()), K(this, ze, /* @__PURE__ */ new Map()), K(this, ys, /* @__PURE__ */ new Map()), K(this, ve, null), K(this, pc, !1), K(this, Pu, 1), K(this, ur, /* @__PURE__ */ new Map()), K(this, hc, !1);
  }
  get pollingInterval() {
    return A(this, wc).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(A(this, ys).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(t) {
    if (A(this, ys).get(t.name))
      throw new Error(`cannot replace existing plugin: ${t.name} `);
    return A(this, ys).set(t.name, t.connect(this)), this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(t) {
    return A(this, ys).get(t) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return A(this, hc);
  }
  set disableCcipRead(t) {
    K(this, hc, !!t);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(t, e, r) {
    if (this.disableCcipRead || r.length === 0 || t.to == null)
      return null;
    const s = t.to.toLowerCase(), _ = e.toLowerCase(), a = [];
    for (let c = 0; c < r.length; c++) {
      const u = r[c], l = u.replace("{sender}", s).replace("{data}", _), f = new Wi(l);
      u.indexOf("{data}") === -1 && (f.body = { data: _, sender: s }), this.emit("debug", { action: "sendCcipReadFetchRequest", request: f, index: c, urls: r });
      let w = "unknown error", y;
      try {
        y = await f.send();
      } catch (v) {
        a.push(v.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: f, result: { error: v } });
        continue;
      }
      try {
        const v = y.bodyJson;
        if (v.data)
          return this.emit("debug", { action: "receiveCcipReadFetchResult", request: f, result: v }), v.data;
        v.message && (w = v.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: f, result: v });
      } catch {
      }
      ht(y.statusCode < 400 || y.statusCode >= 500, `response not found during CCIP fetch: ${w}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: t, info: { url: u, errorMessage: w } }), a.push(w);
    }
    ht(!1, `error encountered during CCIP fetch: ${a.map((c) => JSON.stringify(c)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: t,
      info: { urls: r, errorMessages: a }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(t, e) {
    return new dP(kP(t), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(t, e) {
    return new xu(NP(t), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(t, e) {
    return new z2(FP(t), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(t, e) {
    return new fu(F2(t), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    ht(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(t) {
    ht(!1, `unsupported method: ${t.method}`, "UNSUPPORTED_OPERATION", {
      operation: t.method,
      info: t
    });
  }
  // State
  async getBlockNumber() {
    const t = Ft(await At(this, Ut, He).call(this, { method: "getBlockNumber" }), "%response");
    return A(this, Li) >= 0 && K(this, Li, t), t;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(t) {
    return ke(t, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(t) {
    if (t == null)
      return "latest";
    switch (t) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return t;
    }
    if (ee(t))
      return ee(t, 32) ? t : L_(t);
    if (typeof t == "bigint" && (t = Ft(t, "blockTag")), typeof t == "number")
      return t >= 0 ? L_(t) : A(this, Li) >= 0 ? L_(A(this, Li) + t) : this.getBlockNumber().then((e) => L_(e + t));
    W(!1, "invalid blockTag", "blockTag", t);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(t) {
    const e = (t.topics || []).map((u) => u == null ? null : Array.isArray(u) ? Eh(u.map((l) => l.toLowerCase())) : u.toLowerCase()), r = "blockHash" in t ? t.blockHash : void 0, s = (u, l, f) => {
      let w;
      switch (u.length) {
        case 0:
          break;
        case 1:
          w = u[0];
          break;
        default:
          u.sort(), w = u;
      }
      if (r && (l != null || f != null))
        throw new Error("invalid filter");
      const y = {};
      return w && (y.address = w), e.length && (y.topics = e), l && (y.fromBlock = l), f && (y.toBlock = f), r && (y.blockHash = r), y;
    };
    let _ = [];
    if (t.address)
      if (Array.isArray(t.address))
        for (const u of t.address)
          _.push(this._getAddress(u));
      else
        _.push(this._getAddress(t.address));
    let a;
    "fromBlock" in t && (a = this._getBlockTag(t.fromBlock));
    let c;
    return "toBlock" in t && (c = this._getBlockTag(t.toBlock)), _.filter((u) => typeof u != "string").length || a != null && typeof a != "string" || c != null && typeof c != "string" ? Promise.all([Promise.all(_), a, c]).then((u) => s(u[0], u[1], u[2])) : s(_, a, c);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(t) {
    const e = bf(t), r = [];
    if (["to", "from"].forEach((s) => {
      if (e[s] == null)
        return;
      const _ = ke(e[s], this);
      ju(_) ? r.push(async function() {
        e[s] = await _;
      }()) : e[s] = _;
    }), e.blockTag != null) {
      const s = this._getBlockTag(e.blockTag);
      ju(s) ? r.push(async function() {
        e.blockTag = await s;
      }()) : e.blockTag = s;
    }
    return r.length ? async function() {
      return await Promise.all(r), e;
    }() : e;
  }
  async getNetwork() {
    if (A(this, Ze) == null) {
      const s = (async () => {
        try {
          const _ = await this._detectNetwork();
          return this.emit("network", _, null), _;
        } catch (_) {
          throw A(this, Ze) === s && K(this, Ze, null), _;
        }
      })();
      return K(this, Ze, s), (await s).clone();
    }
    const t = A(this, Ze), [e, r] = await Promise.all([
      t,
      this._detectNetwork()
      // The actual connected network
    ]);
    return e.chainId !== r.chainId && (A(this, h_) ? (this.emit("network", r, e), A(this, Ze) === t && K(this, Ze, Promise.resolve(r))) : ht(!1, `network changed: ${e.chainId} => ${r.chainId} `, "NETWORK_ERROR", {
      event: "changed"
    })), e.clone();
  }
  async getFeeData() {
    const t = await this.getNetwork(), e = async () => {
      const { _block: s, gasPrice: _, priorityFee: a } = await Ce({
        _block: At(this, Ut, vh).call(this, "latest", !1),
        gasPrice: (async () => {
          try {
            const f = await At(this, Ut, He).call(this, { method: "getGasPrice" });
            return zt(f, "%response");
          } catch {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const f = await At(this, Ut, He).call(this, { method: "getPriorityFee" });
            return zt(f, "%response");
          } catch {
          }
          return null;
        })()
      });
      let c = null, u = null;
      const l = this._wrapBlock(s, t);
      return l && l.baseFeePerGas && (u = a ?? BigInt("1000000000"), c = l.baseFeePerGas * qP + u), new Sd(_, c, u);
    }, r = t.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (r) {
      const s = new Wi(r.url), _ = await r.processFunc(e, this, s);
      return new Sd(_.gasPrice, _.maxFeePerGas, _.maxPriorityFeePerGas);
    }
    return await e();
  }
  async estimateGas(t) {
    let e = this._getTransactionRequest(t);
    return ju(e) && (e = await e), zt(await At(this, Ut, He).call(this, {
      method: "estimateGas",
      transaction: e
    }), "%response");
  }
  async call(t) {
    const { tx: e, blockTag: r } = await Ce({
      tx: this._getTransactionRequest(t),
      blockTag: this._getBlockTag(t.blockTag)
    });
    return await At(this, Ut, zh).call(this, At(this, Ut, Ph).call(this, e, r, t.enableCcipRead ? 0 : -1));
  }
  async getBalance(t, e) {
    return zt(await At(this, Ut, qc).call(this, { method: "getBalance" }, t, e), "%response");
  }
  async getTransactionCount(t, e) {
    return Ft(await At(this, Ut, qc).call(this, { method: "getTransactionCount" }, t, e), "%response");
  }
  async getCode(t, e) {
    return Rt(await At(this, Ut, qc).call(this, { method: "getCode" }, t, e));
  }
  async getStorage(t, e, r) {
    const s = zt(e, "position");
    return Rt(await At(this, Ut, qc).call(this, { method: "getStorage", position: s }, t, r));
  }
  // Write
  async broadcastTransaction(t) {
    const { blockNumber: e, hash: r, network: s } = await Ce({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: t
      }),
      network: this.getNetwork()
    }), _ = gf.from(t);
    if (_.hash !== r)
      throw new Error("@TODO: the returned hash did not match");
    return this._wrapTransactionResponse(_, s).replaceableTransaction(e);
  }
  // Queries
  async getBlock(t, e) {
    const { network: r, params: s } = await Ce({
      network: this.getNetwork(),
      params: At(this, Ut, vh).call(this, t, !!e)
    });
    return s == null ? null : this._wrapBlock(s, r);
  }
  async getTransaction(t) {
    const { network: e, params: r } = await Ce({
      network: this.getNetwork(),
      params: At(this, Ut, He).call(this, { method: "getTransaction", hash: t })
    });
    return r == null ? null : this._wrapTransactionResponse(r, e);
  }
  async getTransactionReceipt(t) {
    const { network: e, params: r } = await Ce({
      network: this.getNetwork(),
      params: At(this, Ut, He).call(this, { method: "getTransactionReceipt", hash: t })
    });
    if (r == null)
      return null;
    if (r.gasPrice == null && r.effectiveGasPrice == null) {
      const s = await At(this, Ut, He).call(this, { method: "getTransaction", hash: t });
      if (s == null)
        throw new Error("report this; could not find tx or effectiveGasPrice");
      r.effectiveGasPrice = s.gasPrice;
    }
    return this._wrapTransactionReceipt(r, e);
  }
  async getTransactionResult(t) {
    const { result: e } = await Ce({
      network: this.getNetwork(),
      result: At(this, Ut, He).call(this, { method: "getTransactionResult", hash: t })
    });
    return e == null ? null : Rt(e);
  }
  // Bloom-filter Queries
  async getLogs(t) {
    let e = this._getFilter(t);
    ju(e) && (e = await e);
    const { network: r, params: s } = await Ce({
      network: this.getNetwork(),
      params: At(this, Ut, He).call(this, { method: "getLogs", filter: e })
    });
    return s.map((_) => this._wrapLog(_, r));
  }
  // ENS
  _getProvider(t) {
    ht(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(t) {
    return await Af.fromName(this, t);
  }
  async getAvatar(t) {
    const e = await this.getResolver(t);
    return e ? await e.getAvatar() : null;
  }
  async resolveName(t) {
    const e = await this.getResolver(t);
    return e ? await e.getAddress() : null;
  }
  async lookupAddress(t) {
    t = jt(t);
    const e = gh(t.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const r = await Af.getEnsAddress(this), _ = await new Pr(r, [
        "function resolver(bytes32) view returns (address)"
      ], this).resolver(e);
      if (_ == null || _ === nu)
        return null;
      const c = await new Pr(_, [
        "function name(bytes32) view returns (string)"
      ], this).name(e);
      return await this.resolveName(c) !== t ? null : c;
    } catch (r) {
      if (Re(r, "BAD_DATA") && r.value === "0x" || Re(r, "CALL_EXCEPTION"))
        return null;
      throw r;
    }
    return null;
  }
  async waitForTransaction(t, e, r) {
    const s = e ?? 1;
    return s === 0 ? this.getTransactionReceipt(t) : new Promise(async (_, a) => {
      let c = null;
      const u = async (l) => {
        try {
          const f = await this.getTransactionReceipt(t);
          if (f != null && l - f.blockNumber + 1 >= s) {
            _(f), c && (clearTimeout(c), c = null);
            return;
          }
        } catch (f) {
          console.log("EEE", f);
        }
        this.once("block", u);
      };
      r != null && (c = setTimeout(() => {
        c != null && (c = null, this.off("block", u), a(oe("timeout", "TIMEOUT", { reason: "timeout" })));
      }, r)), u(await this.getBlockNumber());
    });
  }
  async waitForBlock(t) {
    ht(!1, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(t) {
    const e = A(this, ur).get(t);
    e && (e.timer && clearTimeout(e.timer), A(this, ur).delete(t));
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(t, e) {
    e == null && (e = 0);
    const r = Fc(this, Pu)._++, s = () => {
      A(this, ur).delete(r), t();
    };
    if (this.paused)
      A(this, ur).set(r, { timer: null, func: s, time: e });
    else {
      const _ = setTimeout(s, e);
      A(this, ur).set(r, { timer: _, func: s, time: Ol() });
    }
    return r;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(t) {
    for (const e of A(this, ze).values())
      t(e.subscriber);
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(t) {
    switch (t.type) {
      case "debug":
      case "error":
      case "network":
        return new D2(t.type);
      case "block": {
        const e = new jP(this);
        return e.pollingInterval = this.pollingInterval, e;
      }
      case "safe":
      case "finalized":
        return new VP(this, t.type);
      case "event":
        return new ow(this, t.filter);
      case "transaction":
        return new HP(this, t.hash);
      case "orphan":
        return new YP(this, t.filter);
    }
    throw new Error(`unsupported event: ${t.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(t, e) {
    for (const r of A(this, ze).values())
      if (r.subscriber === t) {
        r.started && r.subscriber.stop(), r.subscriber = e, r.started && e.start(), A(this, ve) != null && e.pause(A(this, ve));
        break;
      }
  }
  async on(t, e) {
    const r = await At(this, Ut, nf).call(this, t);
    return r.listeners.push({ listener: e, once: !1 }), r.started || (r.subscriber.start(), r.started = !0, A(this, ve) != null && r.subscriber.pause(A(this, ve))), this;
  }
  async once(t, e) {
    const r = await At(this, Ut, nf).call(this, t);
    return r.listeners.push({ listener: e, once: !0 }), r.started || (r.subscriber.start(), r.started = !0, A(this, ve) != null && r.subscriber.pause(A(this, ve))), this;
  }
  async emit(t, ...e) {
    const r = await At(this, Ut, Qc).call(this, t, e);
    if (!r || r.listeners.length === 0)
      return !1;
    const s = r.listeners.length;
    return r.listeners = r.listeners.filter(({ listener: _, once: a }) => {
      const c = new eA(this, a ? null : _, t);
      try {
        _.call(this, ...e, c);
      } catch {
      }
      return !a;
    }), r.listeners.length === 0 && (r.started && r.subscriber.stop(), A(this, ze).delete(r.tag)), s > 0;
  }
  async listenerCount(t) {
    if (t) {
      const r = await At(this, Ut, Qc).call(this, t);
      return r ? r.listeners.length : 0;
    }
    let e = 0;
    for (const { listeners: r } of A(this, ze).values())
      e += r.length;
    return e;
  }
  async listeners(t) {
    if (t) {
      const r = await At(this, Ut, Qc).call(this, t);
      return r ? r.listeners.map(({ listener: s }) => s) : [];
    }
    let e = [];
    for (const { listeners: r } of A(this, ze).values())
      e = e.concat(r.map(({ listener: s }) => s));
    return e;
  }
  async off(t, e) {
    const r = await At(this, Ut, Qc).call(this, t);
    if (!r)
      return this;
    if (e) {
      const s = r.listeners.map(({ listener: _ }) => _).indexOf(e);
      s >= 0 && r.listeners.splice(s, 1);
    }
    return (!e || r.listeners.length === 0) && (r.started && r.subscriber.stop(), A(this, ze).delete(r.tag)), this;
  }
  async removeAllListeners(t) {
    if (t) {
      const { tag: e, started: r, subscriber: s } = await At(this, Ut, nf).call(this, t);
      r && s.stop(), A(this, ze).delete(e);
    } else
      for (const [e, { started: r, subscriber: s }] of A(this, ze))
        r && s.stop(), A(this, ze).delete(e);
    return this;
  }
  // Alias for "on"
  async addListener(t, e) {
    return await this.on(t, e);
  }
  // Alias for "off"
  async removeListener(t, e) {
    return this.off(t, e);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return A(this, pc);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const t of A(this, ur).keys())
      this._clearTimeout(t);
    K(this, pc, !0);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return A(this, ve) != null;
  }
  set paused(t) {
    !!t !== this.paused && (this.paused ? this.resume() : this.pause(!1));
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(t) {
    if (K(this, Li, -1), A(this, ve) != null) {
      if (A(this, ve) == !!t)
        return;
      ht(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((e) => e.pause(t)), K(this, ve, !!t);
    for (const e of A(this, ur).values())
      e.timer && clearTimeout(e.timer), e.time = Ol() - e.time;
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (A(this, ve) != null) {
      this._forEachSubscriber((t) => t.resume()), K(this, ve, null);
      for (const t of A(this, ur).values()) {
        let e = t.time;
        e < 0 && (e = 0), t.time = Ol(), setTimeout(t.func, e);
      }
    }
  }
}
ze = new WeakMap(), ys = new WeakMap(), ve = new WeakMap(), pc = new WeakMap(), Ze = new WeakMap(), h_ = new WeakMap(), As = new WeakMap(), Li = new WeakMap(), Pu = new WeakMap(), ur = new WeakMap(), hc = new WeakMap(), wc = new WeakMap(), Ut = new WeakSet(), He = async function(t) {
  const e = A(this, wc).cacheTimeout;
  if (e < 0)
    return await this._perform(t);
  const r = rf(t.method, t);
  let s = A(this, As).get(r);
  return s || (s = this._perform(t), A(this, As).set(r, s), setTimeout(() => {
    A(this, As).get(r) === s && A(this, As).delete(r);
  }, e)), await s;
}, Ph = async function(t, e, r) {
  ht(r < QP, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, t, { blockTag: e, enableCcipRead: !0 })
  });
  const s = bf(t);
  try {
    return Rt(await this._perform({ method: "call", transaction: s, blockTag: e }));
  } catch (_) {
    if (!this.disableCcipRead && Fh(_) && _.data && r >= 0 && e === "latest" && s.to != null && ae(_.data, 0, 4) === "0x556f1830") {
      const a = _.data, c = await ke(s.to, this);
      let u;
      try {
        u = rz(ae(_.data, 4));
      } catch (w) {
        ht(!1, w.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction: s,
          info: { data: a }
        });
      }
      ht(u.sender.toLowerCase() === c.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data: a,
        reason: "OffchainLookup",
        transaction: s,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: u.errorArgs
        }
      });
      const l = await this.ccipReadFetch(s, u.calldata, u.urls);
      ht(l != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction: s,
        info: { data: _.data, errorArgs: u.errorArgs }
      });
      const f = {
        to: c,
        data: pe([u.selector, ez([l, u.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: f });
      try {
        const w = await At(this, Ut, Ph).call(this, f, e, r + 1);
        return this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, f), result: w }), w;
      } catch (w) {
        throw this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, f), error: w }), w;
      }
    }
    throw _;
  }
}, zh = async function(t) {
  const { value: e } = await Ce({
    network: this.getNetwork(),
    value: t
  });
  return e;
}, qc = async function(t, e, r) {
  let s = this._getAddress(e), _ = this._getBlockTag(r);
  return (typeof s != "string" || typeof _ != "string") && ([s, _] = await Promise.all([s, _])), await At(this, Ut, zh).call(this, At(this, Ut, He).call(this, Object.assign(t, { address: s, blockTag: _ })));
}, vh = async function(t, e) {
  if (ee(t, 32))
    return await At(this, Ut, He).call(this, {
      method: "getBlock",
      blockHash: t,
      includeTransactions: e
    });
  let r = this._getBlockTag(t);
  return typeof r != "string" && (r = await r), await At(this, Ut, He).call(this, {
    method: "getBlock",
    blockTag: r,
    includeTransactions: e
  });
}, Qc = async function(t, e) {
  let r = await Nl(t, this);
  return r.type === "event" && e && e.length > 0 && e[0].removed === !0 && (r = await Nl({ orphan: "drop-log", log: e[0] }, this)), A(this, ze).get(r.tag) || null;
}, nf = async function(t) {
  const e = await Nl(t, this), r = e.tag;
  let s = A(this, ze).get(r);
  return s || (s = { subscriber: this._getSubscriber(e), tag: r, addressableMap: /* @__PURE__ */ new WeakMap(), nameMap: /* @__PURE__ */ new Map(), started: !1, listeners: [] }, A(this, ze).set(r, s)), s;
};
function ZP(n, t) {
  try {
    const e = Mh(n, t);
    if (e)
      return uf(e);
  } catch {
  }
  return null;
}
function Mh(n, t) {
  if (n === "0x")
    return null;
  try {
    const e = Ft(ae(n, t, t + 32)), r = Ft(ae(n, e, e + 32));
    return ae(n, e + 32, e + 32 + r);
  } catch {
  }
  return null;
}
function Bd(n) {
  const t = Ne(n);
  if (t.length > 32)
    throw new Error("internal; should not happen");
  const e = new Uint8Array(32);
  return e.set(t, 32 - t.length), e;
}
function XP(n) {
  if (n.length % 32 === 0)
    return n;
  const t = new Uint8Array(Math.ceil(n.length / 32) * 32);
  return t.set(n), t;
}
const tz = new Uint8Array([]);
function ez(n) {
  const t = [];
  let e = 0;
  for (let r = 0; r < n.length; r++)
    t.push(tz), e += 32;
  for (let r = 0; r < n.length; r++) {
    const s = Vt(n[r]);
    t[r] = Bd(e), t.push(Bd(s.length)), t.push(XP(s)), e += 32 + Math.ceil(s.length / 32) * 32;
  }
  return pe(t);
}
const Cd = "0x0000000000000000000000000000000000000000000000000000000000000000";
function rz(n) {
  const t = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  ht(Pa(n) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const e = ae(n, 0, 32);
  ht(ae(e, 0, 12) === ae(Cd, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  }), t.sender = ae(e, 12);
  try {
    const r = [], s = Ft(ae(n, 32, 64)), _ = Ft(ae(n, s, s + 32)), a = ae(n, s + 32);
    for (let c = 0; c < _; c++) {
      const u = ZP(a, c * 32);
      if (u == null)
        throw new Error("abort");
      r.push(u);
    }
    t.urls = r;
  } catch {
    ht(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const r = Mh(n, 64);
    if (r == null)
      throw new Error("abort");
    t.calldata = r;
  } catch {
    ht(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  ht(ae(n, 100, 128) === ae(Cd, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  }), t.selector = ae(n, 96, 100);
  try {
    const r = Mh(n, 128);
    if (r == null)
      throw new Error("abort");
    t.extraData = r;
  } catch {
    ht(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  return t.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((r) => t[r]), t;
}
function k_(n, t) {
  if (n.provider)
    return n.provider;
  ht(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: t });
}
async function Id(n, t) {
  let e = bf(t);
  if (e.to != null && (e.to = ke(e.to, n)), e.from != null) {
    const r = e.from;
    e.from = Promise.all([
      n.getAddress(),
      ke(r, n)
    ]).then(([s, _]) => (W(s.toLowerCase() === _.toLowerCase(), "transaction from mismatch", "tx.from", _), s));
  } else
    e.from = n.getAddress();
  return await Ce(e);
}
class nz {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(t) {
    /**
     *  The provider this signer is connected to.
     */
    $(this, "provider");
    Bt(this, { provider: t || null });
  }
  async getNonce(t) {
    return k_(this, "getTransactionCount").getTransactionCount(await this.getAddress(), t);
  }
  async populateCall(t) {
    return await Id(this, t);
  }
  async populateTransaction(t) {
    const e = k_(this, "populateTransaction"), r = await Id(this, t);
    r.nonce == null && (r.nonce = await this.getNonce("pending")), r.gasLimit == null && (r.gasLimit = await this.estimateGas(r));
    const s = await this.provider.getNetwork();
    if (r.chainId != null) {
      const a = zt(r.chainId);
      W(a === s.chainId, "transaction chainId mismatch", "tx.chainId", t.chainId);
    } else
      r.chainId = s.chainId;
    const _ = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
    if (r.gasPrice != null && (r.type === 2 || _) ? W(!1, "eip-1559 transaction do not support gasPrice", "tx", t) : (r.type === 0 || r.type === 1) && _ && W(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", t), (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null)
      r.type = 2;
    else if (r.type === 0 || r.type === 1) {
      const a = await e.getFeeData();
      ht(a.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      }), r.gasPrice == null && (r.gasPrice = a.gasPrice);
    } else {
      const a = await e.getFeeData();
      if (r.type == null)
        if (a.maxFeePerGas != null && a.maxPriorityFeePerGas != null)
          if (r.type = 2, r.gasPrice != null) {
            const c = r.gasPrice;
            delete r.gasPrice, r.maxFeePerGas = c, r.maxPriorityFeePerGas = c;
          } else
            r.maxFeePerGas == null && (r.maxFeePerGas = a.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = a.maxPriorityFeePerGas);
        else a.gasPrice != null ? (ht(!_, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
          operation: "populateTransaction"
        }), r.gasPrice == null && (r.gasPrice = a.gasPrice), r.type = 0) : ht(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
          operation: "signer.getFeeData"
        });
      else (r.type === 2 || r.type === 3) && (r.maxFeePerGas == null && (r.maxFeePerGas = a.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = a.maxPriorityFeePerGas));
    }
    return await Ce(r);
  }
  async estimateGas(t) {
    return k_(this, "estimateGas").estimateGas(await this.populateCall(t));
  }
  async call(t) {
    return k_(this, "call").call(await this.populateCall(t));
  }
  async resolveName(t) {
    return await k_(this, "resolveName").resolveName(t);
  }
  async sendTransaction(t) {
    const e = k_(this, "sendTransaction"), r = await this.populateTransaction(t);
    delete r.from;
    const s = gf.from(r);
    return await e.broadcastTransaction(await this.signTransaction(s));
  }
}
function iz(n) {
  return JSON.parse(JSON.stringify(n));
}
var Be, Vr, w_, ms, d_, dc, Ms, xh, Bh;
class L2 {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(t) {
    nt(this, Ms);
    nt(this, Be);
    nt(this, Vr);
    nt(this, w_);
    nt(this, ms);
    nt(this, d_);
    nt(this, dc);
    K(this, Be, t), K(this, Vr, null), K(this, w_, At(this, Ms, xh).bind(this)), K(this, ms, !1), K(this, d_, null), K(this, dc, !1);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(t) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(t, e) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(t) {
    throw new Error("subclasses must override this");
  }
  start() {
    A(this, ms) || (K(this, ms, !0), At(this, Ms, xh).call(this, -2));
  }
  stop() {
    A(this, ms) && (K(this, ms, !1), K(this, dc, !0), At(this, Ms, Bh).call(this), A(this, Be).off("block", A(this, w_)));
  }
  pause(t) {
    t && At(this, Ms, Bh).call(this), A(this, Be).off("block", A(this, w_));
  }
  resume() {
    this.start();
  }
}
Be = new WeakMap(), Vr = new WeakMap(), w_ = new WeakMap(), ms = new WeakMap(), d_ = new WeakMap(), dc = new WeakMap(), Ms = new WeakSet(), xh = async function(t) {
  try {
    A(this, Vr) == null && K(this, Vr, this._subscribe(A(this, Be)));
    let e = null;
    try {
      e = await A(this, Vr);
    } catch (_) {
      if (!Re(_, "UNSUPPORTED_OPERATION") || _.operation !== "eth_newFilter")
        throw _;
    }
    if (e == null) {
      K(this, Vr, null), A(this, Be)._recoverSubscriber(this, this._recover(A(this, Be)));
      return;
    }
    const r = await A(this, Be).getNetwork();
    if (A(this, d_) || K(this, d_, r), A(this, d_).chainId !== r.chainId)
      throw new Error("chaid changed");
    if (A(this, dc))
      return;
    const s = await A(this, Be).send("eth_getFilterChanges", [e]);
    await this._emitResults(A(this, Be), s);
  } catch (e) {
    console.log("@TODO", e);
  }
  A(this, Be).once("block", A(this, w_));
}, Bh = function() {
  const t = A(this, Vr);
  t && (K(this, Vr, null), t.then((e) => {
    A(this, Be).destroyed || A(this, Be).send("eth_uninstallFilter", [e]);
  }));
};
var g_;
class sz extends L2 {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(e, r) {
    super(e);
    nt(this, g_);
    K(this, g_, iz(r));
  }
  _recover(e) {
    return new ow(e, A(this, g_));
  }
  async _subscribe(e) {
    return await e.send("eth_newFilter", [A(this, g_)]);
  }
  async _emitResults(e, r) {
    for (const s of r)
      e.emit(A(this, g_), e._wrapLog(s, e._network));
  }
}
g_ = new WeakMap();
class _z extends L2 {
  async _subscribe(t) {
    return await t.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(t, e) {
    for (const r of e)
      t.emit("pending", r);
  }
}
const oz = "bigint,boolean,function,number,string,symbol".split(/,/g);
function sf(n) {
  if (n == null || oz.indexOf(typeof n) >= 0 || typeof n.getAddress == "function")
    return n;
  if (Array.isArray(n))
    return n.map(sf);
  if (typeof n == "object")
    return Object.keys(n).reduce((t, e) => (t[e] = n[e], t), {});
  throw new Error(`should not happen: ${n} (${typeof n})`);
}
function az(n) {
  return new Promise((t) => {
    setTimeout(t, n);
  });
}
function T_(n) {
  return n && n.toLowerCase();
}
function Nd(n) {
  return n && typeof n.pollingInterval == "number";
}
const j2 = {
  polling: !1,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class kl extends nz {
  constructor(e, r) {
    super(e);
    $(this, "address");
    r = jt(r), Bt(this, { address: r });
  }
  connect(e) {
    ht(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(e) {
    return await this.populateCall(e);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(e) {
    const r = sf(e), s = [];
    if (r.from) {
      const a = r.from;
      s.push((async () => {
        const c = await ke(a, this.provider);
        W(c != null && c.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e), r.from = c;
      })());
    } else
      r.from = this.address;
    if (r.gasLimit == null && s.push((async () => {
      r.gasLimit = await this.provider.estimateGas({ ...r, from: this.address });
    })()), r.to != null) {
      const a = r.to;
      s.push((async () => {
        r.to = await ke(a, this.provider);
      })());
    }
    s.length && await Promise.all(s);
    const _ = this.provider.getRpcTransaction(r);
    return this.provider.send("eth_sendTransaction", [_]);
  }
  async sendTransaction(e) {
    const r = await this.provider.getBlockNumber(), s = await this.sendUncheckedTransaction(e);
    return await new Promise((_, a) => {
      const c = [1e3, 100];
      let u = 0;
      const l = async () => {
        try {
          const f = await this.provider.getTransaction(s);
          if (f != null) {
            _(f.replaceableTransaction(r));
            return;
          }
        } catch (f) {
          if (Re(f, "CANCELLED") || Re(f, "BAD_DATA") || Re(f, "NETWORK_ERROR") || Re(f, "UNSUPPORTED_OPERATION")) {
            f.info == null && (f.info = {}), f.info.sendTransactionHash = s, a(f);
            return;
          }
          if (Re(f, "INVALID_ARGUMENT") && (u++, f.info == null && (f.info = {}), f.info.sendTransactionHash = s, u > 10)) {
            a(f);
            return;
          }
          this.provider.emit("error", oe("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error: f }));
        }
        this.provider._setTimeout(() => {
          l();
        }, c.pop() || 4e3);
      };
      l();
    });
  }
  async signTransaction(e) {
    const r = sf(e);
    if (r.from) {
      const _ = await ke(r.from, this.provider);
      W(_ != null && _.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e), r.from = _;
    } else
      r.from = this.address;
    const s = this.provider.getRpcTransaction(r);
    return await this.provider.send("eth_signTransaction", [s]);
  }
  async signMessage(e) {
    const r = typeof e == "string" ? qi(e) : e;
    return await this.provider.send("personal_sign", [
      Rt(r),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(e, r, s) {
    const _ = sf(s), a = await cu.resolveNames(e, r, _, async (c) => {
      const u = await ke(c);
      return W(u != null, "TypedData does not support null address", "value", c), u;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(cu.getPayload(a.domain, r, a.value))
    ]);
  }
  async unlock(e) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      e,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(e) {
    const r = typeof e == "string" ? qi(e) : e;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      Rt(r)
    ]);
  }
}
var b_, gc, ji, Yr, mr, fr, Le, zu, Ch;
class cz extends $P {
  constructor(e, r) {
    super(e, r);
    nt(this, zu);
    nt(this, b_);
    // The next ID to use for the JSON-RPC ID field
    nt(this, gc);
    // Payloads are queued and triggered in batches using the drainTimer
    nt(this, ji);
    nt(this, Yr);
    nt(this, mr);
    nt(this, fr);
    nt(this, Le);
    K(this, gc, 1), K(this, b_, Object.assign({}, j2, r || {})), K(this, ji, []), K(this, Yr, null), K(this, fr, null), K(this, Le, null);
    {
      let _ = null;
      const a = new Promise((c) => {
        _ = c;
      });
      K(this, mr, { promise: a, resolve: _ });
    }
    const s = this._getOption("staticNetwork");
    typeof s == "boolean" ? (W(!s || e !== "any", "staticNetwork cannot be used on special network 'any'", "options", r), s && e != null && K(this, fr, Pi.from(e))) : s && (W(e == null || s.matches(e), "staticNetwork MUST match network object", "options", r), K(this, fr, s));
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(e) {
    return A(this, b_)[e];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    return ht(A(this, fr), "network is not available yet", "NETWORK_ERROR"), A(this, fr);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(e) {
    if (e.method === "call" || e.method === "estimateGas") {
      let s = e.transaction;
      if (s && s.type != null && zt(s.type) && s.maxFeePerGas == null && s.maxPriorityFeePerGas == null) {
        const _ = await this.getFeeData();
        _.maxFeePerGas == null && _.maxPriorityFeePerGas == null && (e = Object.assign({}, e, {
          transaction: Object.assign({}, s, { type: void 0 })
        }));
      }
    }
    const r = this.getRpcRequest(e);
    return r != null ? await this.send(r.method, r.args) : super._perform(e);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const e = this._getOption("staticNetwork");
    if (e)
      if (e === !0) {
        if (A(this, fr))
          return A(this, fr);
      } else
        return e;
    return A(this, Le) ? await A(this, Le) : this.ready ? (K(this, Le, (async () => {
      try {
        const r = Pi.from(zt(await this.send("eth_chainId", [])));
        return K(this, Le, null), r;
      } catch (r) {
        throw K(this, Le, null), r;
      }
    })()), await A(this, Le)) : (K(this, Le, (async () => {
      const r = {
        id: Fc(this, gc)._++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload: r });
      let s;
      try {
        s = (await this._send(r))[0], K(this, Le, null);
      } catch (_) {
        throw K(this, Le, null), this.emit("debug", { action: "receiveRpcError", error: _ }), _;
      }
      if (this.emit("debug", { action: "receiveRpcResult", result: s }), "result" in s)
        return Pi.from(zt(s.result));
      throw this.getRpcError(r, s);
    })()), await A(this, Le));
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    A(this, mr) == null || A(this, mr).resolve == null || (A(this, mr).resolve(), K(this, mr, null), (async () => {
      for (; A(this, fr) == null && !this.destroyed; )
        try {
          K(this, fr, await this._detectNetwork());
        } catch (e) {
          if (this.destroyed)
            break;
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"), this.emit("error", oe("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error: e } })), await az(1e3);
        }
      At(this, zu, Ch).call(this);
    })());
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (A(this, mr) != null)
      return await A(this, mr).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(e) {
    return e.type === "pending" ? new _z(this) : e.type === "event" ? this._getOption("polling") ? new ow(this, e.filter) : new sz(this, e.filter) : e.type === "orphan" && e.filter.orphan === "drop-log" ? new D2("orphan") : super._getSubscriber(e);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return A(this, mr) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(e) {
    const r = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((s) => {
      if (e[s] == null)
        return;
      let _ = s;
      s === "gasLimit" && (_ = "gas"), r[_] = L_(zt(e[s], `tx.${s}`));
    }), ["from", "to", "data"].forEach((s) => {
      e[s] != null && (r[s] = Rt(e[s]));
    }), e.accessList && (r.accessList = C_(e.accessList)), e.blobVersionedHashes && (r.blobVersionedHashes = e.blobVersionedHashes.map((s) => s.toLowerCase())), r;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(e) {
    switch (e.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [T_(e.address), e.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [T_(e.address), e.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [T_(e.address), e.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            T_(e.address),
            "0x" + e.position.toString(16),
            e.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [e.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in e)
          return {
            method: "eth_getBlockByNumber",
            args: [e.blockTag, !!e.includeTransactions]
          };
        if ("blockHash" in e)
          return {
            method: "eth_getBlockByHash",
            args: [e.blockHash, !!e.includeTransactions]
          };
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [e.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [e.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(e.transaction), e.blockTag]
        };
      case "estimateGas":
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(e.transaction)]
        };
      case "getLogs":
        return e.filter && e.filter.address != null && (Array.isArray(e.filter.address) ? e.filter.address = e.filter.address.map(T_) : e.filter.address = T_(e.filter.address)), { method: "eth_getLogs", args: [e.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(e, r) {
    const { method: s } = e, { error: _ } = r;
    if (s === "eth_estimateGas" && _.message) {
      const u = _.message;
      if (!u.match(/revert/i) && u.match(/insufficient funds/i))
        return oe("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: e.params[0],
          info: { payload: e, error: _ }
        });
    }
    if (s === "eth_call" || s === "eth_estimateGas") {
      const u = Ih(_), l = Mc.getBuiltinCallException(s === "eth_call" ? "call" : "estimateGas", e.params[0], u ? u.data : null);
      return l.info = { error: _, payload: e }, l;
    }
    const a = JSON.stringify(fz(_));
    if (typeof _.message == "string" && _.message.match(/user denied|ethers-user-denied/i))
      return oe("user rejected action", "ACTION_REJECTED", {
        action: {
          eth_sign: "signMessage",
          personal_sign: "signMessage",
          eth_signTypedData_v4: "signTypedData",
          eth_signTransaction: "signTransaction",
          eth_sendTransaction: "sendTransaction",
          eth_requestAccounts: "requestAccess",
          wallet_requestAccounts: "requestAccess"
        }[s] || "unknown",
        reason: "rejected",
        info: { payload: e, error: _ }
      });
    if (s === "eth_sendRawTransaction" || s === "eth_sendTransaction") {
      const u = e.params[0];
      if (a.match(/insufficient funds|base fee exceeds gas limit/i))
        return oe("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction: u,
          info: { error: _ }
        });
      if (a.match(/nonce/i) && a.match(/too low/i))
        return oe("nonce has already been used", "NONCE_EXPIRED", { transaction: u, info: { error: _ } });
      if (a.match(/replacement transaction/i) && a.match(/underpriced/i))
        return oe("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction: u, info: { error: _ } });
      if (a.match(/only replay-protected/i))
        return oe("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: s,
          info: { transaction: u, info: { error: _ } }
        });
    }
    let c = !!a.match(/the method .* does not exist/i);
    return c || _ && _.details && _.details.startsWith("Unauthorized method:") && (c = !0), c ? oe("unsupported operation", "UNSUPPORTED_OPERATION", {
      operation: e.method,
      info: { error: _, payload: e }
    }) : oe("could not coalesce error", "UNKNOWN_ERROR", { error: _, payload: e });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(e, r) {
    if (this.destroyed)
      return Promise.reject(oe("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: e }));
    const s = Fc(this, gc)._++, _ = new Promise((a, c) => {
      A(this, ji).push({
        resolve: a,
        reject: c,
        payload: { method: e, params: r, id: s, jsonrpc: "2.0" }
      });
    });
    return At(this, zu, Ch).call(this), _;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(e) {
    e == null && (e = 0);
    const r = this.send("eth_accounts", []);
    if (typeof e == "number") {
      const _ = await r;
      if (e >= _.length)
        throw new Error("no such account");
      return new kl(this, _[e]);
    }
    const { accounts: s } = await Ce({
      network: this.getNetwork(),
      accounts: r
    });
    e = jt(e);
    for (const _ of s)
      if (jt(_) === e)
        return new kl(this, e);
    throw new Error("invalid account");
  }
  async listAccounts() {
    return (await this.send("eth_accounts", [])).map((r) => new kl(this, r));
  }
  destroy() {
    A(this, Yr) && (clearTimeout(A(this, Yr)), K(this, Yr, null));
    for (const { payload: e, reject: r } of A(this, ji))
      r(oe("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: e.method }));
    K(this, ji, []), super.destroy();
  }
}
b_ = new WeakMap(), gc = new WeakMap(), ji = new WeakMap(), Yr = new WeakMap(), mr = new WeakMap(), fr = new WeakMap(), Le = new WeakMap(), zu = new WeakSet(), Ch = function() {
  if (A(this, Yr))
    return;
  const e = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  K(this, Yr, setTimeout(() => {
    K(this, Yr, null);
    const r = A(this, ji);
    for (K(this, ji, []); r.length; ) {
      const s = [r.shift()];
      for (; r.length && s.length !== A(this, b_).batchMaxCount; )
        if (s.push(r.shift()), JSON.stringify(s.map((a) => a.payload)).length > A(this, b_).batchMaxSize) {
          r.unshift(s.pop());
          break;
        }
      (async () => {
        const _ = s.length === 1 ? s[0].payload : s.map((a) => a.payload);
        this.emit("debug", { action: "sendRpcPayload", payload: _ });
        try {
          const a = await this._send(_);
          this.emit("debug", { action: "receiveRpcResult", result: a });
          for (const { resolve: c, reject: u, payload: l } of s) {
            if (this.destroyed) {
              u(oe("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: l.method }));
              continue;
            }
            const f = a.filter((w) => w.id === l.id)[0];
            if (f == null) {
              const w = oe("missing response for request", "BAD_DATA", {
                value: a,
                info: { payload: l }
              });
              this.emit("error", w), u(w);
              continue;
            }
            if ("error" in f) {
              u(this.getRpcError(l, f));
              continue;
            }
            c(f.result);
          }
        } catch (a) {
          this.emit("debug", { action: "receiveRpcError", error: a });
          for (const { reject: c } of s)
            c(a);
        }
      })();
    }
  }, e));
};
var Ss;
class V2 extends cz {
  constructor(e, r) {
    super(e, r);
    nt(this, Ss);
    let s = this._getOption("pollingInterval");
    s == null && (s = j2.pollingInterval), K(this, Ss, s);
  }
  _getSubscriber(e) {
    const r = super._getSubscriber(e);
    return Nd(r) && (r.pollingInterval = A(this, Ss)), r;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return A(this, Ss);
  }
  set pollingInterval(e) {
    if (!Number.isInteger(e) || e < 0)
      throw new Error("invalid interval");
    K(this, Ss, e), this._forEachSubscriber((r) => {
      Nd(r) && (r.pollingInterval = A(this, Ss));
    });
  }
}
Ss = new WeakMap();
var bc;
class uz extends V2 {
  constructor(e, r, s) {
    e == null && (e = "http://localhost:8545");
    super(r, s);
    nt(this, bc);
    typeof e == "string" ? K(this, bc, new Wi(e)) : K(this, bc, e.clone());
  }
  _getConnection() {
    return A(this, bc).clone();
  }
  async send(e, r) {
    return await this._start(), await super.send(e, r);
  }
  async _send(e) {
    const r = this._getConnection();
    r.body = JSON.stringify(e), r.setHeader("content-type", "application/json");
    const s = await r.send();
    s.assertOk();
    let _ = s.bodyJson;
    return Array.isArray(_) || (_ = [_]), _;
  }
}
bc = new WeakMap();
function Ih(n) {
  if (n == null)
    return null;
  if (typeof n.message == "string" && n.message.match(/revert/i) && ee(n.data))
    return { message: n.message, data: n.data };
  if (typeof n == "object") {
    for (const t in n) {
      const e = Ih(n[t]);
      if (e)
        return e;
    }
    return null;
  }
  if (typeof n == "string")
    try {
      return Ih(JSON.parse(n));
    } catch {
    }
  return null;
}
function Nh(n, t) {
  if (n != null) {
    if (typeof n.message == "string" && t.push(n.message), typeof n == "object")
      for (const e in n)
        Nh(n[e], t);
    if (typeof n == "string")
      try {
        return Nh(JSON.parse(n), t);
      } catch {
      }
  }
}
function fz(n) {
  const t = [];
  return Nh(n, t), t;
}
var yc;
class lz extends V2 {
  /**
   *  Connnect to the %%ethereum%% provider, optionally forcing the
   *  %%network%%.
   */
  constructor(e, r, s) {
    const _ = Object.assign({}, s ?? {}, { batchMaxCount: 1 });
    W(e && e.request, "invalid EIP-1193 provider", "ethereum", e);
    super(r, _);
    nt(this, yc);
    K(this, yc, async (a, c) => {
      const u = { method: a, params: c };
      this.emit("debug", { action: "sendEip1193Request", payload: u });
      try {
        const l = await e.request(u);
        return this.emit("debug", { action: "receiveEip1193Result", result: l }), l;
      } catch (l) {
        const f = new Error(l.message);
        throw f.code = l.code, f.data = l.data, f.payload = u, this.emit("debug", { action: "receiveEip1193Error", error: f }), f;
      }
    });
  }
  async send(e, r) {
    return await this._start(), await super.send(e, r);
  }
  async _send(e) {
    W(!Array.isArray(e), "EIP-1193 does not support batch request", "payload", e);
    try {
      const r = await A(this, yc).call(this, e.method, e.params || []);
      return [{ id: e.id, result: r }];
    } catch (r) {
      return [{
        id: e.id,
        error: { code: r.code, data: r.data, message: r.message }
      }];
    }
  }
  getRpcError(e, r) {
    switch (r = JSON.parse(JSON.stringify(r)), r.error.code || -1) {
      case 4001:
        r.error.message = `ethers-user-denied: ${r.error.message}`;
        break;
      case 4200:
        r.error.message = `ethers-unsupported: ${r.error.message}`;
        break;
    }
    return super.getRpcError(e, r);
  }
  /**
   *  Resolves to ``true`` if the provider manages the %%address%%.
   */
  async hasSigner(e) {
    e == null && (e = 0);
    const r = await this.send("eth_accounts", []);
    return typeof e == "number" ? r.length > e : (e = e.toLowerCase(), r.filter((s) => s.toLowerCase() === e).length !== 0);
  }
  async getSigner(e) {
    if (e == null && (e = 0), !await this.hasSigner(e))
      try {
        await A(this, yc).call(this, "eth_requestAccounts", []);
      } catch (r) {
        const s = r.payload;
        throw this.getRpcError(s, { id: s.id, error: r });
      }
    return await super.getSigner(e);
  }
}
yc = new WeakMap();
var vs = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Y2(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var Vu = { exports: {} };
function pz(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var H2 = { exports: {} }, he = H2.exports = {}, Or, kr;
function Oh() {
  throw new Error("setTimeout has not been defined");
}
function kh() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Or = setTimeout : Or = Oh;
  } catch {
    Or = Oh;
  }
  try {
    typeof clearTimeout == "function" ? kr = clearTimeout : kr = kh;
  } catch {
    kr = kh;
  }
})();
function q2(n) {
  if (Or === setTimeout)
    return setTimeout(n, 0);
  if ((Or === Oh || !Or) && setTimeout)
    return Or = setTimeout, setTimeout(n, 0);
  try {
    return Or(n, 0);
  } catch {
    try {
      return Or.call(null, n, 0);
    } catch {
      return Or.call(this, n, 0);
    }
  }
}
function hz(n) {
  if (kr === clearTimeout)
    return clearTimeout(n);
  if ((kr === kh || !kr) && clearTimeout)
    return kr = clearTimeout, clearTimeout(n);
  try {
    return kr(n);
  } catch {
    try {
      return kr.call(null, n);
    } catch {
      return kr.call(this, n);
    }
  }
}
var Hi = [], Ma = !1, Ys, _f = -1;
function wz() {
  !Ma || !Ys || (Ma = !1, Ys.length ? Hi = Ys.concat(Hi) : _f = -1, Hi.length && Q2());
}
function Q2() {
  if (!Ma) {
    var n = q2(wz);
    Ma = !0;
    for (var t = Hi.length; t; ) {
      for (Ys = Hi, Hi = []; ++_f < t; )
        Ys && Ys[_f].run();
      _f = -1, t = Hi.length;
    }
    Ys = null, Ma = !1, hz(n);
  }
}
he.nextTick = function(n) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var e = 1; e < arguments.length; e++)
      t[e - 1] = arguments[e];
  Hi.push(new W2(n, t)), Hi.length === 1 && !Ma && q2(Q2);
};
function W2(n, t) {
  this.fun = n, this.array = t;
}
W2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
he.title = "browser";
he.browser = !0;
he.env = {};
he.argv = [];
he.version = "";
he.versions = {};
function Zi() {
}
he.on = Zi;
he.addListener = Zi;
he.once = Zi;
he.off = Zi;
he.removeListener = Zi;
he.removeAllListeners = Zi;
he.emit = Zi;
he.prependListener = Zi;
he.prependOnceListener = Zi;
he.listeners = function(n) {
  return [];
};
he.binding = function(n) {
  throw new Error("process.binding is not supported");
};
he.cwd = function() {
  return "/";
};
he.chdir = function(n) {
  throw new Error("process.chdir is not supported");
};
he.umask = function() {
  return 0;
};
var dz = H2.exports;
const Kt = /* @__PURE__ */ pz(dz);
var Yu = { exports: {} }, Od;
function J2() {
  if (Od) return Yu.exports;
  Od = 1;
  var n = typeof Reflect == "object" ? Reflect : null, t = n && typeof n.apply == "function" ? n.apply : function(G, D, j) {
    return Function.prototype.apply.call(G, D, j);
  }, e;
  n && typeof n.ownKeys == "function" ? e = n.ownKeys : Object.getOwnPropertySymbols ? e = function(G) {
    return Object.getOwnPropertyNames(G).concat(Object.getOwnPropertySymbols(G));
  } : e = function(G) {
    return Object.getOwnPropertyNames(G);
  };
  function r(I) {
    console && console.warn && console.warn(I);
  }
  var s = Number.isNaN || function(G) {
    return G !== G;
  };
  function _() {
    _.init.call(this);
  }
  Yu.exports = _, Yu.exports.once = z, _.EventEmitter = _, _.prototype._events = void 0, _.prototype._eventsCount = 0, _.prototype._maxListeners = void 0;
  var a = 10;
  function c(I) {
    if (typeof I != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof I);
  }
  Object.defineProperty(_, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return a;
    },
    set: function(I) {
      if (typeof I != "number" || I < 0 || s(I))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + I + ".");
      a = I;
    }
  }), _.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, _.prototype.setMaxListeners = function(G) {
    if (typeof G != "number" || G < 0 || s(G))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + G + ".");
    return this._maxListeners = G, this;
  };
  function u(I) {
    return I._maxListeners === void 0 ? _.defaultMaxListeners : I._maxListeners;
  }
  _.prototype.getMaxListeners = function() {
    return u(this);
  }, _.prototype.emit = function(G) {
    for (var D = [], j = 1; j < arguments.length; j++) D.push(arguments[j]);
    var L = G === "error", X = this._events;
    if (X !== void 0)
      L = L && X.error === void 0;
    else if (!L)
      return !1;
    if (L) {
      var et;
      if (D.length > 0 && (et = D[0]), et instanceof Error)
        throw et;
      var lt = new Error("Unhandled error." + (et ? " (" + et.message + ")" : ""));
      throw lt.context = et, lt;
    }
    var Y = X[G];
    if (Y === void 0)
      return !1;
    if (typeof Y == "function")
      t(Y, this, D);
    else
      for (var Et = Y.length, Ct = x(Y, Et), j = 0; j < Et; ++j)
        t(Ct[j], this, D);
    return !0;
  };
  function l(I, G, D, j) {
    var L, X, et;
    if (c(D), X = I._events, X === void 0 ? (X = I._events = /* @__PURE__ */ Object.create(null), I._eventsCount = 0) : (X.newListener !== void 0 && (I.emit(
      "newListener",
      G,
      D.listener ? D.listener : D
    ), X = I._events), et = X[G]), et === void 0)
      et = X[G] = D, ++I._eventsCount;
    else if (typeof et == "function" ? et = X[G] = j ? [D, et] : [et, D] : j ? et.unshift(D) : et.push(D), L = u(I), L > 0 && et.length > L && !et.warned) {
      et.warned = !0;
      var lt = new Error("Possible EventEmitter memory leak detected. " + et.length + " " + String(G) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      lt.name = "MaxListenersExceededWarning", lt.emitter = I, lt.type = G, lt.count = et.length, r(lt);
    }
    return I;
  }
  _.prototype.addListener = function(G, D) {
    return l(this, G, D, !1);
  }, _.prototype.on = _.prototype.addListener, _.prototype.prependListener = function(G, D) {
    return l(this, G, D, !0);
  };
  function f() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function w(I, G, D) {
    var j = { fired: !1, wrapFn: void 0, target: I, type: G, listener: D }, L = f.bind(j);
    return L.listener = D, j.wrapFn = L, L;
  }
  _.prototype.once = function(G, D) {
    return c(D), this.on(G, w(this, G, D)), this;
  }, _.prototype.prependOnceListener = function(G, D) {
    return c(D), this.prependListener(G, w(this, G, D)), this;
  }, _.prototype.removeListener = function(G, D) {
    var j, L, X, et, lt;
    if (c(D), L = this._events, L === void 0)
      return this;
    if (j = L[G], j === void 0)
      return this;
    if (j === D || j.listener === D)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete L[G], L.removeListener && this.emit("removeListener", G, j.listener || D));
    else if (typeof j != "function") {
      for (X = -1, et = j.length - 1; et >= 0; et--)
        if (j[et] === D || j[et].listener === D) {
          lt = j[et].listener, X = et;
          break;
        }
      if (X < 0)
        return this;
      X === 0 ? j.shift() : C(j, X), j.length === 1 && (L[G] = j[0]), L.removeListener !== void 0 && this.emit("removeListener", G, lt || D);
    }
    return this;
  }, _.prototype.off = _.prototype.removeListener, _.prototype.removeAllListeners = function(G) {
    var D, j, L;
    if (j = this._events, j === void 0)
      return this;
    if (j.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : j[G] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete j[G]), this;
    if (arguments.length === 0) {
      var X = Object.keys(j), et;
      for (L = 0; L < X.length; ++L)
        et = X[L], et !== "removeListener" && this.removeAllListeners(et);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (D = j[G], typeof D == "function")
      this.removeListener(G, D);
    else if (D !== void 0)
      for (L = D.length - 1; L >= 0; L--)
        this.removeListener(G, D[L]);
    return this;
  };
  function y(I, G, D) {
    var j = I._events;
    if (j === void 0)
      return [];
    var L = j[G];
    return L === void 0 ? [] : typeof L == "function" ? D ? [L.listener || L] : [L] : D ? U(L) : x(L, L.length);
  }
  _.prototype.listeners = function(G) {
    return y(this, G, !0);
  }, _.prototype.rawListeners = function(G) {
    return y(this, G, !1);
  }, _.listenerCount = function(I, G) {
    return typeof I.listenerCount == "function" ? I.listenerCount(G) : v.call(I, G);
  }, _.prototype.listenerCount = v;
  function v(I) {
    var G = this._events;
    if (G !== void 0) {
      var D = G[I];
      if (typeof D == "function")
        return 1;
      if (D !== void 0)
        return D.length;
    }
    return 0;
  }
  _.prototype.eventNames = function() {
    return this._eventsCount > 0 ? e(this._events) : [];
  };
  function x(I, G) {
    for (var D = new Array(G), j = 0; j < G; ++j)
      D[j] = I[j];
    return D;
  }
  function C(I, G) {
    for (; G + 1 < I.length; G++)
      I[G] = I[G + 1];
    I.pop();
  }
  function U(I) {
    for (var G = new Array(I.length), D = 0; D < G.length; ++D)
      G[D] = I[D].listener || I[D];
    return G;
  }
  function z(I, G) {
    return new Promise(function(D, j) {
      function L(et) {
        I.removeListener(G, X), j(et);
      }
      function X() {
        typeof I.removeListener == "function" && I.removeListener("error", L), D([].slice.call(arguments));
      }
      N(I, G, X, { once: !0 }), G !== "error" && M(I, L, { once: !0 });
    });
  }
  function M(I, G, D) {
    typeof I.on == "function" && N(I, "error", G, D);
  }
  function N(I, G, D, j) {
    if (typeof I.on == "function")
      j.once ? I.once(G, D) : I.on(G, D);
    else if (typeof I.addEventListener == "function")
      I.addEventListener(G, function L(X) {
        j.once && I.removeEventListener(G, L), D(X);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof I);
  }
  return Yu.exports;
}
var Tl, kd;
function $2() {
  return kd || (kd = 1, Tl = J2().EventEmitter), Tl;
}
var Gl = {}, Td;
function Hf() {
  return Td || (Td = 1, function(n) {
    Object.defineProperties(n, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } });
    var t = {}, e = {};
    e.byteLength = f, e.toByteArray = y, e.fromByteArray = C;
    for (var r = [], s = [], _ = typeof Uint8Array < "u" ? Uint8Array : Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", c = 0, u = a.length; c < u; ++c)
      r[c] = a[c], s[a.charCodeAt(c)] = c;
    s[45] = 62, s[95] = 63;
    function l(M) {
      var N = M.length;
      if (N % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var I = M.indexOf("=");
      I === -1 && (I = N);
      var G = I === N ? 0 : 4 - I % 4;
      return [I, G];
    }
    function f(M) {
      var N = l(M), I = N[0], G = N[1];
      return (I + G) * 3 / 4 - G;
    }
    function w(M, N, I) {
      return (N + I) * 3 / 4 - I;
    }
    function y(M) {
      var N, I = l(M), G = I[0], D = I[1], j = new _(w(M, G, D)), L = 0, X = D > 0 ? G - 4 : G, et;
      for (et = 0; et < X; et += 4)
        N = s[M.charCodeAt(et)] << 18 | s[M.charCodeAt(et + 1)] << 12 | s[M.charCodeAt(et + 2)] << 6 | s[M.charCodeAt(et + 3)], j[L++] = N >> 16 & 255, j[L++] = N >> 8 & 255, j[L++] = N & 255;
      return D === 2 && (N = s[M.charCodeAt(et)] << 2 | s[M.charCodeAt(et + 1)] >> 4, j[L++] = N & 255), D === 1 && (N = s[M.charCodeAt(et)] << 10 | s[M.charCodeAt(et + 1)] << 4 | s[M.charCodeAt(et + 2)] >> 2, j[L++] = N >> 8 & 255, j[L++] = N & 255), j;
    }
    function v(M) {
      return r[M >> 18 & 63] + r[M >> 12 & 63] + r[M >> 6 & 63] + r[M & 63];
    }
    function x(M, N, I) {
      for (var G, D = [], j = N; j < I; j += 3)
        G = (M[j] << 16 & 16711680) + (M[j + 1] << 8 & 65280) + (M[j + 2] & 255), D.push(v(G));
      return D.join("");
    }
    function C(M) {
      for (var N, I = M.length, G = I % 3, D = [], j = 16383, L = 0, X = I - G; L < X; L += j)
        D.push(x(M, L, L + j > X ? X : L + j));
      return G === 1 ? (N = M[I - 1], D.push(
        r[N >> 2] + r[N << 4 & 63] + "=="
      )) : G === 2 && (N = (M[I - 2] << 8) + M[I - 1], D.push(
        r[N >> 10] + r[N >> 4 & 63] + r[N << 2 & 63] + "="
      )), D.join("");
    }
    var U = {};
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    U.read = function(M, N, I, G, D) {
      var j, L, X = D * 8 - G - 1, et = (1 << X) - 1, lt = et >> 1, Y = -7, Et = I ? D - 1 : 0, Ct = I ? -1 : 1, pt = M[N + Et];
      for (Et += Ct, j = pt & (1 << -Y) - 1, pt >>= -Y, Y += X; Y > 0; j = j * 256 + M[N + Et], Et += Ct, Y -= 8)
        ;
      for (L = j & (1 << -Y) - 1, j >>= -Y, Y += G; Y > 0; L = L * 256 + M[N + Et], Et += Ct, Y -= 8)
        ;
      if (j === 0)
        j = 1 - lt;
      else {
        if (j === et)
          return L ? NaN : (pt ? -1 : 1) * (1 / 0);
        L = L + Math.pow(2, G), j = j - lt;
      }
      return (pt ? -1 : 1) * L * Math.pow(2, j - G);
    }, U.write = function(M, N, I, G, D, j) {
      var L, X, et, lt = j * 8 - D - 1, Y = (1 << lt) - 1, Et = Y >> 1, Ct = D === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, pt = G ? 0 : j - 1, wt = G ? 1 : -1, Pt = N < 0 || N === 0 && 1 / N < 0 ? 1 : 0;
      for (N = Math.abs(N), isNaN(N) || N === 1 / 0 ? (X = isNaN(N) ? 1 : 0, L = Y) : (L = Math.floor(Math.log(N) / Math.LN2), N * (et = Math.pow(2, -L)) < 1 && (L--, et *= 2), L + Et >= 1 ? N += Ct / et : N += Ct * Math.pow(2, 1 - Et), N * et >= 2 && (L++, et /= 2), L + Et >= Y ? (X = 0, L = Y) : L + Et >= 1 ? (X = (N * et - 1) * Math.pow(2, D), L = L + Et) : (X = N * Math.pow(2, Et - 1) * Math.pow(2, D), L = 0)); D >= 8; M[I + pt] = X & 255, pt += wt, X /= 256, D -= 8)
        ;
      for (L = L << D | X, lt += D; lt > 0; M[I + pt] = L & 255, pt += wt, L /= 256, lt -= 8)
        ;
      M[I + pt - wt] |= Pt * 128;
    };
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    (function(M) {
      const N = e, I = U, G = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
      M.Buffer = Y, M.SlowBuffer = st, M.INSPECT_MAX_BYTES = 50;
      const D = 2147483647;
      M.kMaxLength = D;
      const { Uint8Array: j, ArrayBuffer: L, SharedArrayBuffer: X } = globalThis;
      Y.TYPED_ARRAY_SUPPORT = et(), !Y.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
      function et() {
        try {
          const P = new j(1), h = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(h, j.prototype), Object.setPrototypeOf(P, h), P.foo() === 42;
        } catch {
          return !1;
        }
      }
      Object.defineProperty(Y.prototype, "parent", {
        enumerable: !0,
        get: function() {
          if (Y.isBuffer(this))
            return this.buffer;
        }
      }), Object.defineProperty(Y.prototype, "offset", {
        enumerable: !0,
        get: function() {
          if (Y.isBuffer(this))
            return this.byteOffset;
        }
      });
      function lt(P) {
        if (P > D)
          throw new RangeError('The value "' + P + '" is invalid for option "size"');
        const h = new j(P);
        return Object.setPrototypeOf(h, Y.prototype), h;
      }
      function Y(P, h, g) {
        if (typeof P == "number") {
          if (typeof h == "string")
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          return wt(P);
        }
        return Et(P, h, g);
      }
      Y.poolSize = 8192;
      function Et(P, h, g) {
        if (typeof P == "string")
          return Pt(P, h);
        if (L.isView(P))
          return xt(P);
        if (P == null)
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof P
          );
        if (Ke(P, L) || P && Ke(P.buffer, L) || typeof X < "u" && (Ke(P, X) || P && Ke(P.buffer, X)))
          return Nt(P, h, g);
        if (typeof P == "number")
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        const T = P.valueOf && P.valueOf();
        if (T != null && T !== P)
          return Y.from(T, h, g);
        const Q = Ht(P);
        if (Q) return Q;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof P[Symbol.toPrimitive] == "function")
          return Y.from(P[Symbol.toPrimitive]("string"), h, g);
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof P
        );
      }
      Y.from = function(P, h, g) {
        return Et(P, h, g);
      }, Object.setPrototypeOf(Y.prototype, j.prototype), Object.setPrototypeOf(Y, j);
      function Ct(P) {
        if (typeof P != "number")
          throw new TypeError('"size" argument must be of type number');
        if (P < 0)
          throw new RangeError('The value "' + P + '" is invalid for option "size"');
      }
      function pt(P, h, g) {
        return Ct(P), P <= 0 ? lt(P) : h !== void 0 ? typeof g == "string" ? lt(P).fill(h, g) : lt(P).fill(h) : lt(P);
      }
      Y.alloc = function(P, h, g) {
        return pt(P, h, g);
      };
      function wt(P) {
        return Ct(P), lt(P < 0 ? 0 : J(P) | 0);
      }
      Y.allocUnsafe = function(P) {
        return wt(P);
      }, Y.allocUnsafeSlow = function(P) {
        return wt(P);
      };
      function Pt(P, h) {
        if ((typeof h != "string" || h === "") && (h = "utf8"), !Y.isEncoding(h))
          throw new TypeError("Unknown encoding: " + h);
        const g = _t(P, h) | 0;
        let T = lt(g);
        const Q = T.write(P, h);
        return Q !== g && (T = T.slice(0, Q)), T;
      }
      function Mt(P) {
        const h = P.length < 0 ? 0 : J(P.length) | 0, g = lt(h);
        for (let T = 0; T < h; T += 1)
          g[T] = P[T] & 255;
        return g;
      }
      function xt(P) {
        if (Ke(P, j)) {
          const h = new j(P);
          return Nt(h.buffer, h.byteOffset, h.byteLength);
        }
        return Mt(P);
      }
      function Nt(P, h, g) {
        if (h < 0 || P.byteLength < h)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (P.byteLength < h + (g || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        let T;
        return h === void 0 && g === void 0 ? T = new j(P) : g === void 0 ? T = new j(P, h) : T = new j(P, h, g), Object.setPrototypeOf(T, Y.prototype), T;
      }
      function Ht(P) {
        if (Y.isBuffer(P)) {
          const h = J(P.length) | 0, g = lt(h);
          return g.length === 0 || P.copy(g, 0, 0, h), g;
        }
        if (P.length !== void 0)
          return typeof P.length != "number" || Bs(P.length) ? lt(0) : Mt(P);
        if (P.type === "Buffer" && Array.isArray(P.data))
          return Mt(P.data);
      }
      function J(P) {
        if (P >= D)
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + D.toString(16) + " bytes");
        return P | 0;
      }
      function st(P) {
        return +P != P && (P = 0), Y.alloc(+P);
      }
      Y.isBuffer = function(h) {
        return h != null && h._isBuffer === !0 && h !== Y.prototype;
      }, Y.compare = function(h, g) {
        if (Ke(h, j) && (h = Y.from(h, h.offset, h.byteLength)), Ke(g, j) && (g = Y.from(g, g.offset, g.byteLength)), !Y.isBuffer(h) || !Y.isBuffer(g))
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        if (h === g) return 0;
        let T = h.length, Q = g.length;
        for (let rt = 0, ft = Math.min(T, Q); rt < ft; ++rt)
          if (h[rt] !== g[rt]) {
            T = h[rt], Q = g[rt];
            break;
          }
        return T < Q ? -1 : Q < T ? 1 : 0;
      }, Y.isEncoding = function(h) {
        switch (String(h).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1;
        }
      }, Y.concat = function(h, g) {
        if (!Array.isArray(h))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (h.length === 0)
          return Y.alloc(0);
        let T;
        if (g === void 0)
          for (g = 0, T = 0; T < h.length; ++T)
            g += h[T].length;
        const Q = Y.allocUnsafe(g);
        let rt = 0;
        for (T = 0; T < h.length; ++T) {
          let ft = h[T];
          if (Ke(ft, j))
            rt + ft.length > Q.length ? (Y.isBuffer(ft) || (ft = Y.from(ft)), ft.copy(Q, rt)) : j.prototype.set.call(
              Q,
              ft,
              rt
            );
          else if (Y.isBuffer(ft))
            ft.copy(Q, rt);
          else
            throw new TypeError('"list" argument must be an Array of Buffers');
          rt += ft.length;
        }
        return Q;
      };
      function _t(P, h) {
        if (Y.isBuffer(P))
          return P.length;
        if (L.isView(P) || Ke(P, L))
          return P.byteLength;
        if (typeof P != "string")
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof P
          );
        const g = P.length, T = arguments.length > 2 && arguments[2] === !0;
        if (!T && g === 0) return 0;
        let Q = !1;
        for (; ; )
          switch (h) {
            case "ascii":
            case "latin1":
            case "binary":
              return g;
            case "utf8":
            case "utf-8":
              return Qt(P).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return g * 2;
            case "hex":
              return g >>> 1;
            case "base64":
              return Dt(P).length;
            default:
              if (Q)
                return T ? -1 : Qt(P).length;
              h = ("" + h).toLowerCase(), Q = !0;
          }
      }
      Y.byteLength = _t;
      function mt(P, h, g) {
        let T = !1;
        if ((h === void 0 || h < 0) && (h = 0), h > this.length || ((g === void 0 || g > this.length) && (g = this.length), g <= 0) || (g >>>= 0, h >>>= 0, g <= h))
          return "";
        for (P || (P = "utf8"); ; )
          switch (P) {
            case "hex":
              return ge(this, h, g);
            case "utf8":
            case "utf-8":
              return Ot(this, h, g);
            case "ascii":
              return re(this, h, g);
            case "latin1":
            case "binary":
              return at(this, h, g);
            case "base64":
              return gt(this, h, g);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return Ge(this, h, g);
            default:
              if (T) throw new TypeError("Unknown encoding: " + P);
              P = (P + "").toLowerCase(), T = !0;
          }
      }
      Y.prototype._isBuffer = !0;
      function H(P, h, g) {
        const T = P[h];
        P[h] = P[g], P[g] = T;
      }
      Y.prototype.swap16 = function() {
        const h = this.length;
        if (h % 2 !== 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let g = 0; g < h; g += 2)
          H(this, g, g + 1);
        return this;
      }, Y.prototype.swap32 = function() {
        const h = this.length;
        if (h % 4 !== 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let g = 0; g < h; g += 4)
          H(this, g, g + 3), H(this, g + 1, g + 2);
        return this;
      }, Y.prototype.swap64 = function() {
        const h = this.length;
        if (h % 8 !== 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let g = 0; g < h; g += 8)
          H(this, g, g + 7), H(this, g + 1, g + 6), H(this, g + 2, g + 5), H(this, g + 3, g + 4);
        return this;
      }, Y.prototype.toString = function() {
        const h = this.length;
        return h === 0 ? "" : arguments.length === 0 ? Ot(this, 0, h) : mt.apply(this, arguments);
      }, Y.prototype.toLocaleString = Y.prototype.toString, Y.prototype.equals = function(h) {
        if (!Y.isBuffer(h)) throw new TypeError("Argument must be a Buffer");
        return this === h ? !0 : Y.compare(this, h) === 0;
      }, Y.prototype.inspect = function() {
        let h = "";
        const g = M.INSPECT_MAX_BYTES;
        return h = this.toString("hex", 0, g).replace(/(.{2})/g, "$1 ").trim(), this.length > g && (h += " ... "), "<Buffer " + h + ">";
      }, G && (Y.prototype[G] = Y.prototype.inspect), Y.prototype.compare = function(h, g, T, Q, rt) {
        if (Ke(h, j) && (h = Y.from(h, h.offset, h.byteLength)), !Y.isBuffer(h))
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof h
          );
        if (g === void 0 && (g = 0), T === void 0 && (T = h ? h.length : 0), Q === void 0 && (Q = 0), rt === void 0 && (rt = this.length), g < 0 || T > h.length || Q < 0 || rt > this.length)
          throw new RangeError("out of range index");
        if (Q >= rt && g >= T)
          return 0;
        if (Q >= rt)
          return -1;
        if (g >= T)
          return 1;
        if (g >>>= 0, T >>>= 0, Q >>>= 0, rt >>>= 0, this === h) return 0;
        let ft = rt - Q, Tt = T - g;
        const Xt = Math.min(ft, Tt), $t = this.slice(Q, rt), te = h.slice(g, T);
        for (let qt = 0; qt < Xt; ++qt)
          if ($t[qt] !== te[qt]) {
            ft = $t[qt], Tt = te[qt];
            break;
          }
        return ft < Tt ? -1 : Tt < ft ? 1 : 0;
      };
      function V(P, h, g, T, Q) {
        if (P.length === 0) return -1;
        if (typeof g == "string" ? (T = g, g = 0) : g > 2147483647 ? g = 2147483647 : g < -2147483648 && (g = -2147483648), g = +g, Bs(g) && (g = Q ? 0 : P.length - 1), g < 0 && (g = P.length + g), g >= P.length) {
          if (Q) return -1;
          g = P.length - 1;
        } else if (g < 0)
          if (Q) g = 0;
          else return -1;
        if (typeof h == "string" && (h = Y.from(h, T)), Y.isBuffer(h))
          return h.length === 0 ? -1 : tt(P, h, g, T, Q);
        if (typeof h == "number")
          return h = h & 255, typeof j.prototype.indexOf == "function" ? Q ? j.prototype.indexOf.call(P, h, g) : j.prototype.lastIndexOf.call(P, h, g) : tt(P, [h], g, T, Q);
        throw new TypeError("val must be string, number or Buffer");
      }
      function tt(P, h, g, T, Q) {
        let rt = 1, ft = P.length, Tt = h.length;
        if (T !== void 0 && (T = String(T).toLowerCase(), T === "ucs2" || T === "ucs-2" || T === "utf16le" || T === "utf-16le")) {
          if (P.length < 2 || h.length < 2)
            return -1;
          rt = 2, ft /= 2, Tt /= 2, g /= 2;
        }
        function Xt(te, qt) {
          return rt === 1 ? te[qt] : te.readUInt16BE(qt * rt);
        }
        let $t;
        if (Q) {
          let te = -1;
          for ($t = g; $t < ft; $t++)
            if (Xt(P, $t) === Xt(h, te === -1 ? 0 : $t - te)) {
              if (te === -1 && (te = $t), $t - te + 1 === Tt) return te * rt;
            } else
              te !== -1 && ($t -= $t - te), te = -1;
        } else
          for (g + Tt > ft && (g = ft - Tt), $t = g; $t >= 0; $t--) {
            let te = !0;
            for (let qt = 0; qt < Tt; qt++)
              if (Xt(P, $t + qt) !== Xt(h, qt)) {
                te = !1;
                break;
              }
            if (te) return $t;
          }
        return -1;
      }
      Y.prototype.includes = function(h, g, T) {
        return this.indexOf(h, g, T) !== -1;
      }, Y.prototype.indexOf = function(h, g, T) {
        return V(this, h, g, T, !0);
      }, Y.prototype.lastIndexOf = function(h, g, T) {
        return V(this, h, g, T, !1);
      };
      function ut(P, h, g, T) {
        g = Number(g) || 0;
        const Q = P.length - g;
        T ? (T = Number(T), T > Q && (T = Q)) : T = Q;
        const rt = h.length;
        T > rt / 2 && (T = rt / 2);
        let ft;
        for (ft = 0; ft < T; ++ft) {
          const Tt = parseInt(h.substr(ft * 2, 2), 16);
          if (Bs(Tt)) return ft;
          P[g + ft] = Tt;
        }
        return ft;
      }
      function dt(P, h, g, T) {
        return Xi(Qt(h, P.length - g), P, g, T);
      }
      function B(P, h, g, T) {
        return Xi(Wt(h), P, g, T);
      }
      function O(P, h, g, T) {
        return Xi(Dt(h), P, g, T);
      }
      function it(P, h, g, T) {
        return Xi(Jt(h, P.length - g), P, g, T);
      }
      Y.prototype.write = function(h, g, T, Q) {
        if (g === void 0)
          Q = "utf8", T = this.length, g = 0;
        else if (T === void 0 && typeof g == "string")
          Q = g, T = this.length, g = 0;
        else if (isFinite(g))
          g = g >>> 0, isFinite(T) ? (T = T >>> 0, Q === void 0 && (Q = "utf8")) : (Q = T, T = void 0);
        else
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        const rt = this.length - g;
        if ((T === void 0 || T > rt) && (T = rt), h.length > 0 && (T < 0 || g < 0) || g > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        Q || (Q = "utf8");
        let ft = !1;
        for (; ; )
          switch (Q) {
            case "hex":
              return ut(this, h, g, T);
            case "utf8":
            case "utf-8":
              return dt(this, h, g, T);
            case "ascii":
            case "latin1":
            case "binary":
              return B(this, h, g, T);
            case "base64":
              return O(this, h, g, T);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return it(this, h, g, T);
            default:
              if (ft) throw new TypeError("Unknown encoding: " + Q);
              Q = ("" + Q).toLowerCase(), ft = !0;
          }
      }, Y.prototype.toJSON = function() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function gt(P, h, g) {
        return h === 0 && g === P.length ? N.fromByteArray(P) : N.fromByteArray(P.slice(h, g));
      }
      function Ot(P, h, g) {
        g = Math.min(P.length, g);
        const T = [];
        let Q = h;
        for (; Q < g; ) {
          const rt = P[Q];
          let ft = null, Tt = rt > 239 ? 4 : rt > 223 ? 3 : rt > 191 ? 2 : 1;
          if (Q + Tt <= g) {
            let Xt, $t, te, qt;
            switch (Tt) {
              case 1:
                rt < 128 && (ft = rt);
                break;
              case 2:
                Xt = P[Q + 1], (Xt & 192) === 128 && (qt = (rt & 31) << 6 | Xt & 63, qt > 127 && (ft = qt));
                break;
              case 3:
                Xt = P[Q + 1], $t = P[Q + 2], (Xt & 192) === 128 && ($t & 192) === 128 && (qt = (rt & 15) << 12 | (Xt & 63) << 6 | $t & 63, qt > 2047 && (qt < 55296 || qt > 57343) && (ft = qt));
                break;
              case 4:
                Xt = P[Q + 1], $t = P[Q + 2], te = P[Q + 3], (Xt & 192) === 128 && ($t & 192) === 128 && (te & 192) === 128 && (qt = (rt & 15) << 18 | (Xt & 63) << 12 | ($t & 63) << 6 | te & 63, qt > 65535 && qt < 1114112 && (ft = qt));
            }
          }
          ft === null ? (ft = 65533, Tt = 1) : ft > 65535 && (ft -= 65536, T.push(ft >>> 10 & 1023 | 55296), ft = 56320 | ft & 1023), T.push(ft), Q += Tt;
        }
        return It(T);
      }
      const vt = 4096;
      function It(P) {
        const h = P.length;
        if (h <= vt)
          return String.fromCharCode.apply(String, P);
        let g = "", T = 0;
        for (; T < h; )
          g += String.fromCharCode.apply(
            String,
            P.slice(T, T += vt)
          );
        return g;
      }
      function re(P, h, g) {
        let T = "";
        g = Math.min(P.length, g);
        for (let Q = h; Q < g; ++Q)
          T += String.fromCharCode(P[Q] & 127);
        return T;
      }
      function at(P, h, g) {
        let T = "";
        g = Math.min(P.length, g);
        for (let Q = h; Q < g; ++Q)
          T += String.fromCharCode(P[Q]);
        return T;
      }
      function ge(P, h, g) {
        const T = P.length;
        (!h || h < 0) && (h = 0), (!g || g < 0 || g > T) && (g = T);
        let Q = "";
        for (let rt = h; rt < g; ++rt)
          Q += Gc[P[rt]];
        return Q;
      }
      function Ge(P, h, g) {
        const T = P.slice(h, g);
        let Q = "";
        for (let rt = 0; rt < T.length - 1; rt += 2)
          Q += String.fromCharCode(T[rt] + T[rt + 1] * 256);
        return Q;
      }
      Y.prototype.slice = function(h, g) {
        const T = this.length;
        h = ~~h, g = g === void 0 ? T : ~~g, h < 0 ? (h += T, h < 0 && (h = 0)) : h > T && (h = T), g < 0 ? (g += T, g < 0 && (g = 0)) : g > T && (g = T), g < h && (g = h);
        const Q = this.subarray(h, g);
        return Object.setPrototypeOf(Q, Y.prototype), Q;
      };
      function Zt(P, h, g) {
        if (P % 1 !== 0 || P < 0) throw new RangeError("offset is not uint");
        if (P + h > g) throw new RangeError("Trying to access beyond buffer length");
      }
      Y.prototype.readUintLE = Y.prototype.readUIntLE = function(h, g, T) {
        h = h >>> 0, g = g >>> 0, T || Zt(h, g, this.length);
        let Q = this[h], rt = 1, ft = 0;
        for (; ++ft < g && (rt *= 256); )
          Q += this[h + ft] * rt;
        return Q;
      }, Y.prototype.readUintBE = Y.prototype.readUIntBE = function(h, g, T) {
        h = h >>> 0, g = g >>> 0, T || Zt(h, g, this.length);
        let Q = this[h + --g], rt = 1;
        for (; g > 0 && (rt *= 256); )
          Q += this[h + --g] * rt;
        return Q;
      }, Y.prototype.readUint8 = Y.prototype.readUInt8 = function(h, g) {
        return h = h >>> 0, g || Zt(h, 1, this.length), this[h];
      }, Y.prototype.readUint16LE = Y.prototype.readUInt16LE = function(h, g) {
        return h = h >>> 0, g || Zt(h, 2, this.length), this[h] | this[h + 1] << 8;
      }, Y.prototype.readUint16BE = Y.prototype.readUInt16BE = function(h, g) {
        return h = h >>> 0, g || Zt(h, 2, this.length), this[h] << 8 | this[h + 1];
      }, Y.prototype.readUint32LE = Y.prototype.readUInt32LE = function(h, g) {
        return h = h >>> 0, g || Zt(h, 4, this.length), (this[h] | this[h + 1] << 8 | this[h + 2] << 16) + this[h + 3] * 16777216;
      }, Y.prototype.readUint32BE = Y.prototype.readUInt32BE = function(h, g) {
        return h = h >>> 0, g || Zt(h, 4, this.length), this[h] * 16777216 + (this[h + 1] << 16 | this[h + 2] << 8 | this[h + 3]);
      }, Y.prototype.readBigUInt64LE = er(function(h) {
        h = h >>> 0, q(h, "offset");
        const g = this[h], T = this[h + 7];
        (g === void 0 || T === void 0) && Z(h, this.length - 8);
        const Q = g + this[++h] * 2 ** 8 + this[++h] * 2 ** 16 + this[++h] * 2 ** 24, rt = this[++h] + this[++h] * 2 ** 8 + this[++h] * 2 ** 16 + T * 2 ** 24;
        return BigInt(Q) + (BigInt(rt) << BigInt(32));
      }), Y.prototype.readBigUInt64BE = er(function(h) {
        h = h >>> 0, q(h, "offset");
        const g = this[h], T = this[h + 7];
        (g === void 0 || T === void 0) && Z(h, this.length - 8);
        const Q = g * 2 ** 24 + this[++h] * 2 ** 16 + this[++h] * 2 ** 8 + this[++h], rt = this[++h] * 2 ** 24 + this[++h] * 2 ** 16 + this[++h] * 2 ** 8 + T;
        return (BigInt(Q) << BigInt(32)) + BigInt(rt);
      }), Y.prototype.readIntLE = function(h, g, T) {
        h = h >>> 0, g = g >>> 0, T || Zt(h, g, this.length);
        let Q = this[h], rt = 1, ft = 0;
        for (; ++ft < g && (rt *= 256); )
          Q += this[h + ft] * rt;
        return rt *= 128, Q >= rt && (Q -= Math.pow(2, 8 * g)), Q;
      }, Y.prototype.readIntBE = function(h, g, T) {
        h = h >>> 0, g = g >>> 0, T || Zt(h, g, this.length);
        let Q = g, rt = 1, ft = this[h + --Q];
        for (; Q > 0 && (rt *= 256); )
          ft += this[h + --Q] * rt;
        return rt *= 128, ft >= rt && (ft -= Math.pow(2, 8 * g)), ft;
      }, Y.prototype.readInt8 = function(h, g) {
        return h = h >>> 0, g || Zt(h, 1, this.length), this[h] & 128 ? (255 - this[h] + 1) * -1 : this[h];
      }, Y.prototype.readInt16LE = function(h, g) {
        h = h >>> 0, g || Zt(h, 2, this.length);
        const T = this[h] | this[h + 1] << 8;
        return T & 32768 ? T | 4294901760 : T;
      }, Y.prototype.readInt16BE = function(h, g) {
        h = h >>> 0, g || Zt(h, 2, this.length);
        const T = this[h + 1] | this[h] << 8;
        return T & 32768 ? T | 4294901760 : T;
      }, Y.prototype.readInt32LE = function(h, g) {
        return h = h >>> 0, g || Zt(h, 4, this.length), this[h] | this[h + 1] << 8 | this[h + 2] << 16 | this[h + 3] << 24;
      }, Y.prototype.readInt32BE = function(h, g) {
        return h = h >>> 0, g || Zt(h, 4, this.length), this[h] << 24 | this[h + 1] << 16 | this[h + 2] << 8 | this[h + 3];
      }, Y.prototype.readBigInt64LE = er(function(h) {
        h = h >>> 0, q(h, "offset");
        const g = this[h], T = this[h + 7];
        (g === void 0 || T === void 0) && Z(h, this.length - 8);
        const Q = this[h + 4] + this[h + 5] * 2 ** 8 + this[h + 6] * 2 ** 16 + (T << 24);
        return (BigInt(Q) << BigInt(32)) + BigInt(g + this[++h] * 2 ** 8 + this[++h] * 2 ** 16 + this[++h] * 2 ** 24);
      }), Y.prototype.readBigInt64BE = er(function(h) {
        h = h >>> 0, q(h, "offset");
        const g = this[h], T = this[h + 7];
        (g === void 0 || T === void 0) && Z(h, this.length - 8);
        const Q = (g << 24) + // Overflow
        this[++h] * 2 ** 16 + this[++h] * 2 ** 8 + this[++h];
        return (BigInt(Q) << BigInt(32)) + BigInt(this[++h] * 2 ** 24 + this[++h] * 2 ** 16 + this[++h] * 2 ** 8 + T);
      }), Y.prototype.readFloatLE = function(h, g) {
        return h = h >>> 0, g || Zt(h, 4, this.length), I.read(this, h, !0, 23, 4);
      }, Y.prototype.readFloatBE = function(h, g) {
        return h = h >>> 0, g || Zt(h, 4, this.length), I.read(this, h, !1, 23, 4);
      }, Y.prototype.readDoubleLE = function(h, g) {
        return h = h >>> 0, g || Zt(h, 8, this.length), I.read(this, h, !0, 52, 8);
      }, Y.prototype.readDoubleBE = function(h, g) {
        return h = h >>> 0, g || Zt(h, 8, this.length), I.read(this, h, !1, 52, 8);
      };
      function ie(P, h, g, T, Q, rt) {
        if (!Y.isBuffer(P)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (h > Q || h < rt) throw new RangeError('"value" argument is out of bounds');
        if (g + T > P.length) throw new RangeError("Index out of range");
      }
      Y.prototype.writeUintLE = Y.prototype.writeUIntLE = function(h, g, T, Q) {
        if (h = +h, g = g >>> 0, T = T >>> 0, !Q) {
          const Tt = Math.pow(2, 8 * T) - 1;
          ie(this, h, g, T, Tt, 0);
        }
        let rt = 1, ft = 0;
        for (this[g] = h & 255; ++ft < T && (rt *= 256); )
          this[g + ft] = h / rt & 255;
        return g + T;
      }, Y.prototype.writeUintBE = Y.prototype.writeUIntBE = function(h, g, T, Q) {
        if (h = +h, g = g >>> 0, T = T >>> 0, !Q) {
          const Tt = Math.pow(2, 8 * T) - 1;
          ie(this, h, g, T, Tt, 0);
        }
        let rt = T - 1, ft = 1;
        for (this[g + rt] = h & 255; --rt >= 0 && (ft *= 256); )
          this[g + rt] = h / ft & 255;
        return g + T;
      }, Y.prototype.writeUint8 = Y.prototype.writeUInt8 = function(h, g, T) {
        return h = +h, g = g >>> 0, T || ie(this, h, g, 1, 255, 0), this[g] = h & 255, g + 1;
      }, Y.prototype.writeUint16LE = Y.prototype.writeUInt16LE = function(h, g, T) {
        return h = +h, g = g >>> 0, T || ie(this, h, g, 2, 65535, 0), this[g] = h & 255, this[g + 1] = h >>> 8, g + 2;
      }, Y.prototype.writeUint16BE = Y.prototype.writeUInt16BE = function(h, g, T) {
        return h = +h, g = g >>> 0, T || ie(this, h, g, 2, 65535, 0), this[g] = h >>> 8, this[g + 1] = h & 255, g + 2;
      }, Y.prototype.writeUint32LE = Y.prototype.writeUInt32LE = function(h, g, T) {
        return h = +h, g = g >>> 0, T || ie(this, h, g, 4, 4294967295, 0), this[g + 3] = h >>> 24, this[g + 2] = h >>> 16, this[g + 1] = h >>> 8, this[g] = h & 255, g + 4;
      }, Y.prototype.writeUint32BE = Y.prototype.writeUInt32BE = function(h, g, T) {
        return h = +h, g = g >>> 0, T || ie(this, h, g, 4, 4294967295, 0), this[g] = h >>> 24, this[g + 1] = h >>> 16, this[g + 2] = h >>> 8, this[g + 3] = h & 255, g + 4;
      };
      function Ue(P, h, g, T, Q) {
        k(h, T, Q, P, g, 7);
        let rt = Number(h & BigInt(4294967295));
        P[g++] = rt, rt = rt >> 8, P[g++] = rt, rt = rt >> 8, P[g++] = rt, rt = rt >> 8, P[g++] = rt;
        let ft = Number(h >> BigInt(32) & BigInt(4294967295));
        return P[g++] = ft, ft = ft >> 8, P[g++] = ft, ft = ft >> 8, P[g++] = ft, ft = ft >> 8, P[g++] = ft, g;
      }
      function we(P, h, g, T, Q) {
        k(h, T, Q, P, g, 7);
        let rt = Number(h & BigInt(4294967295));
        P[g + 7] = rt, rt = rt >> 8, P[g + 6] = rt, rt = rt >> 8, P[g + 5] = rt, rt = rt >> 8, P[g + 4] = rt;
        let ft = Number(h >> BigInt(32) & BigInt(4294967295));
        return P[g + 3] = ft, ft = ft >> 8, P[g + 2] = ft, ft = ft >> 8, P[g + 1] = ft, ft = ft >> 8, P[g] = ft, g + 8;
      }
      Y.prototype.writeBigUInt64LE = er(function(h, g = 0) {
        return Ue(this, h, g, BigInt(0), BigInt("0xffffffffffffffff"));
      }), Y.prototype.writeBigUInt64BE = er(function(h, g = 0) {
        return we(this, h, g, BigInt(0), BigInt("0xffffffffffffffff"));
      }), Y.prototype.writeIntLE = function(h, g, T, Q) {
        if (h = +h, g = g >>> 0, !Q) {
          const Xt = Math.pow(2, 8 * T - 1);
          ie(this, h, g, T, Xt - 1, -Xt);
        }
        let rt = 0, ft = 1, Tt = 0;
        for (this[g] = h & 255; ++rt < T && (ft *= 256); )
          h < 0 && Tt === 0 && this[g + rt - 1] !== 0 && (Tt = 1), this[g + rt] = (h / ft >> 0) - Tt & 255;
        return g + T;
      }, Y.prototype.writeIntBE = function(h, g, T, Q) {
        if (h = +h, g = g >>> 0, !Q) {
          const Xt = Math.pow(2, 8 * T - 1);
          ie(this, h, g, T, Xt - 1, -Xt);
        }
        let rt = T - 1, ft = 1, Tt = 0;
        for (this[g + rt] = h & 255; --rt >= 0 && (ft *= 256); )
          h < 0 && Tt === 0 && this[g + rt + 1] !== 0 && (Tt = 1), this[g + rt] = (h / ft >> 0) - Tt & 255;
        return g + T;
      }, Y.prototype.writeInt8 = function(h, g, T) {
        return h = +h, g = g >>> 0, T || ie(this, h, g, 1, 127, -128), h < 0 && (h = 255 + h + 1), this[g] = h & 255, g + 1;
      }, Y.prototype.writeInt16LE = function(h, g, T) {
        return h = +h, g = g >>> 0, T || ie(this, h, g, 2, 32767, -32768), this[g] = h & 255, this[g + 1] = h >>> 8, g + 2;
      }, Y.prototype.writeInt16BE = function(h, g, T) {
        return h = +h, g = g >>> 0, T || ie(this, h, g, 2, 32767, -32768), this[g] = h >>> 8, this[g + 1] = h & 255, g + 2;
      }, Y.prototype.writeInt32LE = function(h, g, T) {
        return h = +h, g = g >>> 0, T || ie(this, h, g, 4, 2147483647, -2147483648), this[g] = h & 255, this[g + 1] = h >>> 8, this[g + 2] = h >>> 16, this[g + 3] = h >>> 24, g + 4;
      }, Y.prototype.writeInt32BE = function(h, g, T) {
        return h = +h, g = g >>> 0, T || ie(this, h, g, 4, 2147483647, -2147483648), h < 0 && (h = 4294967295 + h + 1), this[g] = h >>> 24, this[g + 1] = h >>> 16, this[g + 2] = h >>> 8, this[g + 3] = h & 255, g + 4;
      }, Y.prototype.writeBigInt64LE = er(function(h, g = 0) {
        return Ue(this, h, g, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      }), Y.prototype.writeBigInt64BE = er(function(h, g = 0) {
        return we(this, h, g, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function xe(P, h, g, T, Q, rt) {
        if (g + T > P.length) throw new RangeError("Index out of range");
        if (g < 0) throw new RangeError("Index out of range");
      }
      function Fe(P, h, g, T, Q) {
        return h = +h, g = g >>> 0, Q || xe(P, h, g, 4), I.write(P, h, g, T, 23, 4), g + 4;
      }
      Y.prototype.writeFloatLE = function(h, g, T) {
        return Fe(this, h, g, !0, T);
      }, Y.prototype.writeFloatBE = function(h, g, T) {
        return Fe(this, h, g, !1, T);
      };
      function ce(P, h, g, T, Q) {
        return h = +h, g = g >>> 0, Q || xe(P, h, g, 8), I.write(P, h, g, T, 52, 8), g + 8;
      }
      Y.prototype.writeDoubleLE = function(h, g, T) {
        return ce(this, h, g, !0, T);
      }, Y.prototype.writeDoubleBE = function(h, g, T) {
        return ce(this, h, g, !1, T);
      }, Y.prototype.copy = function(h, g, T, Q) {
        if (!Y.isBuffer(h)) throw new TypeError("argument should be a Buffer");
        if (T || (T = 0), !Q && Q !== 0 && (Q = this.length), g >= h.length && (g = h.length), g || (g = 0), Q > 0 && Q < T && (Q = T), Q === T || h.length === 0 || this.length === 0) return 0;
        if (g < 0)
          throw new RangeError("targetStart out of bounds");
        if (T < 0 || T >= this.length) throw new RangeError("Index out of range");
        if (Q < 0) throw new RangeError("sourceEnd out of bounds");
        Q > this.length && (Q = this.length), h.length - g < Q - T && (Q = h.length - g + T);
        const rt = Q - T;
        return this === h && typeof j.prototype.copyWithin == "function" ? this.copyWithin(g, T, Q) : j.prototype.set.call(
          h,
          this.subarray(T, Q),
          g
        ), rt;
      }, Y.prototype.fill = function(h, g, T, Q) {
        if (typeof h == "string") {
          if (typeof g == "string" ? (Q = g, g = 0, T = this.length) : typeof T == "string" && (Q = T, T = this.length), Q !== void 0 && typeof Q != "string")
            throw new TypeError("encoding must be a string");
          if (typeof Q == "string" && !Y.isEncoding(Q))
            throw new TypeError("Unknown encoding: " + Q);
          if (h.length === 1) {
            const ft = h.charCodeAt(0);
            (Q === "utf8" && ft < 128 || Q === "latin1") && (h = ft);
          }
        } else typeof h == "number" ? h = h & 255 : typeof h == "boolean" && (h = Number(h));
        if (g < 0 || this.length < g || this.length < T)
          throw new RangeError("Out of range index");
        if (T <= g)
          return this;
        g = g >>> 0, T = T === void 0 ? this.length : T >>> 0, h || (h = 0);
        let rt;
        if (typeof h == "number")
          for (rt = g; rt < T; ++rt)
            this[rt] = h;
        else {
          const ft = Y.isBuffer(h) ? h : Y.from(h, Q), Tt = ft.length;
          if (Tt === 0)
            throw new TypeError('The value "' + h + '" is invalid for argument "value"');
          for (rt = 0; rt < T - g; ++rt)
            this[rt + g] = ft[rt % Tt];
        }
        return this;
      };
      const tr = {};
      function E(P, h, g) {
        tr[P] = class extends g {
          constructor() {
            super(), Object.defineProperty(this, "message", {
              value: h.apply(this, arguments),
              writable: !0,
              configurable: !0
            }), this.name = `${this.name} [${P}]`, this.stack, delete this.name;
          }
          get code() {
            return P;
          }
          set code(Q) {
            Object.defineProperty(this, "code", {
              configurable: !0,
              enumerable: !0,
              value: Q,
              writable: !0
            });
          }
          toString() {
            return `${this.name} [${P}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(P) {
          return P ? `${P} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        },
        RangeError
      ), E(
        "ERR_INVALID_ARG_TYPE",
        function(P, h) {
          return `The "${P}" argument must be of type number. Received type ${typeof h}`;
        },
        TypeError
      ), E(
        "ERR_OUT_OF_RANGE",
        function(P, h, g) {
          let T = `The value of "${P}" is out of range.`, Q = g;
          return Number.isInteger(g) && Math.abs(g) > 2 ** 32 ? Q = p(String(g)) : typeof g == "bigint" && (Q = String(g), (g > BigInt(2) ** BigInt(32) || g < -(BigInt(2) ** BigInt(32))) && (Q = p(Q)), Q += "n"), T += ` It must be ${h}. Received ${Q}`, T;
        },
        RangeError
      );
      function p(P) {
        let h = "", g = P.length;
        const T = P[0] === "-" ? 1 : 0;
        for (; g >= T + 4; g -= 3)
          h = `_${P.slice(g - 3, g)}${h}`;
        return `${P.slice(0, g)}${h}`;
      }
      function d(P, h, g) {
        q(h, "offset"), (P[h] === void 0 || P[h + g] === void 0) && Z(h, P.length - (g + 1));
      }
      function k(P, h, g, T, Q, rt) {
        if (P > g || P < h) {
          const ft = typeof h == "bigint" ? "n" : "";
          let Tt;
          throw h === 0 || h === BigInt(0) ? Tt = `>= 0${ft} and < 2${ft} ** ${(rt + 1) * 8}${ft}` : Tt = `>= -(2${ft} ** ${(rt + 1) * 8 - 1}${ft}) and < 2 ** ${(rt + 1) * 8 - 1}${ft}`, new tr.ERR_OUT_OF_RANGE("value", Tt, P);
        }
        d(T, Q, rt);
      }
      function q(P, h) {
        if (typeof P != "number")
          throw new tr.ERR_INVALID_ARG_TYPE(h, "number", P);
      }
      function Z(P, h, g) {
        throw Math.floor(P) !== P ? (q(P, g), new tr.ERR_OUT_OF_RANGE("offset", "an integer", P)) : h < 0 ? new tr.ERR_BUFFER_OUT_OF_BOUNDS() : new tr.ERR_OUT_OF_RANGE(
          "offset",
          `>= 0 and <= ${h}`,
          P
        );
      }
      const ct = /[^+/0-9A-Za-z-_]/g;
      function kt(P) {
        if (P = P.split("=")[0], P = P.trim().replace(ct, ""), P.length < 2) return "";
        for (; P.length % 4 !== 0; )
          P = P + "=";
        return P;
      }
      function Qt(P, h) {
        h = h || 1 / 0;
        let g;
        const T = P.length;
        let Q = null;
        const rt = [];
        for (let ft = 0; ft < T; ++ft) {
          if (g = P.charCodeAt(ft), g > 55295 && g < 57344) {
            if (!Q) {
              if (g > 56319) {
                (h -= 3) > -1 && rt.push(239, 191, 189);
                continue;
              } else if (ft + 1 === T) {
                (h -= 3) > -1 && rt.push(239, 191, 189);
                continue;
              }
              Q = g;
              continue;
            }
            if (g < 56320) {
              (h -= 3) > -1 && rt.push(239, 191, 189), Q = g;
              continue;
            }
            g = (Q - 55296 << 10 | g - 56320) + 65536;
          } else Q && (h -= 3) > -1 && rt.push(239, 191, 189);
          if (Q = null, g < 128) {
            if ((h -= 1) < 0) break;
            rt.push(g);
          } else if (g < 2048) {
            if ((h -= 2) < 0) break;
            rt.push(
              g >> 6 | 192,
              g & 63 | 128
            );
          } else if (g < 65536) {
            if ((h -= 3) < 0) break;
            rt.push(
              g >> 12 | 224,
              g >> 6 & 63 | 128,
              g & 63 | 128
            );
          } else if (g < 1114112) {
            if ((h -= 4) < 0) break;
            rt.push(
              g >> 18 | 240,
              g >> 12 & 63 | 128,
              g >> 6 & 63 | 128,
              g & 63 | 128
            );
          } else
            throw new Error("Invalid code point");
        }
        return rt;
      }
      function Wt(P) {
        const h = [];
        for (let g = 0; g < P.length; ++g)
          h.push(P.charCodeAt(g) & 255);
        return h;
      }
      function Jt(P, h) {
        let g, T, Q;
        const rt = [];
        for (let ft = 0; ft < P.length && !((h -= 2) < 0); ++ft)
          g = P.charCodeAt(ft), T = g >> 8, Q = g % 256, rt.push(Q), rt.push(T);
        return rt;
      }
      function Dt(P) {
        return N.toByteArray(kt(P));
      }
      function Xi(P, h, g, T) {
        let Q;
        for (Q = 0; Q < T && !(Q + g >= h.length || Q >= P.length); ++Q)
          h[Q + g] = P[Q];
        return Q;
      }
      function Ke(P, h) {
        return P instanceof h || P != null && P.constructor != null && P.constructor.name != null && P.constructor.name === h.name;
      }
      function Bs(P) {
        return P !== P;
      }
      const Gc = function() {
        const P = "0123456789abcdef", h = new Array(256);
        for (let g = 0; g < 16; ++g) {
          const T = g * 16;
          for (let Q = 0; Q < 16; ++Q)
            h[T + Q] = P[g] + P[Q];
        }
        return h;
      }();
      function er(P) {
        return typeof BigInt > "u" ? Uc : P;
      }
      function Uc() {
        throw new Error("BigInt not supported");
      }
    })(t);
    const z = t.Buffer;
    n.Blob = t.Blob, n.BlobOptions = t.BlobOptions, n.Buffer = t.Buffer, n.File = t.File, n.FileOptions = t.FileOptions, n.INSPECT_MAX_BYTES = t.INSPECT_MAX_BYTES, n.SlowBuffer = t.SlowBuffer, n.TranscodeEncoding = t.TranscodeEncoding, n.atob = t.atob, n.btoa = t.btoa, n.constants = t.constants, n.default = z, n.isAscii = t.isAscii, n.isUtf8 = t.isUtf8, n.kMaxLength = t.kMaxLength, n.kStringMaxLength = t.kStringMaxLength, n.resolveObjectURL = t.resolveObjectURL, n.transcode = t.transcode;
  }(Gl)), Gl;
}
var Ul = {}, Fl = {}, Kl, Gd;
function Z2() {
  return Gd || (Gd = 1, Kl = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, e = Symbol("test"), r = Object(e);
    if (typeof e == "string" || Object.prototype.toString.call(e) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
      return !1;
    var s = 42;
    t[e] = s;
    for (var _ in t)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var a = Object.getOwnPropertySymbols(t);
    if (a.length !== 1 || a[0] !== e || !Object.prototype.propertyIsEnumerable.call(t, e))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var c = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(t, e)
      );
      if (c.value !== s || c.enumerable !== !0)
        return !1;
    }
    return !0;
  }), Kl;
}
var Dl, Ud;
function aw() {
  if (Ud) return Dl;
  Ud = 1;
  var n = Z2();
  return Dl = function() {
    return n() && !!Symbol.toStringTag;
  }, Dl;
}
var Ll, Fd;
function gz() {
  return Fd || (Fd = 1, Ll = Object), Ll;
}
var jl, Kd;
function bz() {
  return Kd || (Kd = 1, jl = Error), jl;
}
var Vl, Dd;
function yz() {
  return Dd || (Dd = 1, Vl = EvalError), Vl;
}
var Yl, Ld;
function Az() {
  return Ld || (Ld = 1, Yl = RangeError), Yl;
}
var Hl, jd;
function mz() {
  return jd || (jd = 1, Hl = ReferenceError), Hl;
}
var ql, Vd;
function X2() {
  return Vd || (Vd = 1, ql = SyntaxError), ql;
}
var Ql, Yd;
function qf() {
  return Yd || (Yd = 1, Ql = TypeError), Ql;
}
var Wl, Hd;
function Sz() {
  return Hd || (Hd = 1, Wl = URIError), Wl;
}
var Jl, qd;
function Rz() {
  return qd || (qd = 1, Jl = Math.abs), Jl;
}
var $l, Qd;
function Ez() {
  return Qd || (Qd = 1, $l = Math.floor), $l;
}
var Zl, Wd;
function Pz() {
  return Wd || (Wd = 1, Zl = Math.max), Zl;
}
var Xl, Jd;
function zz() {
  return Jd || (Jd = 1, Xl = Math.min), Xl;
}
var tp, $d;
function vz() {
  return $d || ($d = 1, tp = Math.pow), tp;
}
var ep, Zd;
function Mz() {
  return Zd || (Zd = 1, ep = Object.getOwnPropertyDescriptor), ep;
}
var rp, Xd;
function Iu() {
  if (Xd) return rp;
  Xd = 1;
  var n = /* @__PURE__ */ Mz();
  if (n)
    try {
      n([], "length");
    } catch {
      n = null;
    }
  return rp = n, rp;
}
var np, tg;
function Qf() {
  if (tg) return np;
  tg = 1;
  var n = Object.defineProperty || !1;
  if (n)
    try {
      n({}, "a", { value: 1 });
    } catch {
      n = !1;
    }
  return np = n, np;
}
var ip, eg;
function xz() {
  if (eg) return ip;
  eg = 1;
  var n = typeof Symbol < "u" && Symbol, t = Z2();
  return ip = function() {
    return typeof n != "function" || typeof Symbol != "function" || typeof n("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, ip;
}
var sp, rg;
function Bz() {
  if (rg) return sp;
  rg = 1;
  var n = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, e = Math.max, r = "[object Function]", s = function(u, l) {
    for (var f = [], w = 0; w < u.length; w += 1)
      f[w] = u[w];
    for (var y = 0; y < l.length; y += 1)
      f[y + u.length] = l[y];
    return f;
  }, _ = function(u, l) {
    for (var f = [], w = l, y = 0; w < u.length; w += 1, y += 1)
      f[y] = u[w];
    return f;
  }, a = function(c, u) {
    for (var l = "", f = 0; f < c.length; f += 1)
      l += c[f], f + 1 < c.length && (l += u);
    return l;
  };
  return sp = function(u) {
    var l = this;
    if (typeof l != "function" || t.apply(l) !== r)
      throw new TypeError(n + l);
    for (var f = _(arguments, 1), w, y = function() {
      if (this instanceof w) {
        var z = l.apply(
          this,
          s(f, arguments)
        );
        return Object(z) === z ? z : this;
      }
      return l.apply(
        u,
        s(f, arguments)
      );
    }, v = e(0, l.length - f.length), x = [], C = 0; C < v; C++)
      x[C] = "$" + C;
    if (w = Function("binder", "return function (" + a(x, ",") + "){ return binder.apply(this,arguments); }")(y), l.prototype) {
      var U = function() {
      };
      U.prototype = l.prototype, w.prototype = new U(), U.prototype = null;
    }
    return w;
  }, sp;
}
var _p, ng;
function Nu() {
  if (ng) return _p;
  ng = 1;
  var n = Bz();
  return _p = Function.prototype.bind || n, _p;
}
var op, ig;
function cw() {
  return ig || (ig = 1, op = Function.prototype.call), op;
}
var ap, sg;
function uw() {
  return sg || (sg = 1, ap = Function.prototype.apply), ap;
}
var cp, _g;
function Cz() {
  return _g || (_g = 1, cp = typeof Reflect < "u" && Reflect && Reflect.apply), cp;
}
var up, og;
function tm() {
  if (og) return up;
  og = 1;
  var n = Nu(), t = uw(), e = cw(), r = Cz();
  return up = r || n.call(e, t), up;
}
var fp, ag;
function em() {
  if (ag) return fp;
  ag = 1;
  var n = Nu(), t = /* @__PURE__ */ qf(), e = cw(), r = tm();
  return fp = function(_) {
    if (_.length < 1 || typeof _[0] != "function")
      throw new t("a function is required");
    return r(n, e, _);
  }, fp;
}
var lp, cg;
function Iz() {
  if (cg) return lp;
  cg = 1;
  var n = em(), t = /* @__PURE__ */ Iu(), e = (
    /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype
  ), r = e && t && t(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), s = Object, _ = s.getPrototypeOf;
  return lp = r && typeof r.get == "function" ? n([r.get]) : typeof _ == "function" ? (
    /** @type {import('./get')} */
    function(c) {
      return _(c == null ? c : s(c));
    }
  ) : !1, lp;
}
var pp, ug;
function Nz() {
  if (ug) return pp;
  ug = 1;
  var n = Function.prototype.call, t = Object.prototype.hasOwnProperty, e = Nu();
  return pp = e.call(n, t), pp;
}
var hp, fg;
function fw() {
  if (fg) return hp;
  fg = 1;
  var n, t = /* @__PURE__ */ gz(), e = /* @__PURE__ */ bz(), r = /* @__PURE__ */ yz(), s = /* @__PURE__ */ Az(), _ = /* @__PURE__ */ mz(), a = /* @__PURE__ */ X2(), c = /* @__PURE__ */ qf(), u = /* @__PURE__ */ Sz(), l = /* @__PURE__ */ Rz(), f = /* @__PURE__ */ Ez(), w = /* @__PURE__ */ Pz(), y = /* @__PURE__ */ zz(), v = /* @__PURE__ */ vz(), x = Function, C = function(H) {
    try {
      return x('"use strict"; return (' + H + ").constructor;")();
    } catch {
    }
  }, U = /* @__PURE__ */ Iu(), z = /* @__PURE__ */ Qf(), M = function() {
    throw new c();
  }, N = U ? function() {
    try {
      return arguments.callee, M;
    } catch {
      try {
        return U(arguments, "callee").get;
      } catch {
        return M;
      }
    }
  }() : M, I = xz()(), G = /* @__PURE__ */ Iz(), D = typeof Reflect == "function" && Reflect.getPrototypeOf || t.getPrototypeOf || G, j = uw(), L = cw(), X = {}, et = typeof Uint8Array > "u" || !D ? n : D(Uint8Array), lt = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? n : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? n : ArrayBuffer,
    "%ArrayIteratorPrototype%": I && D ? D([][Symbol.iterator]()) : n,
    "%AsyncFromSyncIteratorPrototype%": n,
    "%AsyncFunction%": X,
    "%AsyncGenerator%": X,
    "%AsyncGeneratorFunction%": X,
    "%AsyncIteratorPrototype%": X,
    "%Atomics%": typeof Atomics > "u" ? n : Atomics,
    "%BigInt%": typeof BigInt > "u" ? n : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? n : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? n : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? n : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": e,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": r,
    "%Float32Array%": typeof Float32Array > "u" ? n : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? n : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? n : FinalizationRegistry,
    "%Function%": x,
    "%GeneratorFunction%": X,
    "%Int8Array%": typeof Int8Array > "u" ? n : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? n : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? n : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": I && D ? D(D([][Symbol.iterator]())) : n,
    "%JSON%": typeof JSON == "object" ? JSON : n,
    "%Map%": typeof Map > "u" ? n : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !I || !D ? n : D((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": t,
    "%Object.getOwnPropertyDescriptor%": U,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? n : Promise,
    "%Proxy%": typeof Proxy > "u" ? n : Proxy,
    "%RangeError%": s,
    "%ReferenceError%": _,
    "%Reflect%": typeof Reflect > "u" ? n : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? n : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !I || !D ? n : D((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? n : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": I && D ? D(""[Symbol.iterator]()) : n,
    "%Symbol%": I ? Symbol : n,
    "%SyntaxError%": a,
    "%ThrowTypeError%": N,
    "%TypedArray%": et,
    "%TypeError%": c,
    "%Uint8Array%": typeof Uint8Array > "u" ? n : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? n : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? n : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? n : Uint32Array,
    "%URIError%": u,
    "%WeakMap%": typeof WeakMap > "u" ? n : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? n : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? n : WeakSet,
    "%Function.prototype.call%": L,
    "%Function.prototype.apply%": j,
    "%Object.defineProperty%": z,
    "%Math.abs%": l,
    "%Math.floor%": f,
    "%Math.max%": w,
    "%Math.min%": y,
    "%Math.pow%": v
  };
  if (D)
    try {
      null.error;
    } catch (H) {
      var Y = D(D(H));
      lt["%Error.prototype%"] = Y;
    }
  var Et = function H(V) {
    var tt;
    if (V === "%AsyncFunction%")
      tt = C("async function () {}");
    else if (V === "%GeneratorFunction%")
      tt = C("function* () {}");
    else if (V === "%AsyncGeneratorFunction%")
      tt = C("async function* () {}");
    else if (V === "%AsyncGenerator%") {
      var ut = H("%AsyncGeneratorFunction%");
      ut && (tt = ut.prototype);
    } else if (V === "%AsyncIteratorPrototype%") {
      var dt = H("%AsyncGenerator%");
      dt && D && (tt = D(dt.prototype));
    }
    return lt[V] = tt, tt;
  }, Ct = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, pt = Nu(), wt = /* @__PURE__ */ Nz(), Pt = pt.call(L, Array.prototype.concat), Mt = pt.call(j, Array.prototype.splice), xt = pt.call(L, String.prototype.replace), Nt = pt.call(L, String.prototype.slice), Ht = pt.call(L, RegExp.prototype.exec), J = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, st = /\\(\\)?/g, _t = function(V) {
    var tt = Nt(V, 0, 1), ut = Nt(V, -1);
    if (tt === "%" && ut !== "%")
      throw new a("invalid intrinsic syntax, expected closing `%`");
    if (ut === "%" && tt !== "%")
      throw new a("invalid intrinsic syntax, expected opening `%`");
    var dt = [];
    return xt(V, J, function(B, O, it, gt) {
      dt[dt.length] = it ? xt(gt, st, "$1") : O || B;
    }), dt;
  }, mt = function(V, tt) {
    var ut = V, dt;
    if (wt(Ct, ut) && (dt = Ct[ut], ut = "%" + dt[0] + "%"), wt(lt, ut)) {
      var B = lt[ut];
      if (B === X && (B = Et(ut)), typeof B > "u" && !tt)
        throw new c("intrinsic " + V + " exists, but is not available. Please file an issue!");
      return {
        alias: dt,
        name: ut,
        value: B
      };
    }
    throw new a("intrinsic " + V + " does not exist!");
  };
  return hp = function(V, tt) {
    if (typeof V != "string" || V.length === 0)
      throw new c("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof tt != "boolean")
      throw new c('"allowMissing" argument must be a boolean');
    if (Ht(/^%?[^%]*%?$/, V) === null)
      throw new a("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var ut = _t(V), dt = ut.length > 0 ? ut[0] : "", B = mt("%" + dt + "%", tt), O = B.name, it = B.value, gt = !1, Ot = B.alias;
    Ot && (dt = Ot[0], Mt(ut, Pt([0, 1], Ot)));
    for (var vt = 1, It = !0; vt < ut.length; vt += 1) {
      var re = ut[vt], at = Nt(re, 0, 1), ge = Nt(re, -1);
      if ((at === '"' || at === "'" || at === "`" || ge === '"' || ge === "'" || ge === "`") && at !== ge)
        throw new a("property names with quotes must have matching quotes");
      if ((re === "constructor" || !It) && (gt = !0), dt += "." + re, O = "%" + dt + "%", wt(lt, O))
        it = lt[O];
      else if (it != null) {
        if (!(re in it)) {
          if (!tt)
            throw new c("base intrinsic for " + V + " exists, but the property is not available.");
          return;
        }
        if (U && vt + 1 >= ut.length) {
          var Ge = U(it, re);
          It = !!Ge, It && "get" in Ge && !("originalValue" in Ge.get) ? it = Ge.get : it = it[re];
        } else
          It = wt(it, re), it = it[re];
        It && !gt && (lt[O] = it);
      }
    }
    return it;
  }, hp;
}
var wp = { exports: {} }, dp, lg;
function Oz() {
  if (lg) return dp;
  lg = 1;
  var n = /* @__PURE__ */ Qf(), t = /* @__PURE__ */ X2(), e = /* @__PURE__ */ qf(), r = /* @__PURE__ */ Iu();
  return dp = function(_, a, c) {
    if (!_ || typeof _ != "object" && typeof _ != "function")
      throw new e("`obj` must be an object or a function`");
    if (typeof a != "string" && typeof a != "symbol")
      throw new e("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new e("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new e("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new e("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new e("`loose`, if provided, must be a boolean");
    var u = arguments.length > 3 ? arguments[3] : null, l = arguments.length > 4 ? arguments[4] : null, f = arguments.length > 5 ? arguments[5] : null, w = arguments.length > 6 ? arguments[6] : !1, y = !!r && r(_, a);
    if (n)
      n(_, a, {
        configurable: f === null && y ? y.configurable : !f,
        enumerable: u === null && y ? y.enumerable : !u,
        value: c,
        writable: l === null && y ? y.writable : !l
      });
    else if (w || !u && !l && !f)
      _[a] = c;
    else
      throw new t("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, dp;
}
var gp, pg;
function kz() {
  if (pg) return gp;
  pg = 1;
  var n = /* @__PURE__ */ Qf(), t = function() {
    return !!n;
  };
  return t.hasArrayLengthDefineBug = function() {
    if (!n)
      return null;
    try {
      return n([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, gp = t, gp;
}
var bp, hg;
function Tz() {
  if (hg) return bp;
  hg = 1;
  var n = /* @__PURE__ */ fw(), t = /* @__PURE__ */ Oz(), e = /* @__PURE__ */ kz()(), r = /* @__PURE__ */ Iu(), s = /* @__PURE__ */ qf(), _ = n("%Math.floor%");
  return bp = function(c, u) {
    if (typeof c != "function")
      throw new s("`fn` is not a function");
    if (typeof u != "number" || u < 0 || u > 4294967295 || _(u) !== u)
      throw new s("`length` must be a positive 32-bit integer");
    var l = arguments.length > 2 && !!arguments[2], f = !0, w = !0;
    if ("length" in c && r) {
      var y = r(c, "length");
      y && !y.configurable && (f = !1), y && !y.writable && (w = !1);
    }
    return (f || w || !l) && (e ? t(
      /** @type {Parameters<define>[0]} */
      c,
      "length",
      u,
      !0,
      !0
    ) : t(
      /** @type {Parameters<define>[0]} */
      c,
      "length",
      u
    )), c;
  }, bp;
}
var yp, wg;
function Gz() {
  if (wg) return yp;
  wg = 1;
  var n = Nu(), t = uw(), e = tm();
  return yp = function() {
    return e(n, t, arguments);
  }, yp;
}
var dg;
function lw() {
  return dg || (dg = 1, function(n) {
    var t = /* @__PURE__ */ Tz(), e = /* @__PURE__ */ Qf(), r = em(), s = Gz();
    n.exports = function(a) {
      var c = r(arguments), u = a.length - (arguments.length - 1);
      return t(
        c,
        1 + (u > 0 ? u : 0),
        !0
      );
    }, e ? e(n.exports, "apply", { value: s }) : n.exports.apply = s;
  }(wp)), wp.exports;
}
var Ap, gg;
function Uz() {
  if (gg) return Ap;
  gg = 1;
  var n = /* @__PURE__ */ fw(), t = lw(), e = t(
    /** @type {typeof String.prototype.indexOf} */
    n("String.prototype.indexOf")
  );
  return Ap = function(s, _) {
    var a = (
      /** @type {Parameters<typeof callBind>[0]} */
      n(s, !!_)
    );
    return typeof a == "function" && e(s, ".prototype.") > -1 ? t(a) : a;
  }, Ap;
}
var mp, bg;
function Fz() {
  if (bg) return mp;
  bg = 1;
  var n = aw()(), t = Uz(), e = t("Object.prototype.toString"), r = function(c) {
    return n && c && typeof c == "object" && Symbol.toStringTag in c ? !1 : e(c) === "[object Arguments]";
  }, s = function(c) {
    return r(c) ? !0 : c !== null && typeof c == "object" && "length" in c && typeof c.length == "number" && c.length >= 0 && e(c) !== "[object Array]" && "callee" in c && e(c.callee) === "[object Function]";
  }, _ = function() {
    return r(arguments);
  }();
  return r.isLegacyArguments = s, mp = _ ? r : s, mp;
}
var Sp, yg;
function Kz() {
  if (yg) return Sp;
  yg = 1;
  var n = Object.prototype.toString, t = Function.prototype.toString, e = /^\s*(?:function)?\*/, r = aw()(), s = Object.getPrototypeOf, _ = function() {
    if (!r)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, a;
  return Sp = function(u) {
    if (typeof u != "function")
      return !1;
    if (e.test(t.call(u)))
      return !0;
    if (!r) {
      var l = n.call(u);
      return l === "[object GeneratorFunction]";
    }
    if (!s)
      return !1;
    if (typeof a > "u") {
      var f = _();
      a = f ? s(f) : !1;
    }
    return s(u) === a;
  }, Sp;
}
var Rp, Ag;
function Dz() {
  if (Ag) return Rp;
  Ag = 1;
  var n = Function.prototype.toString, t = typeof Reflect == "object" && Reflect !== null && Reflect.apply, e, r;
  if (typeof t == "function" && typeof Object.defineProperty == "function")
    try {
      e = Object.defineProperty({}, "length", {
        get: function() {
          throw r;
        }
      }), r = {}, t(function() {
        throw 42;
      }, null, e);
    } catch (M) {
      M !== r && (t = null);
    }
  else
    t = null;
  var s = /^\s*class\b/, _ = function(N) {
    try {
      var I = n.call(N);
      return s.test(I);
    } catch {
      return !1;
    }
  }, a = function(N) {
    try {
      return _(N) ? !1 : (n.call(N), !0);
    } catch {
      return !1;
    }
  }, c = Object.prototype.toString, u = "[object Object]", l = "[object Function]", f = "[object GeneratorFunction]", w = "[object HTMLAllCollection]", y = "[object HTML document.all class]", v = "[object HTMLCollection]", x = typeof Symbol == "function" && !!Symbol.toStringTag, C = !(0 in [,]), U = function() {
    return !1;
  };
  if (typeof document == "object") {
    var z = document.all;
    c.call(z) === c.call(document.all) && (U = function(N) {
      if ((C || !N) && (typeof N > "u" || typeof N == "object"))
        try {
          var I = c.call(N);
          return (I === w || I === y || I === v || I === u) && N("") == null;
        } catch {
        }
      return !1;
    });
  }
  return Rp = t ? function(N) {
    if (U(N))
      return !0;
    if (!N || typeof N != "function" && typeof N != "object")
      return !1;
    try {
      t(N, null, e);
    } catch (I) {
      if (I !== r)
        return !1;
    }
    return !_(N) && a(N);
  } : function(N) {
    if (U(N))
      return !0;
    if (!N || typeof N != "function" && typeof N != "object")
      return !1;
    if (x)
      return a(N);
    if (_(N))
      return !1;
    var I = c.call(N);
    return I !== l && I !== f && !/^\[object HTML/.test(I) ? !1 : a(N);
  }, Rp;
}
var Ep, mg;
function Lz() {
  if (mg) return Ep;
  mg = 1;
  var n = Dz(), t = Object.prototype.toString, e = Object.prototype.hasOwnProperty, r = function(u, l, f) {
    for (var w = 0, y = u.length; w < y; w++)
      e.call(u, w) && (f == null ? l(u[w], w, u) : l.call(f, u[w], w, u));
  }, s = function(u, l, f) {
    for (var w = 0, y = u.length; w < y; w++)
      f == null ? l(u.charAt(w), w, u) : l.call(f, u.charAt(w), w, u);
  }, _ = function(u, l, f) {
    for (var w in u)
      e.call(u, w) && (f == null ? l(u[w], w, u) : l.call(f, u[w], w, u));
  }, a = function(u, l, f) {
    if (!n(l))
      throw new TypeError("iterator must be a function");
    var w;
    arguments.length >= 3 && (w = f), t.call(u) === "[object Array]" ? r(u, l, w) : typeof u == "string" ? s(u, l, w) : _(u, l, w);
  };
  return Ep = a, Ep;
}
var Pp, Sg;
function jz() {
  return Sg || (Sg = 1, Pp = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), Pp;
}
var zp, Rg;
function Vz() {
  if (Rg) return zp;
  Rg = 1;
  var n = /* @__PURE__ */ jz(), t = typeof globalThis > "u" ? vs : globalThis;
  return zp = function() {
    for (var r = [], s = 0; s < n.length; s++)
      typeof t[n[s]] == "function" && (r[r.length] = n[s]);
    return r;
  }, zp;
}
var vp, Eg;
function Yz() {
  if (Eg) return vp;
  Eg = 1;
  var n = /* @__PURE__ */ fw(), t = lw(), e = t(n("String.prototype.indexOf"));
  return vp = function(s, _) {
    var a = n(s, !!_);
    return typeof a == "function" && e(s, ".prototype.") > -1 ? t(a) : a;
  }, vp;
}
var Mp, Pg;
function rm() {
  if (Pg) return Mp;
  Pg = 1;
  var n = Lz(), t = /* @__PURE__ */ Vz(), e = lw(), r = Yz(), s = /* @__PURE__ */ Iu(), _ = r("Object.prototype.toString"), a = aw()(), c = typeof globalThis > "u" ? vs : globalThis, u = t(), l = r("String.prototype.slice"), f = Object.getPrototypeOf, w = r("Array.prototype.indexOf", !0) || function(U, z) {
    for (var M = 0; M < U.length; M += 1)
      if (U[M] === z)
        return M;
    return -1;
  }, y = { __proto__: null };
  a && s && f ? n(u, function(C) {
    var U = new c[C]();
    if (Symbol.toStringTag in U) {
      var z = f(U), M = s(z, Symbol.toStringTag);
      if (!M) {
        var N = f(z);
        M = s(N, Symbol.toStringTag);
      }
      y["$" + C] = e(M.get);
    }
  }) : n(u, function(C) {
    var U = new c[C](), z = U.slice || U.set;
    z && (y["$" + C] = e(z));
  });
  var v = function(U) {
    var z = !1;
    return n(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      y,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(M, N) {
        if (!z)
          try {
            "$" + M(U) === N && (z = l(N, 1));
          } catch {
          }
      }
    ), z;
  }, x = function(U) {
    var z = !1;
    return n(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      y,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(M, N) {
        if (!z)
          try {
            M(U), z = l(N, 1);
          } catch {
          }
      }
    ), z;
  };
  return Mp = function(U) {
    if (!U || typeof U != "object")
      return !1;
    if (!a) {
      var z = l(_(U), 8, -1);
      return w(u, z) > -1 ? z : z !== "Object" ? !1 : x(U);
    }
    return s ? v(U) : null;
  }, Mp;
}
var xp, zg;
function Hz() {
  if (zg) return xp;
  zg = 1;
  var n = /* @__PURE__ */ rm();
  return xp = function(e) {
    return !!n(e);
  }, xp;
}
var vg;
function qz() {
  return vg || (vg = 1, function(n) {
    var t = /* @__PURE__ */ Fz(), e = Kz(), r = /* @__PURE__ */ rm(), s = /* @__PURE__ */ Hz();
    function _(at) {
      return at.call.bind(at);
    }
    var a = typeof BigInt < "u", c = typeof Symbol < "u", u = _(Object.prototype.toString), l = _(Number.prototype.valueOf), f = _(String.prototype.valueOf), w = _(Boolean.prototype.valueOf);
    if (a)
      var y = _(BigInt.prototype.valueOf);
    if (c)
      var v = _(Symbol.prototype.valueOf);
    function x(at, ge) {
      if (typeof at != "object")
        return !1;
      try {
        return ge(at), !0;
      } catch {
        return !1;
      }
    }
    n.isArgumentsObject = t, n.isGeneratorFunction = e, n.isTypedArray = s;
    function C(at) {
      return typeof Promise < "u" && at instanceof Promise || at !== null && typeof at == "object" && typeof at.then == "function" && typeof at.catch == "function";
    }
    n.isPromise = C;
    function U(at) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(at) : s(at) || st(at);
    }
    n.isArrayBufferView = U;
    function z(at) {
      return r(at) === "Uint8Array";
    }
    n.isUint8Array = z;
    function M(at) {
      return r(at) === "Uint8ClampedArray";
    }
    n.isUint8ClampedArray = M;
    function N(at) {
      return r(at) === "Uint16Array";
    }
    n.isUint16Array = N;
    function I(at) {
      return r(at) === "Uint32Array";
    }
    n.isUint32Array = I;
    function G(at) {
      return r(at) === "Int8Array";
    }
    n.isInt8Array = G;
    function D(at) {
      return r(at) === "Int16Array";
    }
    n.isInt16Array = D;
    function j(at) {
      return r(at) === "Int32Array";
    }
    n.isInt32Array = j;
    function L(at) {
      return r(at) === "Float32Array";
    }
    n.isFloat32Array = L;
    function X(at) {
      return r(at) === "Float64Array";
    }
    n.isFloat64Array = X;
    function et(at) {
      return r(at) === "BigInt64Array";
    }
    n.isBigInt64Array = et;
    function lt(at) {
      return r(at) === "BigUint64Array";
    }
    n.isBigUint64Array = lt;
    function Y(at) {
      return u(at) === "[object Map]";
    }
    Y.working = typeof Map < "u" && Y(/* @__PURE__ */ new Map());
    function Et(at) {
      return typeof Map > "u" ? !1 : Y.working ? Y(at) : at instanceof Map;
    }
    n.isMap = Et;
    function Ct(at) {
      return u(at) === "[object Set]";
    }
    Ct.working = typeof Set < "u" && Ct(/* @__PURE__ */ new Set());
    function pt(at) {
      return typeof Set > "u" ? !1 : Ct.working ? Ct(at) : at instanceof Set;
    }
    n.isSet = pt;
    function wt(at) {
      return u(at) === "[object WeakMap]";
    }
    wt.working = typeof WeakMap < "u" && wt(/* @__PURE__ */ new WeakMap());
    function Pt(at) {
      return typeof WeakMap > "u" ? !1 : wt.working ? wt(at) : at instanceof WeakMap;
    }
    n.isWeakMap = Pt;
    function Mt(at) {
      return u(at) === "[object WeakSet]";
    }
    Mt.working = typeof WeakSet < "u" && Mt(/* @__PURE__ */ new WeakSet());
    function xt(at) {
      return Mt(at);
    }
    n.isWeakSet = xt;
    function Nt(at) {
      return u(at) === "[object ArrayBuffer]";
    }
    Nt.working = typeof ArrayBuffer < "u" && Nt(new ArrayBuffer());
    function Ht(at) {
      return typeof ArrayBuffer > "u" ? !1 : Nt.working ? Nt(at) : at instanceof ArrayBuffer;
    }
    n.isArrayBuffer = Ht;
    function J(at) {
      return u(at) === "[object DataView]";
    }
    J.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && J(new DataView(new ArrayBuffer(1), 0, 1));
    function st(at) {
      return typeof DataView > "u" ? !1 : J.working ? J(at) : at instanceof DataView;
    }
    n.isDataView = st;
    var _t = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function mt(at) {
      return u(at) === "[object SharedArrayBuffer]";
    }
    function H(at) {
      return typeof _t > "u" ? !1 : (typeof mt.working > "u" && (mt.working = mt(new _t())), mt.working ? mt(at) : at instanceof _t);
    }
    n.isSharedArrayBuffer = H;
    function V(at) {
      return u(at) === "[object AsyncFunction]";
    }
    n.isAsyncFunction = V;
    function tt(at) {
      return u(at) === "[object Map Iterator]";
    }
    n.isMapIterator = tt;
    function ut(at) {
      return u(at) === "[object Set Iterator]";
    }
    n.isSetIterator = ut;
    function dt(at) {
      return u(at) === "[object Generator]";
    }
    n.isGeneratorObject = dt;
    function B(at) {
      return u(at) === "[object WebAssembly.Module]";
    }
    n.isWebAssemblyCompiledModule = B;
    function O(at) {
      return x(at, l);
    }
    n.isNumberObject = O;
    function it(at) {
      return x(at, f);
    }
    n.isStringObject = it;
    function gt(at) {
      return x(at, w);
    }
    n.isBooleanObject = gt;
    function Ot(at) {
      return a && x(at, y);
    }
    n.isBigIntObject = Ot;
    function vt(at) {
      return c && x(at, v);
    }
    n.isSymbolObject = vt;
    function It(at) {
      return O(at) || it(at) || gt(at) || Ot(at) || vt(at);
    }
    n.isBoxedPrimitive = It;
    function re(at) {
      return typeof Uint8Array < "u" && (Ht(at) || H(at));
    }
    n.isAnyArrayBuffer = re, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(at) {
      Object.defineProperty(n, at, {
        enumerable: !1,
        value: function() {
          throw new Error(at + " is not supported in userland");
        }
      });
    });
  }(Fl)), Fl;
}
var Bp, Mg;
function Qz() {
  return Mg || (Mg = 1, Bp = function(t) {
    return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
  }), Bp;
}
var Hu = { exports: {} }, xg;
function Nc() {
  return xg || (xg = 1, typeof Object.create == "function" ? Hu.exports = function(t, e) {
    e && (t.super_ = e, t.prototype = Object.create(e.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Hu.exports = function(t, e) {
    if (e) {
      t.super_ = e;
      var r = function() {
      };
      r.prototype = e.prototype, t.prototype = new r(), t.prototype.constructor = t;
    }
  }), Hu.exports;
}
var Bg;
function nm() {
  return Bg || (Bg = 1, function(n) {
    var t = Object.getOwnPropertyDescriptors || function(st) {
      for (var _t = Object.keys(st), mt = {}, H = 0; H < _t.length; H++)
        mt[_t[H]] = Object.getOwnPropertyDescriptor(st, _t[H]);
      return mt;
    }, e = /%[sdj%]/g;
    n.format = function(J) {
      if (!G(J)) {
        for (var st = [], _t = 0; _t < arguments.length; _t++)
          st.push(a(arguments[_t]));
        return st.join(" ");
      }
      for (var _t = 1, mt = arguments, H = mt.length, V = String(J).replace(e, function(ut) {
        if (ut === "%%") return "%";
        if (_t >= H) return ut;
        switch (ut) {
          case "%s":
            return String(mt[_t++]);
          case "%d":
            return Number(mt[_t++]);
          case "%j":
            try {
              return JSON.stringify(mt[_t++]);
            } catch {
              return "[Circular]";
            }
          default:
            return ut;
        }
      }), tt = mt[_t]; _t < H; tt = mt[++_t])
        M(tt) || !X(tt) ? V += " " + tt : V += " " + a(tt);
      return V;
    }, n.deprecate = function(J, st) {
      if (typeof Kt < "u" && Kt.noDeprecation === !0)
        return J;
      if (typeof Kt > "u")
        return function() {
          return n.deprecate(J, st).apply(this, arguments);
        };
      var _t = !1;
      function mt() {
        if (!_t) {
          if (Kt.throwDeprecation)
            throw new Error(st);
          Kt.traceDeprecation ? console.trace(st) : console.error(st), _t = !0;
        }
        return J.apply(this, arguments);
      }
      return mt;
    };
    var r = {}, s = /^$/;
    if (Kt.env.NODE_DEBUG) {
      var _ = Kt.env.NODE_DEBUG;
      _ = _.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), s = new RegExp("^" + _ + "$", "i");
    }
    n.debuglog = function(J) {
      if (J = J.toUpperCase(), !r[J])
        if (s.test(J)) {
          var st = Kt.pid;
          r[J] = function() {
            var _t = n.format.apply(n, arguments);
            console.error("%s %d: %s", J, st, _t);
          };
        } else
          r[J] = function() {
          };
      return r[J];
    };
    function a(J, st) {
      var _t = {
        seen: [],
        stylize: u
      };
      return arguments.length >= 3 && (_t.depth = arguments[2]), arguments.length >= 4 && (_t.colors = arguments[3]), z(st) ? _t.showHidden = st : st && n._extend(_t, st), j(_t.showHidden) && (_t.showHidden = !1), j(_t.depth) && (_t.depth = 2), j(_t.colors) && (_t.colors = !1), j(_t.customInspect) && (_t.customInspect = !0), _t.colors && (_t.stylize = c), f(_t, J, _t.depth);
    }
    n.inspect = a, a.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, a.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function c(J, st) {
      var _t = a.styles[st];
      return _t ? "\x1B[" + a.colors[_t][0] + "m" + J + "\x1B[" + a.colors[_t][1] + "m" : J;
    }
    function u(J, st) {
      return J;
    }
    function l(J) {
      var st = {};
      return J.forEach(function(_t, mt) {
        st[_t] = !0;
      }), st;
    }
    function f(J, st, _t) {
      if (J.customInspect && st && Y(st.inspect) && // Filter out the util module, it's inspect function is special
      st.inspect !== n.inspect && // Also filter out any prototype objects using the circular check.
      !(st.constructor && st.constructor.prototype === st)) {
        var mt = st.inspect(_t, J);
        return G(mt) || (mt = f(J, mt, _t)), mt;
      }
      var H = w(J, st);
      if (H)
        return H;
      var V = Object.keys(st), tt = l(V);
      if (J.showHidden && (V = Object.getOwnPropertyNames(st)), lt(st) && (V.indexOf("message") >= 0 || V.indexOf("description") >= 0))
        return y(st);
      if (V.length === 0) {
        if (Y(st)) {
          var ut = st.name ? ": " + st.name : "";
          return J.stylize("[Function" + ut + "]", "special");
        }
        if (L(st))
          return J.stylize(RegExp.prototype.toString.call(st), "regexp");
        if (et(st))
          return J.stylize(Date.prototype.toString.call(st), "date");
        if (lt(st))
          return y(st);
      }
      var dt = "", B = !1, O = ["{", "}"];
      if (U(st) && (B = !0, O = ["[", "]"]), Y(st)) {
        var it = st.name ? ": " + st.name : "";
        dt = " [Function" + it + "]";
      }
      if (L(st) && (dt = " " + RegExp.prototype.toString.call(st)), et(st) && (dt = " " + Date.prototype.toUTCString.call(st)), lt(st) && (dt = " " + y(st)), V.length === 0 && (!B || st.length == 0))
        return O[0] + dt + O[1];
      if (_t < 0)
        return L(st) ? J.stylize(RegExp.prototype.toString.call(st), "regexp") : J.stylize("[Object]", "special");
      J.seen.push(st);
      var gt;
      return B ? gt = v(J, st, _t, tt, V) : gt = V.map(function(Ot) {
        return x(J, st, _t, tt, Ot, B);
      }), J.seen.pop(), C(gt, dt, O);
    }
    function w(J, st) {
      if (j(st))
        return J.stylize("undefined", "undefined");
      if (G(st)) {
        var _t = "'" + JSON.stringify(st).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return J.stylize(_t, "string");
      }
      if (I(st))
        return J.stylize("" + st, "number");
      if (z(st))
        return J.stylize("" + st, "boolean");
      if (M(st))
        return J.stylize("null", "null");
    }
    function y(J) {
      return "[" + Error.prototype.toString.call(J) + "]";
    }
    function v(J, st, _t, mt, H) {
      for (var V = [], tt = 0, ut = st.length; tt < ut; ++tt)
        Mt(st, String(tt)) ? V.push(x(
          J,
          st,
          _t,
          mt,
          String(tt),
          !0
        )) : V.push("");
      return H.forEach(function(dt) {
        dt.match(/^\d+$/) || V.push(x(
          J,
          st,
          _t,
          mt,
          dt,
          !0
        ));
      }), V;
    }
    function x(J, st, _t, mt, H, V) {
      var tt, ut, dt;
      if (dt = Object.getOwnPropertyDescriptor(st, H) || { value: st[H] }, dt.get ? dt.set ? ut = J.stylize("[Getter/Setter]", "special") : ut = J.stylize("[Getter]", "special") : dt.set && (ut = J.stylize("[Setter]", "special")), Mt(mt, H) || (tt = "[" + H + "]"), ut || (J.seen.indexOf(dt.value) < 0 ? (M(_t) ? ut = f(J, dt.value, null) : ut = f(J, dt.value, _t - 1), ut.indexOf(`
`) > -1 && (V ? ut = ut.split(`
`).map(function(B) {
        return "  " + B;
      }).join(`
`).slice(2) : ut = `
` + ut.split(`
`).map(function(B) {
        return "   " + B;
      }).join(`
`))) : ut = J.stylize("[Circular]", "special")), j(tt)) {
        if (V && H.match(/^\d+$/))
          return ut;
        tt = JSON.stringify("" + H), tt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (tt = tt.slice(1, -1), tt = J.stylize(tt, "name")) : (tt = tt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), tt = J.stylize(tt, "string"));
      }
      return tt + ": " + ut;
    }
    function C(J, st, _t) {
      var mt = J.reduce(function(H, V) {
        return V.indexOf(`
`) >= 0, H + V.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return mt > 60 ? _t[0] + (st === "" ? "" : st + `
 `) + " " + J.join(`,
  `) + " " + _t[1] : _t[0] + st + " " + J.join(", ") + " " + _t[1];
    }
    n.types = qz();
    function U(J) {
      return Array.isArray(J);
    }
    n.isArray = U;
    function z(J) {
      return typeof J == "boolean";
    }
    n.isBoolean = z;
    function M(J) {
      return J === null;
    }
    n.isNull = M;
    function N(J) {
      return J == null;
    }
    n.isNullOrUndefined = N;
    function I(J) {
      return typeof J == "number";
    }
    n.isNumber = I;
    function G(J) {
      return typeof J == "string";
    }
    n.isString = G;
    function D(J) {
      return typeof J == "symbol";
    }
    n.isSymbol = D;
    function j(J) {
      return J === void 0;
    }
    n.isUndefined = j;
    function L(J) {
      return X(J) && Ct(J) === "[object RegExp]";
    }
    n.isRegExp = L, n.types.isRegExp = L;
    function X(J) {
      return typeof J == "object" && J !== null;
    }
    n.isObject = X;
    function et(J) {
      return X(J) && Ct(J) === "[object Date]";
    }
    n.isDate = et, n.types.isDate = et;
    function lt(J) {
      return X(J) && (Ct(J) === "[object Error]" || J instanceof Error);
    }
    n.isError = lt, n.types.isNativeError = lt;
    function Y(J) {
      return typeof J == "function";
    }
    n.isFunction = Y;
    function Et(J) {
      return J === null || typeof J == "boolean" || typeof J == "number" || typeof J == "string" || typeof J == "symbol" || // ES6 symbol
      typeof J > "u";
    }
    n.isPrimitive = Et, n.isBuffer = Qz();
    function Ct(J) {
      return Object.prototype.toString.call(J);
    }
    function pt(J) {
      return J < 10 ? "0" + J.toString(10) : J.toString(10);
    }
    var wt = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function Pt() {
      var J = /* @__PURE__ */ new Date(), st = [
        pt(J.getHours()),
        pt(J.getMinutes()),
        pt(J.getSeconds())
      ].join(":");
      return [J.getDate(), wt[J.getMonth()], st].join(" ");
    }
    n.log = function() {
      console.log("%s - %s", Pt(), n.format.apply(n, arguments));
    }, n.inherits = Nc(), n._extend = function(J, st) {
      if (!st || !X(st)) return J;
      for (var _t = Object.keys(st), mt = _t.length; mt--; )
        J[_t[mt]] = st[_t[mt]];
      return J;
    };
    function Mt(J, st) {
      return Object.prototype.hasOwnProperty.call(J, st);
    }
    var xt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    n.promisify = function(st) {
      if (typeof st != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (xt && st[xt]) {
        var _t = st[xt];
        if (typeof _t != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(_t, xt, {
          value: _t,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), _t;
      }
      function _t() {
        for (var mt, H, V = new Promise(function(dt, B) {
          mt = dt, H = B;
        }), tt = [], ut = 0; ut < arguments.length; ut++)
          tt.push(arguments[ut]);
        tt.push(function(dt, B) {
          dt ? H(dt) : mt(B);
        });
        try {
          st.apply(this, tt);
        } catch (dt) {
          H(dt);
        }
        return V;
      }
      return Object.setPrototypeOf(_t, Object.getPrototypeOf(st)), xt && Object.defineProperty(_t, xt, {
        value: _t,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        _t,
        t(st)
      );
    }, n.promisify.custom = xt;
    function Nt(J, st) {
      if (!J) {
        var _t = new Error("Promise was rejected with a falsy value");
        _t.reason = J, J = _t;
      }
      return st(J);
    }
    function Ht(J) {
      if (typeof J != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function st() {
        for (var _t = [], mt = 0; mt < arguments.length; mt++)
          _t.push(arguments[mt]);
        var H = _t.pop();
        if (typeof H != "function")
          throw new TypeError("The last argument must be of type Function");
        var V = this, tt = function() {
          return H.apply(V, arguments);
        };
        J.apply(this, _t).then(
          function(ut) {
            Kt.nextTick(tt.bind(null, null, ut));
          },
          function(ut) {
            Kt.nextTick(Nt.bind(null, ut, tt));
          }
        );
      }
      return Object.setPrototypeOf(st, Object.getPrototypeOf(J)), Object.defineProperties(
        st,
        t(J)
      ), st;
    }
    n.callbackify = Ht;
  }(Ul)), Ul;
}
var Cp, Cg;
function Wz() {
  if (Cg) return Cp;
  Cg = 1;
  function n(x, C) {
    var U = Object.keys(x);
    if (Object.getOwnPropertySymbols) {
      var z = Object.getOwnPropertySymbols(x);
      C && (z = z.filter(function(M) {
        return Object.getOwnPropertyDescriptor(x, M).enumerable;
      })), U.push.apply(U, z);
    }
    return U;
  }
  function t(x) {
    for (var C = 1; C < arguments.length; C++) {
      var U = arguments[C] != null ? arguments[C] : {};
      C % 2 ? n(Object(U), !0).forEach(function(z) {
        e(x, z, U[z]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(x, Object.getOwnPropertyDescriptors(U)) : n(Object(U)).forEach(function(z) {
        Object.defineProperty(x, z, Object.getOwnPropertyDescriptor(U, z));
      });
    }
    return x;
  }
  function e(x, C, U) {
    return C = a(C), C in x ? Object.defineProperty(x, C, { value: U, enumerable: !0, configurable: !0, writable: !0 }) : x[C] = U, x;
  }
  function r(x, C) {
    if (!(x instanceof C))
      throw new TypeError("Cannot call a class as a function");
  }
  function s(x, C) {
    for (var U = 0; U < C.length; U++) {
      var z = C[U];
      z.enumerable = z.enumerable || !1, z.configurable = !0, "value" in z && (z.writable = !0), Object.defineProperty(x, a(z.key), z);
    }
  }
  function _(x, C, U) {
    return C && s(x.prototype, C), Object.defineProperty(x, "prototype", { writable: !1 }), x;
  }
  function a(x) {
    var C = c(x, "string");
    return typeof C == "symbol" ? C : String(C);
  }
  function c(x, C) {
    if (typeof x != "object" || x === null) return x;
    var U = x[Symbol.toPrimitive];
    if (U !== void 0) {
      var z = U.call(x, C);
      if (typeof z != "object") return z;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(x);
  }
  var u = Hf(), l = u.Buffer, f = nm(), w = f.inspect, y = w && w.custom || "inspect";
  function v(x, C, U) {
    l.prototype.copy.call(x, C, U);
  }
  return Cp = /* @__PURE__ */ function() {
    function x() {
      r(this, x), this.head = null, this.tail = null, this.length = 0;
    }
    return _(x, [{
      key: "push",
      value: function(U) {
        var z = {
          data: U,
          next: null
        };
        this.length > 0 ? this.tail.next = z : this.head = z, this.tail = z, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(U) {
        var z = {
          data: U,
          next: this.head
        };
        this.length === 0 && (this.tail = z), this.head = z, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var U = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, U;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(U) {
        if (this.length === 0) return "";
        for (var z = this.head, M = "" + z.data; z = z.next; ) M += U + z.data;
        return M;
      }
    }, {
      key: "concat",
      value: function(U) {
        if (this.length === 0) return l.alloc(0);
        for (var z = l.allocUnsafe(U >>> 0), M = this.head, N = 0; M; )
          v(M.data, z, N), N += M.data.length, M = M.next;
        return z;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(U, z) {
        var M;
        return U < this.head.data.length ? (M = this.head.data.slice(0, U), this.head.data = this.head.data.slice(U)) : U === this.head.data.length ? M = this.shift() : M = z ? this._getString(U) : this._getBuffer(U), M;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(U) {
        var z = this.head, M = 1, N = z.data;
        for (U -= N.length; z = z.next; ) {
          var I = z.data, G = U > I.length ? I.length : U;
          if (G === I.length ? N += I : N += I.slice(0, U), U -= G, U === 0) {
            G === I.length ? (++M, z.next ? this.head = z.next : this.head = this.tail = null) : (this.head = z, z.data = I.slice(G));
            break;
          }
          ++M;
        }
        return this.length -= M, N;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(U) {
        var z = l.allocUnsafe(U), M = this.head, N = 1;
        for (M.data.copy(z), U -= M.data.length; M = M.next; ) {
          var I = M.data, G = U > I.length ? I.length : U;
          if (I.copy(z, z.length - U, 0, G), U -= G, U === 0) {
            G === I.length ? (++N, M.next ? this.head = M.next : this.head = this.tail = null) : (this.head = M, M.data = I.slice(G));
            break;
          }
          ++N;
        }
        return this.length -= N, z;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: y,
      value: function(U, z) {
        return w(this, t(t({}, z), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), x;
  }(), Cp;
}
var Ip, Ig;
function im() {
  if (Ig) return Ip;
  Ig = 1;
  function n(a, c) {
    var u = this, l = this._readableState && this._readableState.destroyed, f = this._writableState && this._writableState.destroyed;
    return l || f ? (c ? c(a) : a && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Kt.nextTick(s, this, a)) : Kt.nextTick(s, this, a)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(a || null, function(w) {
      !c && w ? u._writableState ? u._writableState.errorEmitted ? Kt.nextTick(e, u) : (u._writableState.errorEmitted = !0, Kt.nextTick(t, u, w)) : Kt.nextTick(t, u, w) : c ? (Kt.nextTick(e, u), c(w)) : Kt.nextTick(e, u);
    }), this);
  }
  function t(a, c) {
    s(a, c), e(a);
  }
  function e(a) {
    a._writableState && !a._writableState.emitClose || a._readableState && !a._readableState.emitClose || a.emit("close");
  }
  function r() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function s(a, c) {
    a.emit("error", c);
  }
  function _(a, c) {
    var u = a._readableState, l = a._writableState;
    u && u.autoDestroy || l && l.autoDestroy ? a.destroy(c) : a.emit("error", c);
  }
  return Ip = {
    destroy: n,
    undestroy: r,
    errorOrDestroy: _
  }, Ip;
}
var Np = {}, Ng;
function Oc() {
  if (Ng) return Np;
  Ng = 1;
  function n(c, u) {
    c.prototype = Object.create(u.prototype), c.prototype.constructor = c, c.__proto__ = u;
  }
  var t = {};
  function e(c, u, l) {
    l || (l = Error);
    function f(y, v, x) {
      return typeof u == "string" ? u : u(y, v, x);
    }
    var w = /* @__PURE__ */ function(y) {
      n(v, y);
      function v(x, C, U) {
        return y.call(this, f(x, C, U)) || this;
      }
      return v;
    }(l);
    w.prototype.name = l.name, w.prototype.code = c, t[c] = w;
  }
  function r(c, u) {
    if (Array.isArray(c)) {
      var l = c.length;
      return c = c.map(function(f) {
        return String(f);
      }), l > 2 ? "one of ".concat(u, " ").concat(c.slice(0, l - 1).join(", "), ", or ") + c[l - 1] : l === 2 ? "one of ".concat(u, " ").concat(c[0], " or ").concat(c[1]) : "of ".concat(u, " ").concat(c[0]);
    } else
      return "of ".concat(u, " ").concat(String(c));
  }
  function s(c, u, l) {
    return c.substr(0, u.length) === u;
  }
  function _(c, u, l) {
    return (l === void 0 || l > c.length) && (l = c.length), c.substring(l - u.length, l) === u;
  }
  function a(c, u, l) {
    return typeof l != "number" && (l = 0), l + u.length > c.length ? !1 : c.indexOf(u, l) !== -1;
  }
  return e("ERR_INVALID_OPT_VALUE", function(c, u) {
    return 'The value "' + u + '" is invalid for option "' + c + '"';
  }, TypeError), e("ERR_INVALID_ARG_TYPE", function(c, u, l) {
    var f;
    typeof u == "string" && s(u, "not ") ? (f = "must not be", u = u.replace(/^not /, "")) : f = "must be";
    var w;
    if (_(c, " argument"))
      w = "The ".concat(c, " ").concat(f, " ").concat(r(u, "type"));
    else {
      var y = a(c, ".") ? "property" : "argument";
      w = 'The "'.concat(c, '" ').concat(y, " ").concat(f, " ").concat(r(u, "type"));
    }
    return w += ". Received type ".concat(typeof l), w;
  }, TypeError), e("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), e("ERR_METHOD_NOT_IMPLEMENTED", function(c) {
    return "The " + c + " method is not implemented";
  }), e("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), e("ERR_STREAM_DESTROYED", function(c) {
    return "Cannot call " + c + " after a stream was destroyed";
  }), e("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), e("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), e("ERR_STREAM_WRITE_AFTER_END", "write after end"), e("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), e("ERR_UNKNOWN_ENCODING", function(c) {
    return "Unknown encoding: " + c;
  }, TypeError), e("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), Np.codes = t, Np;
}
var Op, Og;
function sm() {
  if (Og) return Op;
  Og = 1;
  var n = Oc().codes.ERR_INVALID_OPT_VALUE;
  function t(r, s, _) {
    return r.highWaterMark != null ? r.highWaterMark : s ? r[_] : null;
  }
  function e(r, s, _, a) {
    var c = t(s, a, _);
    if (c != null) {
      if (!(isFinite(c) && Math.floor(c) === c) || c < 0) {
        var u = a ? _ : "highWaterMark";
        throw new n(u, c);
      }
      return Math.floor(c);
    }
    return r.objectMode ? 16 : 16 * 1024;
  }
  return Op = {
    getHighWaterMark: e
  }, Op;
}
var kp, kg;
function Jz() {
  if (kg) return kp;
  kg = 1, kp = n;
  function n(e, r) {
    if (t("noDeprecation"))
      return e;
    var s = !1;
    function _() {
      if (!s) {
        if (t("throwDeprecation"))
          throw new Error(r);
        t("traceDeprecation") ? console.trace(r) : console.warn(r), s = !0;
      }
      return e.apply(this, arguments);
    }
    return _;
  }
  function t(e) {
    try {
      if (!vs.localStorage) return !1;
    } catch {
      return !1;
    }
    var r = vs.localStorage[e];
    return r == null ? !1 : String(r).toLowerCase() === "true";
  }
  return kp;
}
var Tp, Tg;
function _m() {
  if (Tg) return Tp;
  Tg = 1, Tp = L;
  function n(H) {
    var V = this;
    this.next = null, this.entry = null, this.finish = function() {
      mt(V, H);
    };
  }
  var t;
  L.WritableState = D;
  var e = {
    deprecate: Jz()
  }, r = $2(), s = Hf().Buffer, _ = (typeof vs < "u" ? vs : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(H) {
    return s.from(H);
  }
  function c(H) {
    return s.isBuffer(H) || H instanceof _;
  }
  var u = im(), l = sm(), f = l.getHighWaterMark, w = Oc().codes, y = w.ERR_INVALID_ARG_TYPE, v = w.ERR_METHOD_NOT_IMPLEMENTED, x = w.ERR_MULTIPLE_CALLBACK, C = w.ERR_STREAM_CANNOT_PIPE, U = w.ERR_STREAM_DESTROYED, z = w.ERR_STREAM_NULL_VALUES, M = w.ERR_STREAM_WRITE_AFTER_END, N = w.ERR_UNKNOWN_ENCODING, I = u.errorOrDestroy;
  Nc()(L, r);
  function G() {
  }
  function D(H, V, tt) {
    t = t || Bc(), H = H || {}, typeof tt != "boolean" && (tt = V instanceof t), this.objectMode = !!H.objectMode, tt && (this.objectMode = this.objectMode || !!H.writableObjectMode), this.highWaterMark = f(this, H, "writableHighWaterMark", tt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ut = H.decodeStrings === !1;
    this.decodeStrings = !ut, this.defaultEncoding = H.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(dt) {
      wt(V, dt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = H.emitClose !== !1, this.autoDestroy = !!H.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new n(this);
  }
  D.prototype.getBuffer = function() {
    for (var V = this.bufferedRequest, tt = []; V; )
      tt.push(V), V = V.next;
    return tt;
  }, function() {
    try {
      Object.defineProperty(D.prototype, "buffer", {
        get: e.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var j;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (j = Function.prototype[Symbol.hasInstance], Object.defineProperty(L, Symbol.hasInstance, {
    value: function(V) {
      return j.call(this, V) ? !0 : this !== L ? !1 : V && V._writableState instanceof D;
    }
  })) : j = function(V) {
    return V instanceof this;
  };
  function L(H) {
    t = t || Bc();
    var V = this instanceof t;
    if (!V && !j.call(L, this)) return new L(H);
    this._writableState = new D(H, this, V), this.writable = !0, H && (typeof H.write == "function" && (this._write = H.write), typeof H.writev == "function" && (this._writev = H.writev), typeof H.destroy == "function" && (this._destroy = H.destroy), typeof H.final == "function" && (this._final = H.final)), r.call(this);
  }
  L.prototype.pipe = function() {
    I(this, new C());
  };
  function X(H, V) {
    var tt = new M();
    I(H, tt), Kt.nextTick(V, tt);
  }
  function et(H, V, tt, ut) {
    var dt;
    return tt === null ? dt = new z() : typeof tt != "string" && !V.objectMode && (dt = new y("chunk", ["string", "Buffer"], tt)), dt ? (I(H, dt), Kt.nextTick(ut, dt), !1) : !0;
  }
  L.prototype.write = function(H, V, tt) {
    var ut = this._writableState, dt = !1, B = !ut.objectMode && c(H);
    return B && !s.isBuffer(H) && (H = a(H)), typeof V == "function" && (tt = V, V = null), B ? V = "buffer" : V || (V = ut.defaultEncoding), typeof tt != "function" && (tt = G), ut.ending ? X(this, tt) : (B || et(this, ut, H, tt)) && (ut.pendingcb++, dt = Y(this, ut, B, H, V, tt)), dt;
  }, L.prototype.cork = function() {
    this._writableState.corked++;
  }, L.prototype.uncork = function() {
    var H = this._writableState;
    H.corked && (H.corked--, !H.writing && !H.corked && !H.bufferProcessing && H.bufferedRequest && xt(this, H));
  }, L.prototype.setDefaultEncoding = function(V) {
    if (typeof V == "string" && (V = V.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((V + "").toLowerCase()) > -1)) throw new N(V);
    return this._writableState.defaultEncoding = V, this;
  }, Object.defineProperty(L.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function lt(H, V, tt) {
    return !H.objectMode && H.decodeStrings !== !1 && typeof V == "string" && (V = s.from(V, tt)), V;
  }
  Object.defineProperty(L.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Y(H, V, tt, ut, dt, B) {
    if (!tt) {
      var O = lt(V, ut, dt);
      ut !== O && (tt = !0, dt = "buffer", ut = O);
    }
    var it = V.objectMode ? 1 : ut.length;
    V.length += it;
    var gt = V.length < V.highWaterMark;
    if (gt || (V.needDrain = !0), V.writing || V.corked) {
      var Ot = V.lastBufferedRequest;
      V.lastBufferedRequest = {
        chunk: ut,
        encoding: dt,
        isBuf: tt,
        callback: B,
        next: null
      }, Ot ? Ot.next = V.lastBufferedRequest : V.bufferedRequest = V.lastBufferedRequest, V.bufferedRequestCount += 1;
    } else
      Et(H, V, !1, it, ut, dt, B);
    return gt;
  }
  function Et(H, V, tt, ut, dt, B, O) {
    V.writelen = ut, V.writecb = O, V.writing = !0, V.sync = !0, V.destroyed ? V.onwrite(new U("write")) : tt ? H._writev(dt, V.onwrite) : H._write(dt, B, V.onwrite), V.sync = !1;
  }
  function Ct(H, V, tt, ut, dt) {
    --V.pendingcb, tt ? (Kt.nextTick(dt, ut), Kt.nextTick(st, H, V), H._writableState.errorEmitted = !0, I(H, ut)) : (dt(ut), H._writableState.errorEmitted = !0, I(H, ut), st(H, V));
  }
  function pt(H) {
    H.writing = !1, H.writecb = null, H.length -= H.writelen, H.writelen = 0;
  }
  function wt(H, V) {
    var tt = H._writableState, ut = tt.sync, dt = tt.writecb;
    if (typeof dt != "function") throw new x();
    if (pt(tt), V) Ct(H, tt, ut, V, dt);
    else {
      var B = Nt(tt) || H.destroyed;
      !B && !tt.corked && !tt.bufferProcessing && tt.bufferedRequest && xt(H, tt), ut ? Kt.nextTick(Pt, H, tt, B, dt) : Pt(H, tt, B, dt);
    }
  }
  function Pt(H, V, tt, ut) {
    tt || Mt(H, V), V.pendingcb--, ut(), st(H, V);
  }
  function Mt(H, V) {
    V.length === 0 && V.needDrain && (V.needDrain = !1, H.emit("drain"));
  }
  function xt(H, V) {
    V.bufferProcessing = !0;
    var tt = V.bufferedRequest;
    if (H._writev && tt && tt.next) {
      var ut = V.bufferedRequestCount, dt = new Array(ut), B = V.corkedRequestsFree;
      B.entry = tt;
      for (var O = 0, it = !0; tt; )
        dt[O] = tt, tt.isBuf || (it = !1), tt = tt.next, O += 1;
      dt.allBuffers = it, Et(H, V, !0, V.length, dt, "", B.finish), V.pendingcb++, V.lastBufferedRequest = null, B.next ? (V.corkedRequestsFree = B.next, B.next = null) : V.corkedRequestsFree = new n(V), V.bufferedRequestCount = 0;
    } else {
      for (; tt; ) {
        var gt = tt.chunk, Ot = tt.encoding, vt = tt.callback, It = V.objectMode ? 1 : gt.length;
        if (Et(H, V, !1, It, gt, Ot, vt), tt = tt.next, V.bufferedRequestCount--, V.writing)
          break;
      }
      tt === null && (V.lastBufferedRequest = null);
    }
    V.bufferedRequest = tt, V.bufferProcessing = !1;
  }
  L.prototype._write = function(H, V, tt) {
    tt(new v("_write()"));
  }, L.prototype._writev = null, L.prototype.end = function(H, V, tt) {
    var ut = this._writableState;
    return typeof H == "function" ? (tt = H, H = null, V = null) : typeof V == "function" && (tt = V, V = null), H != null && this.write(H, V), ut.corked && (ut.corked = 1, this.uncork()), ut.ending || _t(this, ut, tt), this;
  }, Object.defineProperty(L.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function Nt(H) {
    return H.ending && H.length === 0 && H.bufferedRequest === null && !H.finished && !H.writing;
  }
  function Ht(H, V) {
    H._final(function(tt) {
      V.pendingcb--, tt && I(H, tt), V.prefinished = !0, H.emit("prefinish"), st(H, V);
    });
  }
  function J(H, V) {
    !V.prefinished && !V.finalCalled && (typeof H._final == "function" && !V.destroyed ? (V.pendingcb++, V.finalCalled = !0, Kt.nextTick(Ht, H, V)) : (V.prefinished = !0, H.emit("prefinish")));
  }
  function st(H, V) {
    var tt = Nt(V);
    if (tt && (J(H, V), V.pendingcb === 0 && (V.finished = !0, H.emit("finish"), V.autoDestroy))) {
      var ut = H._readableState;
      (!ut || ut.autoDestroy && ut.endEmitted) && H.destroy();
    }
    return tt;
  }
  function _t(H, V, tt) {
    V.ending = !0, st(H, V), tt && (V.finished ? Kt.nextTick(tt) : H.once("finish", tt)), V.ended = !0, H.writable = !1;
  }
  function mt(H, V, tt) {
    var ut = H.entry;
    for (H.entry = null; ut; ) {
      var dt = ut.callback;
      V.pendingcb--, dt(tt), ut = ut.next;
    }
    V.corkedRequestsFree.next = H;
  }
  return Object.defineProperty(L.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(V) {
      this._writableState && (this._writableState.destroyed = V);
    }
  }), L.prototype.destroy = u.destroy, L.prototype._undestroy = u.undestroy, L.prototype._destroy = function(H, V) {
    V(H);
  }, Tp;
}
var Gp, Gg;
function Bc() {
  if (Gg) return Gp;
  Gg = 1;
  var n = Object.keys || function(l) {
    var f = [];
    for (var w in l) f.push(w);
    return f;
  };
  Gp = a;
  var t = om(), e = _m();
  Nc()(a, t);
  for (var r = n(e.prototype), s = 0; s < r.length; s++) {
    var _ = r[s];
    a.prototype[_] || (a.prototype[_] = e.prototype[_]);
  }
  function a(l) {
    if (!(this instanceof a)) return new a(l);
    t.call(this, l), e.call(this, l), this.allowHalfOpen = !0, l && (l.readable === !1 && (this.readable = !1), l.writable === !1 && (this.writable = !1), l.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", c)));
  }
  Object.defineProperty(a.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(a.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(a.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function c() {
    this._writableState.ended || Kt.nextTick(u, this);
  }
  function u(l) {
    l.end();
  }
  return Object.defineProperty(a.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(f) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = f, this._writableState.destroyed = f);
    }
  }), Gp;
}
var Up = {}, qu = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var Ug;
function $z() {
  return Ug || (Ug = 1, function(n, t) {
    var e = Hf(), r = e.Buffer;
    function s(a, c) {
      for (var u in a)
        c[u] = a[u];
    }
    r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? n.exports = e : (s(e, t), t.Buffer = _);
    function _(a, c, u) {
      return r(a, c, u);
    }
    _.prototype = Object.create(r.prototype), s(r, _), _.from = function(a, c, u) {
      if (typeof a == "number")
        throw new TypeError("Argument must not be a number");
      return r(a, c, u);
    }, _.alloc = function(a, c, u) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      var l = r(a);
      return c !== void 0 ? typeof u == "string" ? l.fill(c, u) : l.fill(c) : l.fill(0), l;
    }, _.allocUnsafe = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return r(a);
    }, _.allocUnsafeSlow = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return e.SlowBuffer(a);
    };
  }(qu, qu.exports)), qu.exports;
}
var Fg;
function Kg() {
  if (Fg) return Up;
  Fg = 1;
  var n = $z().Buffer, t = n.isEncoding || function(z) {
    switch (z = "" + z, z && z.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function e(z) {
    if (!z) return "utf8";
    for (var M; ; )
      switch (z) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return z;
        default:
          if (M) return;
          z = ("" + z).toLowerCase(), M = !0;
      }
  }
  function r(z) {
    var M = e(z);
    if (typeof M != "string" && (n.isEncoding === t || !t(z))) throw new Error("Unknown encoding: " + z);
    return M || z;
  }
  Up.StringDecoder = s;
  function s(z) {
    this.encoding = r(z);
    var M;
    switch (this.encoding) {
      case "utf16le":
        this.text = w, this.end = y, M = 4;
        break;
      case "utf8":
        this.fillLast = u, M = 4;
        break;
      case "base64":
        this.text = v, this.end = x, M = 3;
        break;
      default:
        this.write = C, this.end = U;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(M);
  }
  s.prototype.write = function(z) {
    if (z.length === 0) return "";
    var M, N;
    if (this.lastNeed) {
      if (M = this.fillLast(z), M === void 0) return "";
      N = this.lastNeed, this.lastNeed = 0;
    } else
      N = 0;
    return N < z.length ? M ? M + this.text(z, N) : this.text(z, N) : M || "";
  }, s.prototype.end = f, s.prototype.text = l, s.prototype.fillLast = function(z) {
    if (this.lastNeed <= z.length)
      return z.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    z.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, z.length), this.lastNeed -= z.length;
  };
  function _(z) {
    return z <= 127 ? 0 : z >> 5 === 6 ? 2 : z >> 4 === 14 ? 3 : z >> 3 === 30 ? 4 : z >> 6 === 2 ? -1 : -2;
  }
  function a(z, M, N) {
    var I = M.length - 1;
    if (I < N) return 0;
    var G = _(M[I]);
    return G >= 0 ? (G > 0 && (z.lastNeed = G - 1), G) : --I < N || G === -2 ? 0 : (G = _(M[I]), G >= 0 ? (G > 0 && (z.lastNeed = G - 2), G) : --I < N || G === -2 ? 0 : (G = _(M[I]), G >= 0 ? (G > 0 && (G === 2 ? G = 0 : z.lastNeed = G - 3), G) : 0));
  }
  function c(z, M, N) {
    if ((M[0] & 192) !== 128)
      return z.lastNeed = 0, "�";
    if (z.lastNeed > 1 && M.length > 1) {
      if ((M[1] & 192) !== 128)
        return z.lastNeed = 1, "�";
      if (z.lastNeed > 2 && M.length > 2 && (M[2] & 192) !== 128)
        return z.lastNeed = 2, "�";
    }
  }
  function u(z) {
    var M = this.lastTotal - this.lastNeed, N = c(this, z);
    if (N !== void 0) return N;
    if (this.lastNeed <= z.length)
      return z.copy(this.lastChar, M, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    z.copy(this.lastChar, M, 0, z.length), this.lastNeed -= z.length;
  }
  function l(z, M) {
    var N = a(this, z, M);
    if (!this.lastNeed) return z.toString("utf8", M);
    this.lastTotal = N;
    var I = z.length - (N - this.lastNeed);
    return z.copy(this.lastChar, 0, I), z.toString("utf8", M, I);
  }
  function f(z) {
    var M = z && z.length ? this.write(z) : "";
    return this.lastNeed ? M + "�" : M;
  }
  function w(z, M) {
    if ((z.length - M) % 2 === 0) {
      var N = z.toString("utf16le", M);
      if (N) {
        var I = N.charCodeAt(N.length - 1);
        if (I >= 55296 && I <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = z[z.length - 2], this.lastChar[1] = z[z.length - 1], N.slice(0, -1);
      }
      return N;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = z[z.length - 1], z.toString("utf16le", M, z.length - 1);
  }
  function y(z) {
    var M = z && z.length ? this.write(z) : "";
    if (this.lastNeed) {
      var N = this.lastTotal - this.lastNeed;
      return M + this.lastChar.toString("utf16le", 0, N);
    }
    return M;
  }
  function v(z, M) {
    var N = (z.length - M) % 3;
    return N === 0 ? z.toString("base64", M) : (this.lastNeed = 3 - N, this.lastTotal = 3, N === 1 ? this.lastChar[0] = z[z.length - 1] : (this.lastChar[0] = z[z.length - 2], this.lastChar[1] = z[z.length - 1]), z.toString("base64", M, z.length - N));
  }
  function x(z) {
    var M = z && z.length ? this.write(z) : "";
    return this.lastNeed ? M + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : M;
  }
  function C(z) {
    return z.toString(this.encoding);
  }
  function U(z) {
    return z && z.length ? this.write(z) : "";
  }
  return Up;
}
var Fp, Dg;
function pw() {
  if (Dg) return Fp;
  Dg = 1;
  var n = Oc().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(_) {
    var a = !1;
    return function() {
      if (!a) {
        a = !0;
        for (var c = arguments.length, u = new Array(c), l = 0; l < c; l++)
          u[l] = arguments[l];
        _.apply(this, u);
      }
    };
  }
  function e() {
  }
  function r(_) {
    return _.setHeader && typeof _.abort == "function";
  }
  function s(_, a, c) {
    if (typeof a == "function") return s(_, null, a);
    a || (a = {}), c = t(c || e);
    var u = a.readable || a.readable !== !1 && _.readable, l = a.writable || a.writable !== !1 && _.writable, f = function() {
      _.writable || y();
    }, w = _._writableState && _._writableState.finished, y = function() {
      l = !1, w = !0, u || c.call(_);
    }, v = _._readableState && _._readableState.endEmitted, x = function() {
      u = !1, v = !0, l || c.call(_);
    }, C = function(N) {
      c.call(_, N);
    }, U = function() {
      var N;
      if (u && !v)
        return (!_._readableState || !_._readableState.ended) && (N = new n()), c.call(_, N);
      if (l && !w)
        return (!_._writableState || !_._writableState.ended) && (N = new n()), c.call(_, N);
    }, z = function() {
      _.req.on("finish", y);
    };
    return r(_) ? (_.on("complete", y), _.on("abort", U), _.req ? z() : _.on("request", z)) : l && !_._writableState && (_.on("end", f), _.on("close", f)), _.on("end", x), _.on("finish", y), a.error !== !1 && _.on("error", C), _.on("close", U), function() {
      _.removeListener("complete", y), _.removeListener("abort", U), _.removeListener("request", z), _.req && _.req.removeListener("finish", y), _.removeListener("end", f), _.removeListener("close", f), _.removeListener("finish", y), _.removeListener("end", x), _.removeListener("error", C), _.removeListener("close", U);
    };
  }
  return Fp = s, Fp;
}
var Kp, Lg;
function Zz() {
  if (Lg) return Kp;
  Lg = 1;
  var n;
  function t(N, I, G) {
    return I = e(I), I in N ? Object.defineProperty(N, I, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : N[I] = G, N;
  }
  function e(N) {
    var I = r(N, "string");
    return typeof I == "symbol" ? I : String(I);
  }
  function r(N, I) {
    if (typeof N != "object" || N === null) return N;
    var G = N[Symbol.toPrimitive];
    if (G !== void 0) {
      var D = G.call(N, I);
      if (typeof D != "object") return D;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (I === "string" ? String : Number)(N);
  }
  var s = pw(), _ = Symbol("lastResolve"), a = Symbol("lastReject"), c = Symbol("error"), u = Symbol("ended"), l = Symbol("lastPromise"), f = Symbol("handlePromise"), w = Symbol("stream");
  function y(N, I) {
    return {
      value: N,
      done: I
    };
  }
  function v(N) {
    var I = N[_];
    if (I !== null) {
      var G = N[w].read();
      G !== null && (N[l] = null, N[_] = null, N[a] = null, I(y(G, !1)));
    }
  }
  function x(N) {
    Kt.nextTick(v, N);
  }
  function C(N, I) {
    return function(G, D) {
      N.then(function() {
        if (I[u]) {
          G(y(void 0, !0));
          return;
        }
        I[f](G, D);
      }, D);
    };
  }
  var U = Object.getPrototypeOf(function() {
  }), z = Object.setPrototypeOf((n = {
    get stream() {
      return this[w];
    },
    next: function() {
      var I = this, G = this[c];
      if (G !== null)
        return Promise.reject(G);
      if (this[u])
        return Promise.resolve(y(void 0, !0));
      if (this[w].destroyed)
        return new Promise(function(X, et) {
          Kt.nextTick(function() {
            I[c] ? et(I[c]) : X(y(void 0, !0));
          });
        });
      var D = this[l], j;
      if (D)
        j = new Promise(C(D, this));
      else {
        var L = this[w].read();
        if (L !== null)
          return Promise.resolve(y(L, !1));
        j = new Promise(this[f]);
      }
      return this[l] = j, j;
    }
  }, t(n, Symbol.asyncIterator, function() {
    return this;
  }), t(n, "return", function() {
    var I = this;
    return new Promise(function(G, D) {
      I[w].destroy(null, function(j) {
        if (j) {
          D(j);
          return;
        }
        G(y(void 0, !0));
      });
    });
  }), n), U), M = function(I) {
    var G, D = Object.create(z, (G = {}, t(G, w, {
      value: I,
      writable: !0
    }), t(G, _, {
      value: null,
      writable: !0
    }), t(G, a, {
      value: null,
      writable: !0
    }), t(G, c, {
      value: null,
      writable: !0
    }), t(G, u, {
      value: I._readableState.endEmitted,
      writable: !0
    }), t(G, f, {
      value: function(L, X) {
        var et = D[w].read();
        et ? (D[l] = null, D[_] = null, D[a] = null, L(y(et, !1))) : (D[_] = L, D[a] = X);
      },
      writable: !0
    }), G));
    return D[l] = null, s(I, function(j) {
      if (j && j.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var L = D[a];
        L !== null && (D[l] = null, D[_] = null, D[a] = null, L(j)), D[c] = j;
        return;
      }
      var X = D[_];
      X !== null && (D[l] = null, D[_] = null, D[a] = null, X(y(void 0, !0))), D[u] = !0;
    }), I.on("readable", x.bind(null, D)), D;
  };
  return Kp = M, Kp;
}
var Dp, jg;
function Xz() {
  return jg || (jg = 1, Dp = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Dp;
}
var Lp, Vg;
function om() {
  if (Vg) return Lp;
  Vg = 1, Lp = X;
  var n;
  X.ReadableState = L, J2().EventEmitter;
  var t = function(O, it) {
    return O.listeners(it).length;
  }, e = $2(), r = Hf().Buffer, s = (typeof vs < "u" ? vs : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _(B) {
    return r.from(B);
  }
  function a(B) {
    return r.isBuffer(B) || B instanceof s;
  }
  var c = nm(), u;
  c && c.debuglog ? u = c.debuglog("stream") : u = function() {
  };
  var l = Wz(), f = im(), w = sm(), y = w.getHighWaterMark, v = Oc().codes, x = v.ERR_INVALID_ARG_TYPE, C = v.ERR_STREAM_PUSH_AFTER_EOF, U = v.ERR_METHOD_NOT_IMPLEMENTED, z = v.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, M, N, I;
  Nc()(X, e);
  var G = f.errorOrDestroy, D = ["error", "close", "destroy", "pause", "resume"];
  function j(B, O, it) {
    if (typeof B.prependListener == "function") return B.prependListener(O, it);
    !B._events || !B._events[O] ? B.on(O, it) : Array.isArray(B._events[O]) ? B._events[O].unshift(it) : B._events[O] = [it, B._events[O]];
  }
  function L(B, O, it) {
    n = n || Bc(), B = B || {}, typeof it != "boolean" && (it = O instanceof n), this.objectMode = !!B.objectMode, it && (this.objectMode = this.objectMode || !!B.readableObjectMode), this.highWaterMark = y(this, B, "readableHighWaterMark", it), this.buffer = new l(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = B.emitClose !== !1, this.autoDestroy = !!B.autoDestroy, this.destroyed = !1, this.defaultEncoding = B.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, B.encoding && (M || (M = Kg().StringDecoder), this.decoder = new M(B.encoding), this.encoding = B.encoding);
  }
  function X(B) {
    if (n = n || Bc(), !(this instanceof X)) return new X(B);
    var O = this instanceof n;
    this._readableState = new L(B, this, O), this.readable = !0, B && (typeof B.read == "function" && (this._read = B.read), typeof B.destroy == "function" && (this._destroy = B.destroy)), e.call(this);
  }
  Object.defineProperty(X.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(O) {
      this._readableState && (this._readableState.destroyed = O);
    }
  }), X.prototype.destroy = f.destroy, X.prototype._undestroy = f.undestroy, X.prototype._destroy = function(B, O) {
    O(B);
  }, X.prototype.push = function(B, O) {
    var it = this._readableState, gt;
    return it.objectMode ? gt = !0 : typeof B == "string" && (O = O || it.defaultEncoding, O !== it.encoding && (B = r.from(B, O), O = ""), gt = !0), et(this, B, O, !1, gt);
  }, X.prototype.unshift = function(B) {
    return et(this, B, null, !0, !1);
  };
  function et(B, O, it, gt, Ot) {
    u("readableAddChunk", O);
    var vt = B._readableState;
    if (O === null)
      vt.reading = !1, wt(B, vt);
    else {
      var It;
      if (Ot || (It = Y(vt, O)), It)
        G(B, It);
      else if (vt.objectMode || O && O.length > 0)
        if (typeof O != "string" && !vt.objectMode && Object.getPrototypeOf(O) !== r.prototype && (O = _(O)), gt)
          vt.endEmitted ? G(B, new z()) : lt(B, vt, O, !0);
        else if (vt.ended)
          G(B, new C());
        else {
          if (vt.destroyed)
            return !1;
          vt.reading = !1, vt.decoder && !it ? (O = vt.decoder.write(O), vt.objectMode || O.length !== 0 ? lt(B, vt, O, !1) : xt(B, vt)) : lt(B, vt, O, !1);
        }
      else gt || (vt.reading = !1, xt(B, vt));
    }
    return !vt.ended && (vt.length < vt.highWaterMark || vt.length === 0);
  }
  function lt(B, O, it, gt) {
    O.flowing && O.length === 0 && !O.sync ? (O.awaitDrain = 0, B.emit("data", it)) : (O.length += O.objectMode ? 1 : it.length, gt ? O.buffer.unshift(it) : O.buffer.push(it), O.needReadable && Pt(B)), xt(B, O);
  }
  function Y(B, O) {
    var it;
    return !a(O) && typeof O != "string" && O !== void 0 && !B.objectMode && (it = new x("chunk", ["string", "Buffer", "Uint8Array"], O)), it;
  }
  X.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, X.prototype.setEncoding = function(B) {
    M || (M = Kg().StringDecoder);
    var O = new M(B);
    this._readableState.decoder = O, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var it = this._readableState.buffer.head, gt = ""; it !== null; )
      gt += O.write(it.data), it = it.next;
    return this._readableState.buffer.clear(), gt !== "" && this._readableState.buffer.push(gt), this._readableState.length = gt.length, this;
  };
  var Et = 1073741824;
  function Ct(B) {
    return B >= Et ? B = Et : (B--, B |= B >>> 1, B |= B >>> 2, B |= B >>> 4, B |= B >>> 8, B |= B >>> 16, B++), B;
  }
  function pt(B, O) {
    return B <= 0 || O.length === 0 && O.ended ? 0 : O.objectMode ? 1 : B !== B ? O.flowing && O.length ? O.buffer.head.data.length : O.length : (B > O.highWaterMark && (O.highWaterMark = Ct(B)), B <= O.length ? B : O.ended ? O.length : (O.needReadable = !0, 0));
  }
  X.prototype.read = function(B) {
    u("read", B), B = parseInt(B, 10);
    var O = this._readableState, it = B;
    if (B !== 0 && (O.emittedReadable = !1), B === 0 && O.needReadable && ((O.highWaterMark !== 0 ? O.length >= O.highWaterMark : O.length > 0) || O.ended))
      return u("read: emitReadable", O.length, O.ended), O.length === 0 && O.ended ? tt(this) : Pt(this), null;
    if (B = pt(B, O), B === 0 && O.ended)
      return O.length === 0 && tt(this), null;
    var gt = O.needReadable;
    u("need readable", gt), (O.length === 0 || O.length - B < O.highWaterMark) && (gt = !0, u("length less than watermark", gt)), O.ended || O.reading ? (gt = !1, u("reading or ended", gt)) : gt && (u("do read"), O.reading = !0, O.sync = !0, O.length === 0 && (O.needReadable = !0), this._read(O.highWaterMark), O.sync = !1, O.reading || (B = pt(it, O)));
    var Ot;
    return B > 0 ? Ot = V(B, O) : Ot = null, Ot === null ? (O.needReadable = O.length <= O.highWaterMark, B = 0) : (O.length -= B, O.awaitDrain = 0), O.length === 0 && (O.ended || (O.needReadable = !0), it !== B && O.ended && tt(this)), Ot !== null && this.emit("data", Ot), Ot;
  };
  function wt(B, O) {
    if (u("onEofChunk"), !O.ended) {
      if (O.decoder) {
        var it = O.decoder.end();
        it && it.length && (O.buffer.push(it), O.length += O.objectMode ? 1 : it.length);
      }
      O.ended = !0, O.sync ? Pt(B) : (O.needReadable = !1, O.emittedReadable || (O.emittedReadable = !0, Mt(B)));
    }
  }
  function Pt(B) {
    var O = B._readableState;
    u("emitReadable", O.needReadable, O.emittedReadable), O.needReadable = !1, O.emittedReadable || (u("emitReadable", O.flowing), O.emittedReadable = !0, Kt.nextTick(Mt, B));
  }
  function Mt(B) {
    var O = B._readableState;
    u("emitReadable_", O.destroyed, O.length, O.ended), !O.destroyed && (O.length || O.ended) && (B.emit("readable"), O.emittedReadable = !1), O.needReadable = !O.flowing && !O.ended && O.length <= O.highWaterMark, H(B);
  }
  function xt(B, O) {
    O.readingMore || (O.readingMore = !0, Kt.nextTick(Nt, B, O));
  }
  function Nt(B, O) {
    for (; !O.reading && !O.ended && (O.length < O.highWaterMark || O.flowing && O.length === 0); ) {
      var it = O.length;
      if (u("maybeReadMore read 0"), B.read(0), it === O.length)
        break;
    }
    O.readingMore = !1;
  }
  X.prototype._read = function(B) {
    G(this, new U("_read()"));
  }, X.prototype.pipe = function(B, O) {
    var it = this, gt = this._readableState;
    switch (gt.pipesCount) {
      case 0:
        gt.pipes = B;
        break;
      case 1:
        gt.pipes = [gt.pipes, B];
        break;
      default:
        gt.pipes.push(B);
        break;
    }
    gt.pipesCount += 1, u("pipe count=%d opts=%j", gt.pipesCount, O);
    var Ot = (!O || O.end !== !1) && B !== Kt.stdout && B !== Kt.stderr, vt = Ot ? re : xe;
    gt.endEmitted ? Kt.nextTick(vt) : it.once("end", vt), B.on("unpipe", It);
    function It(Fe, ce) {
      u("onunpipe"), Fe === it && ce && ce.hasUnpiped === !1 && (ce.hasUnpiped = !0, Ge());
    }
    function re() {
      u("onend"), B.end();
    }
    var at = Ht(it);
    B.on("drain", at);
    var ge = !1;
    function Ge() {
      u("cleanup"), B.removeListener("close", Ue), B.removeListener("finish", we), B.removeListener("drain", at), B.removeListener("error", ie), B.removeListener("unpipe", It), it.removeListener("end", re), it.removeListener("end", xe), it.removeListener("data", Zt), ge = !0, gt.awaitDrain && (!B._writableState || B._writableState.needDrain) && at();
    }
    it.on("data", Zt);
    function Zt(Fe) {
      u("ondata");
      var ce = B.write(Fe);
      u("dest.write", ce), ce === !1 && ((gt.pipesCount === 1 && gt.pipes === B || gt.pipesCount > 1 && dt(gt.pipes, B) !== -1) && !ge && (u("false write response, pause", gt.awaitDrain), gt.awaitDrain++), it.pause());
    }
    function ie(Fe) {
      u("onerror", Fe), xe(), B.removeListener("error", ie), t(B, "error") === 0 && G(B, Fe);
    }
    j(B, "error", ie);
    function Ue() {
      B.removeListener("finish", we), xe();
    }
    B.once("close", Ue);
    function we() {
      u("onfinish"), B.removeListener("close", Ue), xe();
    }
    B.once("finish", we);
    function xe() {
      u("unpipe"), it.unpipe(B);
    }
    return B.emit("pipe", it), gt.flowing || (u("pipe resume"), it.resume()), B;
  };
  function Ht(B) {
    return function() {
      var it = B._readableState;
      u("pipeOnDrain", it.awaitDrain), it.awaitDrain && it.awaitDrain--, it.awaitDrain === 0 && t(B, "data") && (it.flowing = !0, H(B));
    };
  }
  X.prototype.unpipe = function(B) {
    var O = this._readableState, it = {
      hasUnpiped: !1
    };
    if (O.pipesCount === 0) return this;
    if (O.pipesCount === 1)
      return B && B !== O.pipes ? this : (B || (B = O.pipes), O.pipes = null, O.pipesCount = 0, O.flowing = !1, B && B.emit("unpipe", this, it), this);
    if (!B) {
      var gt = O.pipes, Ot = O.pipesCount;
      O.pipes = null, O.pipesCount = 0, O.flowing = !1;
      for (var vt = 0; vt < Ot; vt++) gt[vt].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var It = dt(O.pipes, B);
    return It === -1 ? this : (O.pipes.splice(It, 1), O.pipesCount -= 1, O.pipesCount === 1 && (O.pipes = O.pipes[0]), B.emit("unpipe", this, it), this);
  }, X.prototype.on = function(B, O) {
    var it = e.prototype.on.call(this, B, O), gt = this._readableState;
    return B === "data" ? (gt.readableListening = this.listenerCount("readable") > 0, gt.flowing !== !1 && this.resume()) : B === "readable" && !gt.endEmitted && !gt.readableListening && (gt.readableListening = gt.needReadable = !0, gt.flowing = !1, gt.emittedReadable = !1, u("on readable", gt.length, gt.reading), gt.length ? Pt(this) : gt.reading || Kt.nextTick(st, this)), it;
  }, X.prototype.addListener = X.prototype.on, X.prototype.removeListener = function(B, O) {
    var it = e.prototype.removeListener.call(this, B, O);
    return B === "readable" && Kt.nextTick(J, this), it;
  }, X.prototype.removeAllListeners = function(B) {
    var O = e.prototype.removeAllListeners.apply(this, arguments);
    return (B === "readable" || B === void 0) && Kt.nextTick(J, this), O;
  };
  function J(B) {
    var O = B._readableState;
    O.readableListening = B.listenerCount("readable") > 0, O.resumeScheduled && !O.paused ? O.flowing = !0 : B.listenerCount("data") > 0 && B.resume();
  }
  function st(B) {
    u("readable nexttick read 0"), B.read(0);
  }
  X.prototype.resume = function() {
    var B = this._readableState;
    return B.flowing || (u("resume"), B.flowing = !B.readableListening, _t(this, B)), B.paused = !1, this;
  };
  function _t(B, O) {
    O.resumeScheduled || (O.resumeScheduled = !0, Kt.nextTick(mt, B, O));
  }
  function mt(B, O) {
    u("resume", O.reading), O.reading || B.read(0), O.resumeScheduled = !1, B.emit("resume"), H(B), O.flowing && !O.reading && B.read(0);
  }
  X.prototype.pause = function() {
    return u("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (u("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function H(B) {
    var O = B._readableState;
    for (u("flow", O.flowing); O.flowing && B.read() !== null; ) ;
  }
  X.prototype.wrap = function(B) {
    var O = this, it = this._readableState, gt = !1;
    B.on("end", function() {
      if (u("wrapped end"), it.decoder && !it.ended) {
        var It = it.decoder.end();
        It && It.length && O.push(It);
      }
      O.push(null);
    }), B.on("data", function(It) {
      if (u("wrapped data"), it.decoder && (It = it.decoder.write(It)), !(it.objectMode && It == null) && !(!it.objectMode && (!It || !It.length))) {
        var re = O.push(It);
        re || (gt = !0, B.pause());
      }
    });
    for (var Ot in B)
      this[Ot] === void 0 && typeof B[Ot] == "function" && (this[Ot] = /* @__PURE__ */ function(re) {
        return function() {
          return B[re].apply(B, arguments);
        };
      }(Ot));
    for (var vt = 0; vt < D.length; vt++)
      B.on(D[vt], this.emit.bind(this, D[vt]));
    return this._read = function(It) {
      u("wrapped _read", It), gt && (gt = !1, B.resume());
    }, this;
  }, typeof Symbol == "function" && (X.prototype[Symbol.asyncIterator] = function() {
    return N === void 0 && (N = Zz()), N(this);
  }), Object.defineProperty(X.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(X.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(X.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(O) {
      this._readableState && (this._readableState.flowing = O);
    }
  }), X._fromList = V, Object.defineProperty(X.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function V(B, O) {
    if (O.length === 0) return null;
    var it;
    return O.objectMode ? it = O.buffer.shift() : !B || B >= O.length ? (O.decoder ? it = O.buffer.join("") : O.buffer.length === 1 ? it = O.buffer.first() : it = O.buffer.concat(O.length), O.buffer.clear()) : it = O.buffer.consume(B, O.decoder), it;
  }
  function tt(B) {
    var O = B._readableState;
    u("endReadable", O.endEmitted), O.endEmitted || (O.ended = !0, Kt.nextTick(ut, O, B));
  }
  function ut(B, O) {
    if (u("endReadableNT", B.endEmitted, B.length), !B.endEmitted && B.length === 0 && (B.endEmitted = !0, O.readable = !1, O.emit("end"), B.autoDestroy)) {
      var it = O._writableState;
      (!it || it.autoDestroy && it.finished) && O.destroy();
    }
  }
  typeof Symbol == "function" && (X.from = function(B, O) {
    return I === void 0 && (I = Xz()), I(X, B, O);
  });
  function dt(B, O) {
    for (var it = 0, gt = B.length; it < gt; it++)
      if (B[it] === O) return it;
    return -1;
  }
  return Lp;
}
var jp, Yg;
function am() {
  if (Yg) return jp;
  Yg = 1, jp = c;
  var n = Oc().codes, t = n.ERR_METHOD_NOT_IMPLEMENTED, e = n.ERR_MULTIPLE_CALLBACK, r = n.ERR_TRANSFORM_ALREADY_TRANSFORMING, s = n.ERR_TRANSFORM_WITH_LENGTH_0, _ = Bc();
  Nc()(c, _);
  function a(f, w) {
    var y = this._transformState;
    y.transforming = !1;
    var v = y.writecb;
    if (v === null)
      return this.emit("error", new e());
    y.writechunk = null, y.writecb = null, w != null && this.push(w), v(f);
    var x = this._readableState;
    x.reading = !1, (x.needReadable || x.length < x.highWaterMark) && this._read(x.highWaterMark);
  }
  function c(f) {
    if (!(this instanceof c)) return new c(f);
    _.call(this, f), this._transformState = {
      afterTransform: a.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, f && (typeof f.transform == "function" && (this._transform = f.transform), typeof f.flush == "function" && (this._flush = f.flush)), this.on("prefinish", u);
  }
  function u() {
    var f = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(w, y) {
      l(f, w, y);
    }) : l(this, null, null);
  }
  c.prototype.push = function(f, w) {
    return this._transformState.needTransform = !1, _.prototype.push.call(this, f, w);
  }, c.prototype._transform = function(f, w, y) {
    y(new t("_transform()"));
  }, c.prototype._write = function(f, w, y) {
    var v = this._transformState;
    if (v.writecb = y, v.writechunk = f, v.writeencoding = w, !v.transforming) {
      var x = this._readableState;
      (v.needTransform || x.needReadable || x.length < x.highWaterMark) && this._read(x.highWaterMark);
    }
  }, c.prototype._read = function(f) {
    var w = this._transformState;
    w.writechunk !== null && !w.transforming ? (w.transforming = !0, this._transform(w.writechunk, w.writeencoding, w.afterTransform)) : w.needTransform = !0;
  }, c.prototype._destroy = function(f, w) {
    _.prototype._destroy.call(this, f, function(y) {
      w(y);
    });
  };
  function l(f, w, y) {
    if (w) return f.emit("error", w);
    if (y != null && f.push(y), f._writableState.length) throw new s();
    if (f._transformState.transforming) throw new r();
    return f.push(null);
  }
  return jp;
}
var Vp, Hg;
function tv() {
  if (Hg) return Vp;
  Hg = 1, Vp = t;
  var n = am();
  Nc()(t, n);
  function t(e) {
    if (!(this instanceof t)) return new t(e);
    n.call(this, e);
  }
  return t.prototype._transform = function(e, r, s) {
    s(null, e);
  }, Vp;
}
var Yp, qg;
function ev() {
  if (qg) return Yp;
  qg = 1;
  var n;
  function t(y) {
    var v = !1;
    return function() {
      v || (v = !0, y.apply(void 0, arguments));
    };
  }
  var e = Oc().codes, r = e.ERR_MISSING_ARGS, s = e.ERR_STREAM_DESTROYED;
  function _(y) {
    if (y) throw y;
  }
  function a(y) {
    return y.setHeader && typeof y.abort == "function";
  }
  function c(y, v, x, C) {
    C = t(C);
    var U = !1;
    y.on("close", function() {
      U = !0;
    }), n === void 0 && (n = pw()), n(y, {
      readable: v,
      writable: x
    }, function(M) {
      if (M) return C(M);
      U = !0, C();
    });
    var z = !1;
    return function(M) {
      if (!U && !z) {
        if (z = !0, a(y)) return y.abort();
        if (typeof y.destroy == "function") return y.destroy();
        C(M || new s("pipe"));
      }
    };
  }
  function u(y) {
    y();
  }
  function l(y, v) {
    return y.pipe(v);
  }
  function f(y) {
    return !y.length || typeof y[y.length - 1] != "function" ? _ : y.pop();
  }
  function w() {
    for (var y = arguments.length, v = new Array(y), x = 0; x < y; x++)
      v[x] = arguments[x];
    var C = f(v);
    if (Array.isArray(v[0]) && (v = v[0]), v.length < 2)
      throw new r("streams");
    var U, z = v.map(function(M, N) {
      var I = N < v.length - 1, G = N > 0;
      return c(M, I, G, function(D) {
        U || (U = D), D && z.forEach(u), !I && (z.forEach(u), C(U));
      });
    });
    return v.reduce(l);
  }
  return Yp = w, Yp;
}
var Qg;
function cm() {
  return Qg || (Qg = 1, function(n, t) {
    t = n.exports = om(), t.Stream = t, t.Readable = t, t.Writable = _m(), t.Duplex = Bc(), t.Transform = am(), t.PassThrough = tv(), t.finished = pw(), t.pipeline = ev();
  }(Vu, Vu.exports)), Vu.exports;
}
var Hp, Wg;
function rv() {
  if (Wg) return Hp;
  Wg = 1;
  const { Transform: n } = cm();
  return Hp = (t) => class um extends n {
    constructor(r, s, _, a, c) {
      super(c), this._rate = r, this._capacity = s, this._delimitedSuffix = _, this._hashBitLength = a, this._options = c, this._state = new t(), this._state.initialize(r, s), this._finalized = !1;
    }
    _transform(r, s, _) {
      let a = null;
      try {
        this.update(r, s);
      } catch (c) {
        a = c;
      }
      _(a);
    }
    _flush(r) {
      let s = null;
      try {
        this.push(this.digest());
      } catch (_) {
        s = _;
      }
      r(s);
    }
    update(r, s) {
      if (!Rr.isBuffer(r) && typeof r != "string") throw new TypeError("Data must be a string or a buffer");
      if (this._finalized) throw new Error("Digest already called");
      return Rr.isBuffer(r) || (r = Rr.from(r, s)), this._state.absorb(r), this;
    }
    digest(r) {
      if (this._finalized) throw new Error("Digest already called");
      this._finalized = !0, this._delimitedSuffix && this._state.absorbLastFewBits(this._delimitedSuffix);
      let s = this._state.squeeze(this._hashBitLength / 8);
      return r !== void 0 && (s = s.toString(r)), this._resetState(), s;
    }
    // remove result from memory
    _resetState() {
      return this._state.initialize(this._rate, this._capacity), this;
    }
    // because sometimes we need hash right now and little later
    _clone() {
      const r = new um(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
      return this._state.copy(r._state), r._finalized = this._finalized, r;
    }
  }, Hp;
}
var qp, Jg;
function nv() {
  if (Jg) return qp;
  Jg = 1;
  const { Transform: n } = cm();
  return qp = (t) => class fm extends n {
    constructor(r, s, _, a) {
      super(a), this._rate = r, this._capacity = s, this._delimitedSuffix = _, this._options = a, this._state = new t(), this._state.initialize(r, s), this._finalized = !1;
    }
    _transform(r, s, _) {
      let a = null;
      try {
        this.update(r, s);
      } catch (c) {
        a = c;
      }
      _(a);
    }
    _flush() {
    }
    _read(r) {
      this.push(this.squeeze(r));
    }
    update(r, s) {
      if (!Rr.isBuffer(r) && typeof r != "string") throw new TypeError("Data must be a string or a buffer");
      if (this._finalized) throw new Error("Squeeze already called");
      return Rr.isBuffer(r) || (r = Rr.from(r, s)), this._state.absorb(r), this;
    }
    squeeze(r, s) {
      this._finalized || (this._finalized = !0, this._state.absorbLastFewBits(this._delimitedSuffix));
      let _ = this._state.squeeze(r);
      return s !== void 0 && (_ = _.toString(s)), _;
    }
    _resetState() {
      return this._state.initialize(this._rate, this._capacity), this;
    }
    _clone() {
      const r = new fm(this._rate, this._capacity, this._delimitedSuffix, this._options);
      return this._state.copy(r._state), r._finalized = this._finalized, r;
    }
  }, qp;
}
var Qp, $g;
function iv() {
  if ($g) return Qp;
  $g = 1;
  const n = rv(), t = nv();
  return Qp = function(e) {
    const r = n(e), s = t(e);
    return function(_, a) {
      switch (typeof _ == "string" ? _.toLowerCase() : _) {
        case "keccak224":
          return new r(1152, 448, null, 224, a);
        case "keccak256":
          return new r(1088, 512, null, 256, a);
        case "keccak384":
          return new r(832, 768, null, 384, a);
        case "keccak512":
          return new r(576, 1024, null, 512, a);
        case "sha3-224":
          return new r(1152, 448, 6, 224, a);
        case "sha3-256":
          return new r(1088, 512, 6, 256, a);
        case "sha3-384":
          return new r(832, 768, 6, 384, a);
        case "sha3-512":
          return new r(576, 1024, 6, 512, a);
        case "shake128":
          return new s(1344, 256, 31, a);
        case "shake256":
          return new s(1088, 512, 31, a);
        default:
          throw new Error("Invald algorithm: " + _);
      }
    };
  }, Qp;
}
var Wp = {}, Zg;
function sv() {
  if (Zg) return Wp;
  Zg = 1;
  const n = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  return Wp.p1600 = function(t) {
    for (let e = 0; e < 24; ++e) {
      const r = t[0] ^ t[10] ^ t[20] ^ t[30] ^ t[40], s = t[1] ^ t[11] ^ t[21] ^ t[31] ^ t[41], _ = t[2] ^ t[12] ^ t[22] ^ t[32] ^ t[42], a = t[3] ^ t[13] ^ t[23] ^ t[33] ^ t[43], c = t[4] ^ t[14] ^ t[24] ^ t[34] ^ t[44], u = t[5] ^ t[15] ^ t[25] ^ t[35] ^ t[45], l = t[6] ^ t[16] ^ t[26] ^ t[36] ^ t[46], f = t[7] ^ t[17] ^ t[27] ^ t[37] ^ t[47], w = t[8] ^ t[18] ^ t[28] ^ t[38] ^ t[48], y = t[9] ^ t[19] ^ t[29] ^ t[39] ^ t[49];
      let v = w ^ (_ << 1 | a >>> 31), x = y ^ (a << 1 | _ >>> 31);
      const C = t[0] ^ v, U = t[1] ^ x, z = t[10] ^ v, M = t[11] ^ x, N = t[20] ^ v, I = t[21] ^ x, G = t[30] ^ v, D = t[31] ^ x, j = t[40] ^ v, L = t[41] ^ x;
      v = r ^ (c << 1 | u >>> 31), x = s ^ (u << 1 | c >>> 31);
      const X = t[2] ^ v, et = t[3] ^ x, lt = t[12] ^ v, Y = t[13] ^ x, Et = t[22] ^ v, Ct = t[23] ^ x, pt = t[32] ^ v, wt = t[33] ^ x, Pt = t[42] ^ v, Mt = t[43] ^ x;
      v = _ ^ (l << 1 | f >>> 31), x = a ^ (f << 1 | l >>> 31);
      const xt = t[4] ^ v, Nt = t[5] ^ x, Ht = t[14] ^ v, J = t[15] ^ x, st = t[24] ^ v, _t = t[25] ^ x, mt = t[34] ^ v, H = t[35] ^ x, V = t[44] ^ v, tt = t[45] ^ x;
      v = c ^ (w << 1 | y >>> 31), x = u ^ (y << 1 | w >>> 31);
      const ut = t[6] ^ v, dt = t[7] ^ x, B = t[16] ^ v, O = t[17] ^ x, it = t[26] ^ v, gt = t[27] ^ x, Ot = t[36] ^ v, vt = t[37] ^ x, It = t[46] ^ v, re = t[47] ^ x;
      v = l ^ (r << 1 | s >>> 31), x = f ^ (s << 1 | r >>> 31);
      const at = t[8] ^ v, ge = t[9] ^ x, Ge = t[18] ^ v, Zt = t[19] ^ x, ie = t[28] ^ v, Ue = t[29] ^ x, we = t[38] ^ v, xe = t[39] ^ x, Fe = t[48] ^ v, ce = t[49] ^ x, tr = C, E = U, p = M << 4 | z >>> 28, d = z << 4 | M >>> 28, k = N << 3 | I >>> 29, q = I << 3 | N >>> 29, Z = D << 9 | G >>> 23, ct = G << 9 | D >>> 23, kt = j << 18 | L >>> 14, Qt = L << 18 | j >>> 14, Wt = X << 1 | et >>> 31, Jt = et << 1 | X >>> 31, Dt = Y << 12 | lt >>> 20, Xi = lt << 12 | Y >>> 20, Ke = Et << 10 | Ct >>> 22, Bs = Ct << 10 | Et >>> 22, Gc = wt << 13 | pt >>> 19, er = pt << 13 | wt >>> 19, Uc = Pt << 2 | Mt >>> 30, P = Mt << 2 | Pt >>> 30, h = Nt << 30 | xt >>> 2, g = xt << 30 | Nt >>> 2, T = Ht << 6 | J >>> 26, Q = J << 6 | Ht >>> 26, rt = _t << 11 | st >>> 21, ft = st << 11 | _t >>> 21, Tt = mt << 15 | H >>> 17, Xt = H << 15 | mt >>> 17, $t = tt << 29 | V >>> 3, te = V << 29 | tt >>> 3, qt = ut << 28 | dt >>> 4, Zf = dt << 28 | ut >>> 4, Xf = O << 23 | B >>> 9, tl = B << 23 | O >>> 9, el = it << 25 | gt >>> 7, rl = gt << 25 | it >>> 7, nl = Ot << 21 | vt >>> 11, il = vt << 21 | Ot >>> 11, sl = re << 24 | It >>> 8, _l = It << 24 | re >>> 8, ol = at << 27 | ge >>> 5, al = ge << 27 | at >>> 5, cl = Ge << 20 | Zt >>> 12, ul = Zt << 20 | Ge >>> 12, fl = Ue << 7 | ie >>> 25, ll = ie << 7 | Ue >>> 25, pl = we << 8 | xe >>> 24, hl = xe << 8 | we >>> 24, wl = Fe << 14 | ce >>> 18, dl = ce << 14 | Fe >>> 18;
      t[0] = tr ^ ~Dt & rt, t[1] = E ^ ~Xi & ft, t[10] = qt ^ ~cl & k, t[11] = Zf ^ ~ul & q, t[20] = Wt ^ ~T & el, t[21] = Jt ^ ~Q & rl, t[30] = ol ^ ~p & Ke, t[31] = al ^ ~d & Bs, t[40] = h ^ ~Xf & fl, t[41] = g ^ ~tl & ll, t[2] = Dt ^ ~rt & nl, t[3] = Xi ^ ~ft & il, t[12] = cl ^ ~k & Gc, t[13] = ul ^ ~q & er, t[22] = T ^ ~el & pl, t[23] = Q ^ ~rl & hl, t[32] = p ^ ~Ke & Tt, t[33] = d ^ ~Bs & Xt, t[42] = Xf ^ ~fl & Z, t[43] = tl ^ ~ll & ct, t[4] = rt ^ ~nl & wl, t[5] = ft ^ ~il & dl, t[14] = k ^ ~Gc & $t, t[15] = q ^ ~er & te, t[24] = el ^ ~pl & kt, t[25] = rl ^ ~hl & Qt, t[34] = Ke ^ ~Tt & sl, t[35] = Bs ^ ~Xt & _l, t[44] = fl ^ ~Z & Uc, t[45] = ll ^ ~ct & P, t[6] = nl ^ ~wl & tr, t[7] = il ^ ~dl & E, t[16] = Gc ^ ~$t & qt, t[17] = er ^ ~te & Zf, t[26] = pl ^ ~kt & Wt, t[27] = hl ^ ~Qt & Jt, t[36] = Tt ^ ~sl & ol, t[37] = Xt ^ ~_l & al, t[46] = Z ^ ~Uc & h, t[47] = ct ^ ~P & g, t[8] = wl ^ ~tr & Dt, t[9] = dl ^ ~E & Xi, t[18] = $t ^ ~qt & cl, t[19] = te ^ ~Zf & ul, t[28] = kt ^ ~Wt & T, t[29] = Qt ^ ~Jt & Q, t[38] = sl ^ ~ol & p, t[39] = _l ^ ~al & d, t[48] = Uc ^ ~h & Xf, t[49] = P ^ ~g & tl, t[0] ^= n[e * 2], t[1] ^= n[e * 2 + 1];
    }
  }, Wp;
}
var Jp, Xg;
function _v() {
  if (Xg) return Jp;
  Xg = 1;
  const n = sv();
  function t() {
    this.state = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ], this.blockSize = null, this.count = 0, this.squeezing = !1;
  }
  return t.prototype.initialize = function(e, r) {
    for (let s = 0; s < 50; ++s) this.state[s] = 0;
    this.blockSize = e / 8, this.count = 0, this.squeezing = !1;
  }, t.prototype.absorb = function(e) {
    for (let r = 0; r < e.length; ++r)
      this.state[~~(this.count / 4)] ^= e[r] << 8 * (this.count % 4), this.count += 1, this.count === this.blockSize && (n.p1600(this.state), this.count = 0);
  }, t.prototype.absorbLastFewBits = function(e) {
    this.state[~~(this.count / 4)] ^= e << 8 * (this.count % 4), (e & 128) !== 0 && this.count === this.blockSize - 1 && n.p1600(this.state), this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4), n.p1600(this.state), this.count = 0, this.squeezing = !0;
  }, t.prototype.squeeze = function(e) {
    this.squeezing || this.absorbLastFewBits(1);
    const r = Rr.alloc(e);
    for (let s = 0; s < e; ++s)
      r[s] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255, this.count += 1, this.count === this.blockSize && (n.p1600(this.state), this.count = 0);
    return r;
  }, t.prototype.copy = function(e) {
    for (let r = 0; r < 50; ++r) e.state[r] = this.state[r];
    e.blockSize = this.blockSize, e.count = this.count, e.squeezing = this.squeezing;
  }, Jp = t, Jp;
}
var $p, t0;
function ov() {
  return t0 || (t0 = 1, $p = iv()(_v())), $p;
}
var av = ov();
const e0 = /* @__PURE__ */ Y2(av);
var of = { exports: {} }, cv = of.exports, r0;
function uv() {
  return r0 || (r0 = 1, function(n, t) {
    (function(e, r) {
      n.exports = r();
    })(cv, function() {
      var e = function(_, a) {
        if (a = a || {}, typeof _ != "function")
          throw new s("fetch must be a function");
        if (typeof a != "object")
          throw new s("defaults must be an object");
        if (a.retries !== void 0 && !r(a.retries))
          throw new s("retries must be a positive integer");
        if (a.retryDelay !== void 0 && !r(a.retryDelay) && typeof a.retryDelay != "function")
          throw new s("retryDelay must be a positive integer or a function returning a positive integer");
        if (a.retryOn !== void 0 && !Array.isArray(a.retryOn) && typeof a.retryOn != "function")
          throw new s("retryOn property expects an array or function");
        var c = {
          retries: 3,
          retryDelay: 1e3,
          retryOn: []
        };
        return a = Object.assign(c, a), function(l, f) {
          var w = a.retries, y = a.retryDelay, v = a.retryOn;
          if (f && f.retries !== void 0)
            if (r(f.retries))
              w = f.retries;
            else
              throw new s("retries must be a positive integer");
          if (f && f.retryDelay !== void 0)
            if (r(f.retryDelay) || typeof f.retryDelay == "function")
              y = f.retryDelay;
            else
              throw new s("retryDelay must be a positive integer or a function returning a positive integer");
          if (f && f.retryOn)
            if (Array.isArray(f.retryOn) || typeof f.retryOn == "function")
              v = f.retryOn;
            else
              throw new s("retryOn property expects an array or function");
          return new Promise(function(x, C) {
            var U = function(M) {
              var N = typeof Request < "u" && l instanceof Request ? l.clone() : l;
              _(N, f).then(function(I) {
                if (Array.isArray(v) && v.indexOf(I.status) === -1)
                  x(I);
                else if (typeof v == "function")
                  try {
                    return Promise.resolve(v(M, null, I)).then(function(G) {
                      G ? z(M, null, I) : x(I);
                    }).catch(C);
                  } catch (G) {
                    C(G);
                  }
                else
                  M < w ? z(M, null, I) : x(I);
              }).catch(function(I) {
                if (typeof v == "function")
                  try {
                    Promise.resolve(v(M, I, null)).then(function(G) {
                      G ? z(M, I, null) : C(I);
                    }).catch(function(G) {
                      C(G);
                    });
                  } catch (G) {
                    C(G);
                  }
                else M < w ? z(M, I, null) : C(I);
              });
            };
            function z(M, N, I) {
              var G = typeof y == "function" ? y(M, N, I) : y;
              setTimeout(function() {
                U(++M);
              }, G);
            }
            U(0);
          });
        };
      };
      function r(_) {
        return Number.isInteger(_) && _ >= 0;
      }
      function s(_) {
        this.name = "ArgumentError", this.message = _;
      }
      return e;
    });
  }(of)), of.exports;
}
var fv = uv();
const lv = /* @__PURE__ */ Y2(fv), pv = () => (async (n) => {
  try {
    return typeof MessageChannel < "u" && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(n);
  } catch {
    return !1;
  }
})(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));
var mf = typeof Ac < "u" ? Ac : typeof self < "u" ? self : typeof window < "u" ? window : {};
function lm(n, t) {
  return new Promise((e) => {
    n.addEventListener("message", function r({ data: s }) {
      (s == null ? void 0 : s.type) === t && (n.removeEventListener("message", r), e(s));
    });
  });
}
lm(self, "wasm_bindgen_worker_init").then(async ({ init: n, receiver: t }) => {
  const e = await Promise.resolve().then(function() {
    return kv;
  });
  await e.default(n), postMessage({ type: "wasm_bindgen_worker_ready" }), e.wbg_rayon_start_worker(t);
});
async function hv(n, t, e) {
  if (e.numThreads() === 0)
    throw new Error("num_threads must be > 0.");
  const r = {
    type: "wasm_bindgen_worker_init",
    init: { module_or_path: n, memory: t },
    receiver: e.receiver()
  };
  await Promise.all(
    Array.from({ length: e.numThreads() }, async () => {
      let s;
      try {
        s = new Worker(
          new URL(
            /* @vite-ignore */
            "/workerHelpers.js",
            import.meta.url
          ),
          {
            type: "module"
          }
        );
      } catch {
        const c = await (await fetch("/workerHelpers.js")).blob(), u = URL.createObjectURL(c);
        s = new Worker(u);
      }
      return s.postMessage(r), await lm(s, "wasm_bindgen_worker_ready"), s;
    })
  ), e.build();
}
let i;
function Wc(n) {
  const t = i.__externref_table_alloc();
  return i.__wbindgen_export_2.set(t, n), t;
}
function G_(n, t) {
  try {
    return n.apply(this, t);
  } catch (e) {
    const r = Wc(e);
    i.__wbindgen_exn_store(r);
  }
}
const pm = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && pm.decode();
let Jc = null;
function xa() {
  return (Jc === null || Jc.buffer !== i.memory.buffer) && (Jc = new Uint8Array(i.memory.buffer)), Jc;
}
function Gs(n, t) {
  return n = n >>> 0, pm.decode(xa().slice(n, n + t));
}
let m = 0;
const hm = typeof TextEncoder < "u" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} }, wv = function(n, t) {
  const e = hm.encode(n);
  return t.set(e), {
    read: n.length,
    written: e.length
  };
};
function Qu(n, t, e) {
  if (e === void 0) {
    const c = hm.encode(n), u = t(c.length, 1) >>> 0;
    return xa().subarray(u, u + c.length).set(c), m = c.length, u;
  }
  let r = n.length, s = t(r, 1) >>> 0;
  const _ = xa();
  let a = 0;
  for (; a < r; a++) {
    const c = n.charCodeAt(a);
    if (c > 127) break;
    _[s + a] = c;
  }
  if (a !== r) {
    a !== 0 && (n = n.slice(a)), s = e(s, r, r = a + n.length * 3, 1) >>> 0;
    const c = xa().subarray(s + a, s + r), u = wv(n, c);
    a += u.written, s = e(s, r, a, 1) >>> 0;
  }
  return m = a, s;
}
let $c = null;
function Ir() {
  return ($c === null || $c.buffer !== i.memory.buffer) && ($c = new DataView(i.memory.buffer)), $c;
}
function Cs(n) {
  return n == null;
}
function Th(n) {
  const t = typeof n;
  if (t == "number" || t == "boolean" || n == null)
    return `${n}`;
  if (t == "string")
    return `"${n}"`;
  if (t == "symbol") {
    const s = n.description;
    return s == null ? "Symbol" : `Symbol(${s})`;
  }
  if (t == "function") {
    const s = n.name;
    return typeof s == "string" && s.length > 0 ? `Function(${s})` : "Function";
  }
  if (Array.isArray(n)) {
    const s = n.length;
    let _ = "[";
    s > 0 && (_ += Th(n[0]));
    for (let a = 1; a < s; a++)
      _ += ", " + Th(n[a]);
    return _ += "]", _;
  }
  const e = /\[object ([^\]]+)\]/.exec(toString.call(n));
  let r;
  if (e && e.length > 1)
    r = e[1];
  else
    return toString.call(n);
  if (r == "Object")
    try {
      return "Object(" + JSON.stringify(n) + ")";
    } catch {
      return "Object";
    }
  return n instanceof Error ? `${n.name}: ${n.message}
${n.stack}` : r;
}
function o(n) {
  const t = i.__wbindgen_export_2.get(n);
  return i.__externref_table_dealloc(n), t;
}
function b(n, t) {
  if (!(n instanceof t))
    throw new Error(`expected instance of ${t.name}`);
}
function R(n, t) {
  return n = n >>> 0, xa().subarray(n / 1, n / 1 + t);
}
function S(n, t) {
  const e = t(n.length * 1, 1) >>> 0;
  return xa().set(n, e / 1), m = n.length, e;
}
function dv(n) {
  let t, e;
  try {
    const r = i.shortint_pke_params_name(n);
    return t = r[0], e = r[1], Gs(r[0], r[1]);
  } finally {
    i.__wbindgen_free(t, e, 1);
  }
}
function gv(n) {
  let t, e;
  try {
    const r = i.shortint_params_name(n);
    return t = r[0], e = r[1], Gs(r[0], r[1]);
  } finally {
    i.__wbindgen_free(t, e, 1);
  }
}
function wm() {
  i.init_panic_hook();
}
function bv(n) {
  b(n, lu);
  const t = i.set_server_key(n.__wbg_ptr);
  if (t[1])
    throw o(t[0]);
}
function dm(n) {
  return i.initThreadPool(n);
}
function yv(n) {
  i.wbg_rayon_start_worker(n);
}
const Av = Object.freeze({
  Big: 0,
  0: "Big",
  Small: 1,
  1: "Small"
}), mv = Object.freeze({
  Default: 0,
  0: "Default",
  TfheLib: 1,
  1: "TfheLib",
  DefaultKsPbs: 2,
  2: "DefaultKsPbs",
  TfheLibKsPbs: 3,
  3: "TfheLibKsPbs"
}), Sv = Object.freeze({
  Bool: 0,
  0: "Bool",
  Uint4: 1,
  1: "Uint4",
  Uint8: 2,
  2: "Uint8",
  Uint16: 3,
  3: "Uint16",
  Uint32: 4,
  4: "Uint32",
  Uint64: 5,
  5: "Uint64",
  Uint128: 6,
  6: "Uint128",
  Uint160: 7,
  7: "Uint160",
  Uint256: 8,
  8: "Uint256",
  Uint512: 9,
  9: "Uint512",
  Uint1024: 10,
  10: "Uint1024",
  Uint2048: 11,
  11: "Uint2048",
  Uint2: 12,
  12: "Uint2",
  Uint6: 13,
  13: "Uint6",
  Uint10: 14,
  14: "Uint10",
  Uint12: 15,
  15: "Uint12",
  Uint14: 16,
  16: "Uint14",
  Int2: 17,
  17: "Int2",
  Int4: 18,
  18: "Int4",
  Int6: 19,
  19: "Int6",
  Int8: 20,
  20: "Int8",
  Int10: 21,
  21: "Int10",
  Int12: 22,
  22: "Int12",
  Int14: 23,
  23: "Int14",
  Int16: 24,
  24: "Int16",
  Int32: 25,
  25: "Int32",
  Int64: 26,
  26: "Int64",
  Int128: 27,
  27: "Int128",
  Int160: 28,
  28: "Int160",
  Int256: 29,
  29: "Int256",
  AsciiString: 30,
  30: "AsciiString",
  Int512: 31,
  31: "Int512",
  Int1024: 32,
  32: "Int1024",
  Int2048: 33,
  33: "Int2048",
  Uint24: 34,
  34: "Uint24",
  Uint40: 35,
  35: "Uint40",
  Uint48: 36,
  36: "Uint48",
  Uint56: 37,
  37: "Uint56",
  Uint72: 38,
  38: "Uint72",
  Uint80: 39,
  39: "Uint80",
  Uint88: 40,
  40: "Uint88",
  Uint96: 41,
  41: "Uint96",
  Uint104: 42,
  42: "Uint104",
  Uint112: 43,
  43: "Uint112",
  Uint120: 44,
  44: "Uint120",
  Uint136: 45,
  45: "Uint136",
  Uint144: 46,
  46: "Uint144",
  Uint152: 47,
  47: "Uint152",
  Uint168: 48,
  48: "Uint168",
  Uint176: 49,
  49: "Uint176",
  Uint184: 50,
  50: "Uint184",
  Uint192: 51,
  51: "Uint192",
  Uint200: 52,
  52: "Uint200",
  Uint208: 53,
  53: "Uint208",
  Uint216: 54,
  54: "Uint216",
  Uint224: 55,
  55: "Uint224",
  Uint232: 56,
  56: "Uint232",
  Uint240: 57,
  57: "Uint240",
  Uint248: 58,
  58: "Uint248",
  Int24: 59,
  59: "Int24",
  Int40: 60,
  60: "Int40",
  Int48: 61,
  61: "Int48",
  Int56: 62,
  62: "Int56",
  Int72: 63,
  63: "Int72",
  Int80: 64,
  64: "Int80",
  Int88: 65,
  65: "Int88",
  Int96: 66,
  66: "Int96",
  Int104: 67,
  67: "Int104",
  Int112: 68,
  68: "Int112",
  Int120: 69,
  69: "Int120",
  Int136: 70,
  70: "Int136",
  Int144: 71,
  71: "Int144",
  Int152: 72,
  72: "Int152",
  Int168: 73,
  73: "Int168",
  Int176: 74,
  74: "Int176",
  Int184: 75,
  75: "Int184",
  Int192: 76,
  76: "Int192",
  Int200: 77,
  77: "Int200",
  Int208: 78,
  78: "Int208",
  Int216: 79,
  79: "Int216",
  Int224: 80,
  80: "Int224",
  Int232: 81,
  81: "Int232",
  Int240: 82,
  82: "Int240",
  Int248: 83,
  83: "Int248"
}), Rv = Object.freeze({
  PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128: 0,
  0: "PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128",
  V1_1_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128: 1,
  1: "V1_1_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128",
  V1_1_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128_ZKV1: 2,
  2: "V1_1_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128_ZKV1",
  V1_0_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128: 3,
  3: "V1_0_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128",
  V1_0_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128_ZKV1: 4,
  4: "V1_0_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128_ZKV1",
  V0_11_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M64: 5,
  5: "V0_11_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M64",
  V0_11_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M64_ZKV1: 6,
  6: "V0_11_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M64_ZKV1"
}), Ev = Object.freeze({
  Big: 0,
  0: "Big",
  Small: 1,
  1: "Small"
}), Pv = Object.freeze({
  KeyswitchBootstrap: 0,
  0: "KeyswitchBootstrap",
  BootstrapKeyswitch: 1,
  1: "BootstrapKeyswitch"
}), zv = Object.freeze({
  PARAM_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128: 0,
  0: "PARAM_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_0_KS_PBS_GAUSSIAN_2M128: 1,
  1: "V1_1_PARAM_MESSAGE_1_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M128: 2,
  2: "V1_1_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_2_CARRY_0_KS_PBS_GAUSSIAN_2M128: 3,
  3: "V1_1_PARAM_MESSAGE_2_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_2_KS_PBS_GAUSSIAN_2M128: 4,
  4: "V1_1_PARAM_MESSAGE_1_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_2_CARRY_1_KS_PBS_GAUSSIAN_2M128: 5,
  5: "V1_1_PARAM_MESSAGE_2_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_3_CARRY_0_KS_PBS_GAUSSIAN_2M128: 6,
  6: "V1_1_PARAM_MESSAGE_3_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_3_KS_PBS_GAUSSIAN_2M128: 7,
  7: "V1_1_PARAM_MESSAGE_1_CARRY_3_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M128: 8,
  8: "V1_1_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_3_CARRY_1_KS_PBS_GAUSSIAN_2M128: 9,
  9: "V1_1_PARAM_MESSAGE_3_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_4_CARRY_0_KS_PBS_GAUSSIAN_2M128: 10,
  10: "V1_1_PARAM_MESSAGE_4_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_4_KS_PBS_GAUSSIAN_2M128: 11,
  11: "V1_1_PARAM_MESSAGE_1_CARRY_4_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_2_CARRY_3_KS_PBS_GAUSSIAN_2M128: 12,
  12: "V1_1_PARAM_MESSAGE_2_CARRY_3_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_3_CARRY_2_KS_PBS_GAUSSIAN_2M128: 13,
  13: "V1_1_PARAM_MESSAGE_3_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_4_CARRY_1_KS_PBS_GAUSSIAN_2M128: 14,
  14: "V1_1_PARAM_MESSAGE_4_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_5_CARRY_0_KS_PBS_GAUSSIAN_2M128: 15,
  15: "V1_1_PARAM_MESSAGE_5_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_5_KS_PBS_GAUSSIAN_2M128: 16,
  16: "V1_1_PARAM_MESSAGE_1_CARRY_5_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_2_CARRY_4_KS_PBS_GAUSSIAN_2M128: 17,
  17: "V1_1_PARAM_MESSAGE_2_CARRY_4_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_3_CARRY_3_KS_PBS_GAUSSIAN_2M128: 18,
  18: "V1_1_PARAM_MESSAGE_3_CARRY_3_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_4_CARRY_2_KS_PBS_GAUSSIAN_2M128: 19,
  19: "V1_1_PARAM_MESSAGE_4_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_5_CARRY_1_KS_PBS_GAUSSIAN_2M128: 20,
  20: "V1_1_PARAM_MESSAGE_5_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_6_CARRY_0_KS_PBS_GAUSSIAN_2M128: 21,
  21: "V1_1_PARAM_MESSAGE_6_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_6_KS_PBS_GAUSSIAN_2M128: 22,
  22: "V1_1_PARAM_MESSAGE_1_CARRY_6_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_2_CARRY_5_KS_PBS_GAUSSIAN_2M128: 23,
  23: "V1_1_PARAM_MESSAGE_2_CARRY_5_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_3_CARRY_4_KS_PBS_GAUSSIAN_2M128: 24,
  24: "V1_1_PARAM_MESSAGE_3_CARRY_4_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_4_CARRY_3_KS_PBS_GAUSSIAN_2M128: 25,
  25: "V1_1_PARAM_MESSAGE_4_CARRY_3_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_5_CARRY_2_KS_PBS_GAUSSIAN_2M128: 26,
  26: "V1_1_PARAM_MESSAGE_5_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_6_CARRY_1_KS_PBS_GAUSSIAN_2M128: 27,
  27: "V1_1_PARAM_MESSAGE_6_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_7_CARRY_0_KS_PBS_GAUSSIAN_2M128: 28,
  28: "V1_1_PARAM_MESSAGE_7_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_7_KS_PBS_GAUSSIAN_2M128: 29,
  29: "V1_1_PARAM_MESSAGE_1_CARRY_7_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_2_CARRY_6_KS_PBS_GAUSSIAN_2M128: 30,
  30: "V1_1_PARAM_MESSAGE_2_CARRY_6_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_3_CARRY_5_KS_PBS_GAUSSIAN_2M128: 31,
  31: "V1_1_PARAM_MESSAGE_3_CARRY_5_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_4_CARRY_4_KS_PBS_GAUSSIAN_2M128: 32,
  32: "V1_1_PARAM_MESSAGE_4_CARRY_4_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_5_CARRY_3_KS_PBS_GAUSSIAN_2M128: 33,
  33: "V1_1_PARAM_MESSAGE_5_CARRY_3_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_6_CARRY_2_KS_PBS_GAUSSIAN_2M128: 34,
  34: "V1_1_PARAM_MESSAGE_6_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_7_CARRY_1_KS_PBS_GAUSSIAN_2M128: 35,
  35: "V1_1_PARAM_MESSAGE_7_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_8_CARRY_0_KS_PBS_GAUSSIAN_2M128: 36,
  36: "V1_1_PARAM_MESSAGE_8_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_1_PBS_KS_GAUSSIAN_2M128: 37,
  37: "V1_1_PARAM_MESSAGE_1_CARRY_1_PBS_KS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_2_CARRY_2_PBS_KS_GAUSSIAN_2M128: 38,
  38: "V1_1_PARAM_MESSAGE_2_CARRY_2_PBS_KS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_3_CARRY_3_PBS_KS_GAUSSIAN_2M128: 39,
  39: "V1_1_PARAM_MESSAGE_3_CARRY_3_PBS_KS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_4_CARRY_4_PBS_KS_GAUSSIAN_2M128: 40,
  40: "V1_1_PARAM_MESSAGE_4_CARRY_4_PBS_KS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 41,
  41: "V1_1_PARAM_MESSAGE_1_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 42,
  42: "V1_1_PARAM_MESSAGE_1_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 43,
  43: "V1_1_PARAM_MESSAGE_1_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 44,
  44: "V1_1_PARAM_MESSAGE_1_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 45,
  45: "V1_1_PARAM_MESSAGE_1_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_7_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 46,
  46: "V1_1_PARAM_MESSAGE_1_CARRY_7_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_2_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 47,
  47: "V1_1_PARAM_MESSAGE_2_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 48,
  48: "V1_1_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_2_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 49,
  49: "V1_1_PARAM_MESSAGE_2_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_2_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 50,
  50: "V1_1_PARAM_MESSAGE_2_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_2_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 51,
  51: "V1_1_PARAM_MESSAGE_2_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_2_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 52,
  52: "V1_1_PARAM_MESSAGE_2_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_3_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 53,
  53: "V1_1_PARAM_MESSAGE_3_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_3_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 54,
  54: "V1_1_PARAM_MESSAGE_3_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 55,
  55: "V1_1_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_3_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 56,
  56: "V1_1_PARAM_MESSAGE_3_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_3_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 57,
  57: "V1_1_PARAM_MESSAGE_3_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_4_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 58,
  58: "V1_1_PARAM_MESSAGE_4_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_4_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 59,
  59: "V1_1_PARAM_MESSAGE_4_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_4_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 60,
  60: "V1_1_PARAM_MESSAGE_4_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 61,
  61: "V1_1_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_5_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 62,
  62: "V1_1_PARAM_MESSAGE_5_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_5_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 63,
  63: "V1_1_PARAM_MESSAGE_5_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_5_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 64,
  64: "V1_1_PARAM_MESSAGE_5_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_6_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 65,
  65: "V1_1_PARAM_MESSAGE_6_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_6_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 66,
  66: "V1_1_PARAM_MESSAGE_6_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_7_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 67,
  67: "V1_1_PARAM_MESSAGE_7_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 68,
  68: "V1_1_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 69,
  69: "V1_1_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 70,
  70: "V1_1_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
  V1_1_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 71,
  71: "V1_1_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_0_KS_PBS_GAUSSIAN_2M128: 72,
  72: "V1_0_PARAM_MESSAGE_1_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M128: 73,
  73: "V1_0_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_0_KS_PBS_GAUSSIAN_2M128: 74,
  74: "V1_0_PARAM_MESSAGE_2_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_2_KS_PBS_GAUSSIAN_2M128: 75,
  75: "V1_0_PARAM_MESSAGE_1_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_1_KS_PBS_GAUSSIAN_2M128: 76,
  76: "V1_0_PARAM_MESSAGE_2_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_0_KS_PBS_GAUSSIAN_2M128: 77,
  77: "V1_0_PARAM_MESSAGE_3_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_3_KS_PBS_GAUSSIAN_2M128: 78,
  78: "V1_0_PARAM_MESSAGE_1_CARRY_3_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M128: 79,
  79: "V1_0_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_1_KS_PBS_GAUSSIAN_2M128: 80,
  80: "V1_0_PARAM_MESSAGE_3_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_0_KS_PBS_GAUSSIAN_2M128: 81,
  81: "V1_0_PARAM_MESSAGE_4_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_4_KS_PBS_GAUSSIAN_2M128: 82,
  82: "V1_0_PARAM_MESSAGE_1_CARRY_4_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_3_KS_PBS_GAUSSIAN_2M128: 83,
  83: "V1_0_PARAM_MESSAGE_2_CARRY_3_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_2_KS_PBS_GAUSSIAN_2M128: 84,
  84: "V1_0_PARAM_MESSAGE_3_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_1_KS_PBS_GAUSSIAN_2M128: 85,
  85: "V1_0_PARAM_MESSAGE_4_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_5_CARRY_0_KS_PBS_GAUSSIAN_2M128: 86,
  86: "V1_0_PARAM_MESSAGE_5_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_5_KS_PBS_GAUSSIAN_2M128: 87,
  87: "V1_0_PARAM_MESSAGE_1_CARRY_5_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_4_KS_PBS_GAUSSIAN_2M128: 88,
  88: "V1_0_PARAM_MESSAGE_2_CARRY_4_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_3_KS_PBS_GAUSSIAN_2M128: 89,
  89: "V1_0_PARAM_MESSAGE_3_CARRY_3_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_2_KS_PBS_GAUSSIAN_2M128: 90,
  90: "V1_0_PARAM_MESSAGE_4_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_5_CARRY_1_KS_PBS_GAUSSIAN_2M128: 91,
  91: "V1_0_PARAM_MESSAGE_5_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_6_CARRY_0_KS_PBS_GAUSSIAN_2M128: 92,
  92: "V1_0_PARAM_MESSAGE_6_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_6_KS_PBS_GAUSSIAN_2M128: 93,
  93: "V1_0_PARAM_MESSAGE_1_CARRY_6_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_5_KS_PBS_GAUSSIAN_2M128: 94,
  94: "V1_0_PARAM_MESSAGE_2_CARRY_5_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_4_KS_PBS_GAUSSIAN_2M128: 95,
  95: "V1_0_PARAM_MESSAGE_3_CARRY_4_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_3_KS_PBS_GAUSSIAN_2M128: 96,
  96: "V1_0_PARAM_MESSAGE_4_CARRY_3_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_5_CARRY_2_KS_PBS_GAUSSIAN_2M128: 97,
  97: "V1_0_PARAM_MESSAGE_5_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_6_CARRY_1_KS_PBS_GAUSSIAN_2M128: 98,
  98: "V1_0_PARAM_MESSAGE_6_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_7_CARRY_0_KS_PBS_GAUSSIAN_2M128: 99,
  99: "V1_0_PARAM_MESSAGE_7_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_7_KS_PBS_GAUSSIAN_2M128: 100,
  100: "V1_0_PARAM_MESSAGE_1_CARRY_7_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_6_KS_PBS_GAUSSIAN_2M128: 101,
  101: "V1_0_PARAM_MESSAGE_2_CARRY_6_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_5_KS_PBS_GAUSSIAN_2M128: 102,
  102: "V1_0_PARAM_MESSAGE_3_CARRY_5_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_4_KS_PBS_GAUSSIAN_2M128: 103,
  103: "V1_0_PARAM_MESSAGE_4_CARRY_4_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_5_CARRY_3_KS_PBS_GAUSSIAN_2M128: 104,
  104: "V1_0_PARAM_MESSAGE_5_CARRY_3_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_6_CARRY_2_KS_PBS_GAUSSIAN_2M128: 105,
  105: "V1_0_PARAM_MESSAGE_6_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_7_CARRY_1_KS_PBS_GAUSSIAN_2M128: 106,
  106: "V1_0_PARAM_MESSAGE_7_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_8_CARRY_0_KS_PBS_GAUSSIAN_2M128: 107,
  107: "V1_0_PARAM_MESSAGE_8_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_1_PBS_KS_GAUSSIAN_2M128: 108,
  108: "V1_0_PARAM_MESSAGE_1_CARRY_1_PBS_KS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_2_PBS_KS_GAUSSIAN_2M128: 109,
  109: "V1_0_PARAM_MESSAGE_2_CARRY_2_PBS_KS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_3_PBS_KS_GAUSSIAN_2M128: 110,
  110: "V1_0_PARAM_MESSAGE_3_CARRY_3_PBS_KS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_4_PBS_KS_GAUSSIAN_2M128: 111,
  111: "V1_0_PARAM_MESSAGE_4_CARRY_4_PBS_KS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 112,
  112: "V1_0_PARAM_MESSAGE_1_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 113,
  113: "V1_0_PARAM_MESSAGE_1_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 114,
  114: "V1_0_PARAM_MESSAGE_1_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 115,
  115: "V1_0_PARAM_MESSAGE_1_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 116,
  116: "V1_0_PARAM_MESSAGE_1_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_7_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 117,
  117: "V1_0_PARAM_MESSAGE_1_CARRY_7_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 118,
  118: "V1_0_PARAM_MESSAGE_2_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 119,
  119: "V1_0_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 120,
  120: "V1_0_PARAM_MESSAGE_2_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 121,
  121: "V1_0_PARAM_MESSAGE_2_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 122,
  122: "V1_0_PARAM_MESSAGE_2_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 123,
  123: "V1_0_PARAM_MESSAGE_2_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 124,
  124: "V1_0_PARAM_MESSAGE_3_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 125,
  125: "V1_0_PARAM_MESSAGE_3_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 126,
  126: "V1_0_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 127,
  127: "V1_0_PARAM_MESSAGE_3_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 128,
  128: "V1_0_PARAM_MESSAGE_3_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 129,
  129: "V1_0_PARAM_MESSAGE_4_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 130,
  130: "V1_0_PARAM_MESSAGE_4_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 131,
  131: "V1_0_PARAM_MESSAGE_4_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 132,
  132: "V1_0_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_5_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 133,
  133: "V1_0_PARAM_MESSAGE_5_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_5_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 134,
  134: "V1_0_PARAM_MESSAGE_5_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_5_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 135,
  135: "V1_0_PARAM_MESSAGE_5_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_6_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 136,
  136: "V1_0_PARAM_MESSAGE_6_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_6_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 137,
  137: "V1_0_PARAM_MESSAGE_6_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_7_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 138,
  138: "V1_0_PARAM_MESSAGE_7_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 139,
  139: "V1_0_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 140,
  140: "V1_0_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 141,
  141: "V1_0_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 142,
  142: "V1_0_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
  V0_11_PARAM_MESSAGE_1_CARRY_0_KS_PBS_GAUSSIAN_2M64: 143,
  143: "V0_11_PARAM_MESSAGE_1_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M64: 144,
  144: "V0_11_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_0_KS_PBS_GAUSSIAN_2M64: 145,
  145: "V0_11_PARAM_MESSAGE_2_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_2_KS_PBS_GAUSSIAN_2M64: 146,
  146: "V0_11_PARAM_MESSAGE_1_CARRY_2_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_1_KS_PBS_GAUSSIAN_2M64: 147,
  147: "V0_11_PARAM_MESSAGE_2_CARRY_1_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_0_KS_PBS_GAUSSIAN_2M64: 148,
  148: "V0_11_PARAM_MESSAGE_3_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_3_KS_PBS_GAUSSIAN_2M64: 149,
  149: "V0_11_PARAM_MESSAGE_1_CARRY_3_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M64: 150,
  150: "V0_11_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_1_KS_PBS_GAUSSIAN_2M64: 151,
  151: "V0_11_PARAM_MESSAGE_3_CARRY_1_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_0_KS_PBS_GAUSSIAN_2M64: 152,
  152: "V0_11_PARAM_MESSAGE_4_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_4_KS_PBS_GAUSSIAN_2M64: 153,
  153: "V0_11_PARAM_MESSAGE_1_CARRY_4_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_3_KS_PBS_GAUSSIAN_2M64: 154,
  154: "V0_11_PARAM_MESSAGE_2_CARRY_3_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_2_KS_PBS_GAUSSIAN_2M64: 155,
  155: "V0_11_PARAM_MESSAGE_3_CARRY_2_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_1_KS_PBS_GAUSSIAN_2M64: 156,
  156: "V0_11_PARAM_MESSAGE_4_CARRY_1_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_5_CARRY_0_KS_PBS_GAUSSIAN_2M64: 157,
  157: "V0_11_PARAM_MESSAGE_5_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_5_KS_PBS_GAUSSIAN_2M64: 158,
  158: "V0_11_PARAM_MESSAGE_1_CARRY_5_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_4_KS_PBS_GAUSSIAN_2M64: 159,
  159: "V0_11_PARAM_MESSAGE_2_CARRY_4_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_3_KS_PBS_GAUSSIAN_2M64: 160,
  160: "V0_11_PARAM_MESSAGE_3_CARRY_3_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_2_KS_PBS_GAUSSIAN_2M64: 161,
  161: "V0_11_PARAM_MESSAGE_4_CARRY_2_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_5_CARRY_1_KS_PBS_GAUSSIAN_2M64: 162,
  162: "V0_11_PARAM_MESSAGE_5_CARRY_1_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_6_CARRY_0_KS_PBS_GAUSSIAN_2M64: 163,
  163: "V0_11_PARAM_MESSAGE_6_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_6_KS_PBS_GAUSSIAN_2M64: 164,
  164: "V0_11_PARAM_MESSAGE_1_CARRY_6_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_5_KS_PBS_GAUSSIAN_2M64: 165,
  165: "V0_11_PARAM_MESSAGE_2_CARRY_5_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_4_KS_PBS_GAUSSIAN_2M64: 166,
  166: "V0_11_PARAM_MESSAGE_3_CARRY_4_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_3_KS_PBS_GAUSSIAN_2M64: 167,
  167: "V0_11_PARAM_MESSAGE_4_CARRY_3_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_5_CARRY_2_KS_PBS_GAUSSIAN_2M64: 168,
  168: "V0_11_PARAM_MESSAGE_5_CARRY_2_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_6_CARRY_1_KS_PBS_GAUSSIAN_2M64: 169,
  169: "V0_11_PARAM_MESSAGE_6_CARRY_1_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_7_CARRY_0_KS_PBS_GAUSSIAN_2M64: 170,
  170: "V0_11_PARAM_MESSAGE_7_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_7_KS_PBS_GAUSSIAN_2M64: 171,
  171: "V0_11_PARAM_MESSAGE_1_CARRY_7_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_6_KS_PBS_GAUSSIAN_2M64: 172,
  172: "V0_11_PARAM_MESSAGE_2_CARRY_6_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_5_KS_PBS_GAUSSIAN_2M64: 173,
  173: "V0_11_PARAM_MESSAGE_3_CARRY_5_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_4_KS_PBS_GAUSSIAN_2M64: 174,
  174: "V0_11_PARAM_MESSAGE_4_CARRY_4_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_5_CARRY_3_KS_PBS_GAUSSIAN_2M64: 175,
  175: "V0_11_PARAM_MESSAGE_5_CARRY_3_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_6_CARRY_2_KS_PBS_GAUSSIAN_2M64: 176,
  176: "V0_11_PARAM_MESSAGE_6_CARRY_2_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_7_CARRY_1_KS_PBS_GAUSSIAN_2M64: 177,
  177: "V0_11_PARAM_MESSAGE_7_CARRY_1_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_8_CARRY_0_KS_PBS_GAUSSIAN_2M64: 178,
  178: "V0_11_PARAM_MESSAGE_8_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_1_PBS_KS_GAUSSIAN_2M64: 179,
  179: "V0_11_PARAM_MESSAGE_1_CARRY_1_PBS_KS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_2_PBS_KS_GAUSSIAN_2M64: 180,
  180: "V0_11_PARAM_MESSAGE_2_CARRY_2_PBS_KS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_3_PBS_KS_GAUSSIAN_2M64: 181,
  181: "V0_11_PARAM_MESSAGE_3_CARRY_3_PBS_KS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_4_PBS_KS_GAUSSIAN_2M64: 182,
  182: "V0_11_PARAM_MESSAGE_4_CARRY_4_PBS_KS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 183,
  183: "V0_11_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 184,
  184: "V0_11_PARAM_MESSAGE_1_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 185,
  185: "V0_11_PARAM_MESSAGE_1_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 186,
  186: "V0_11_PARAM_MESSAGE_1_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 187,
  187: "V0_11_PARAM_MESSAGE_1_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 188,
  188: "V0_11_PARAM_MESSAGE_1_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_7_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 189,
  189: "V0_11_PARAM_MESSAGE_1_CARRY_7_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 190,
  190: "V0_11_PARAM_MESSAGE_2_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 191,
  191: "V0_11_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 192,
  192: "V0_11_PARAM_MESSAGE_2_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 193,
  193: "V0_11_PARAM_MESSAGE_2_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 194,
  194: "V0_11_PARAM_MESSAGE_2_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 195,
  195: "V0_11_PARAM_MESSAGE_2_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 196,
  196: "V0_11_PARAM_MESSAGE_3_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 197,
  197: "V0_11_PARAM_MESSAGE_3_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 198,
  198: "V0_11_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 199,
  199: "V0_11_PARAM_MESSAGE_3_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 200,
  200: "V0_11_PARAM_MESSAGE_3_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 201,
  201: "V0_11_PARAM_MESSAGE_4_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 202,
  202: "V0_11_PARAM_MESSAGE_4_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 203,
  203: "V0_11_PARAM_MESSAGE_4_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 204,
  204: "V0_11_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_5_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 205,
  205: "V0_11_PARAM_MESSAGE_5_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_5_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 206,
  206: "V0_11_PARAM_MESSAGE_5_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_5_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 207,
  207: "V0_11_PARAM_MESSAGE_5_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_6_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 208,
  208: "V0_11_PARAM_MESSAGE_6_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_6_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 209,
  209: "V0_11_PARAM_MESSAGE_6_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_7_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 210,
  210: "V0_11_PARAM_MESSAGE_7_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_PBS_KS_GAUSSIAN_2M64: 211,
  211: "V0_11_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_PBS_KS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_PBS_KS_GAUSSIAN_2M64: 212,
  212: "V0_11_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_PBS_KS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_PBS_KS_GAUSSIAN_2M64: 213,
  213: "V0_11_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_PBS_KS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_PBS_KS_GAUSSIAN_2M64: 214,
  214: "V0_11_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_PBS_KS_GAUSSIAN_2M64"
}), gm = Object.freeze({
  Proof: 0,
  0: "Proof",
  Verify: 1,
  1: "Verify"
}), vv = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_boolean_free(n >>> 0, 1));
let Mv = class {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, vv.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_boolean_free(t, 0);
  }
  /**
   * @param {number} parameter_choice
   * @returns {BooleanParameters}
   */
  static get_parameters(t) {
    const e = i.boolean_get_parameters(t);
    if (e[2])
      throw o(e[1]);
    return Qs.__wrap(e[0]);
  }
  /**
   * @param {number} std_dev
   * @returns {BooleanNoiseDistribution}
   */
  static new_gaussian_from_std_dev(t) {
    const e = i.boolean_new_gaussian_from_std_dev(t);
    return qs.__wrap(e);
  }
  /**
   * @param {number} bound_log2
   * @returns {BooleanNoiseDistribution}
   */
  static try_new_t_uniform(t) {
    const e = i.boolean_try_new_t_uniform(t);
    if (e[2])
      throw o(e[1]);
    return qs.__wrap(e[0]);
  }
  /**
   * @param {number} lwe_dimension
   * @param {number} glwe_dimension
   * @param {number} polynomial_size
   * @param {BooleanNoiseDistribution} lwe_noise_distribution
   * @param {BooleanNoiseDistribution} glwe_noise_distribution
   * @param {number} pbs_base_log
   * @param {number} pbs_level
   * @param {number} ks_base_log
   * @param {number} ks_level
   * @param {BooleanEncryptionKeyChoice} encryption_key_choice
   * @returns {BooleanParameters}
   */
  static new_parameters(t, e, r, s, _, a, c, u, l, f) {
    b(s, qs), b(_, qs);
    const w = i.boolean_new_parameters(t, e, r, s.__wbg_ptr, _.__wbg_ptr, a, c, u, l, f);
    return Qs.__wrap(w);
  }
  /**
   * @param {bigint} seed_high_bytes
   * @param {bigint} seed_low_bytes
   * @param {BooleanParameters} parameters
   * @returns {BooleanClientKey}
   */
  static new_client_key_from_seed_and_parameters(t, e, r) {
    b(r, Qs);
    const s = i.boolean_new_client_key_from_seed_and_parameters(t, e, r.__wbg_ptr);
    return or.__wrap(s);
  }
  /**
   * @param {BooleanParameters} parameters
   * @returns {BooleanClientKey}
   */
  static new_client_key(t) {
    b(t, Qs);
    const e = i.boolean_new_client_key(t.__wbg_ptr);
    return or.__wrap(e);
  }
  /**
   * @param {BooleanClientKey} client_key
   * @returns {BooleanPublicKey}
   */
  static new_public_key(t) {
    b(t, or);
    const e = i.boolean_new_public_key(t.__wbg_ptr);
    return Ws.__wrap(e);
  }
  /**
   * @param {BooleanClientKey} client_key
   * @returns {BooleanCompressedServerKey}
   */
  static new_compressed_server_key(t) {
    b(t, or);
    const e = i.boolean_new_compressed_server_key(t.__wbg_ptr);
    return Ba.__wrap(e);
  }
  /**
   * @param {BooleanClientKey} client_key
   * @param {boolean} message
   * @returns {BooleanCiphertext}
   */
  static encrypt(t, e) {
    b(t, or);
    const r = i.boolean_encrypt(t.__wbg_ptr, e);
    return Tr.__wrap(r);
  }
  /**
   * @param {BooleanClientKey} client_key
   * @param {boolean} message
   * @returns {BooleanCompressedCiphertext}
   */
  static encrypt_compressed(t, e) {
    b(t, or);
    const r = i.boolean_encrypt_compressed(t.__wbg_ptr, e);
    return Hs.__wrap(r);
  }
  /**
   * @param {BooleanCompressedCiphertext} compressed_ciphertext
   * @returns {BooleanCiphertext}
   */
  static decompress_ciphertext(t) {
    b(t, Hs);
    const e = i.boolean_decompress_ciphertext(t.__wbg_ptr);
    return Tr.__wrap(e);
  }
  /**
   * @param {BooleanPublicKey} public_key
   * @param {boolean} message
   * @returns {BooleanCiphertext}
   */
  static encrypt_with_public_key(t, e) {
    b(t, Ws);
    const r = i.boolean_encrypt_with_public_key(t.__wbg_ptr, e);
    return Tr.__wrap(r);
  }
  /**
   * @param {boolean} message
   * @returns {BooleanCiphertext}
   */
  static trivial_encrypt(t) {
    const e = i.boolean_trivial_encrypt(t);
    return Tr.__wrap(e);
  }
  /**
   * @param {BooleanClientKey} client_key
   * @param {BooleanCiphertext} ct
   * @returns {boolean}
   */
  static decrypt(t, e) {
    return b(t, or), b(e, Tr), i.boolean_decrypt(t.__wbg_ptr, e.__wbg_ptr) !== 0;
  }
  /**
   * @param {BooleanCiphertext} ciphertext
   * @returns {Uint8Array}
   */
  static serialize_ciphertext(t) {
    b(t, Tr);
    const e = i.boolean_serialize_ciphertext(t.__wbg_ptr);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {BooleanCiphertext}
   */
  static deserialize_ciphertext(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.boolean_deserialize_ciphertext(e, r);
    if (s[2])
      throw o(s[1]);
    return Tr.__wrap(s[0]);
  }
  /**
   * @param {BooleanCompressedCiphertext} ciphertext
   * @returns {Uint8Array}
   */
  static serialize_compressed_ciphertext(t) {
    b(t, Hs);
    const e = i.boolean_serialize_compressed_ciphertext(t.__wbg_ptr);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {BooleanCompressedCiphertext}
   */
  static deserialize_compressed_ciphertext(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.boolean_deserialize_compressed_ciphertext(e, r);
    if (s[2])
      throw o(s[1]);
    return Hs.__wrap(s[0]);
  }
  /**
   * @param {BooleanClientKey} client_key
   * @returns {Uint8Array}
   */
  static serialize_client_key(t) {
    b(t, or);
    const e = i.boolean_serialize_client_key(t.__wbg_ptr);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {BooleanClientKey}
   */
  static deserialize_client_key(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.boolean_deserialize_client_key(e, r);
    if (s[2])
      throw o(s[1]);
    return or.__wrap(s[0]);
  }
  /**
   * @param {BooleanPublicKey} public_key
   * @returns {Uint8Array}
   */
  static serialize_public_key(t) {
    b(t, Ws);
    const e = i.boolean_serialize_public_key(t.__wbg_ptr);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {BooleanPublicKey}
   */
  static deserialize_public_key(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.boolean_deserialize_public_key(e, r);
    if (s[2])
      throw o(s[1]);
    return Ws.__wrap(s[0]);
  }
  /**
   * @param {BooleanCompressedServerKey} server_key
   * @returns {Uint8Array}
   */
  static serialize_compressed_server_key(t) {
    b(t, Ba);
    const e = i.boolean_serialize_compressed_server_key(t.__wbg_ptr);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {BooleanCompressedServerKey}
   */
  static deserialize_compressed_server_key(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.boolean_deserialize_compressed_server_key(e, r);
    if (s[2])
      throw o(s[1]);
    return Ba.__wrap(s[0]);
  }
};
const n0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_booleanciphertext_free(n >>> 0, 1));
class Tr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Tr.prototype);
    return e.__wbg_ptr = t, n0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, n0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_booleanciphertext_free(t, 0);
  }
}
const i0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_booleanclientkey_free(n >>> 0, 1));
class or {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(or.prototype);
    return e.__wbg_ptr = t, i0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, i0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_booleanclientkey_free(t, 0);
  }
}
const s0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_booleancompressedciphertext_free(n >>> 0, 1));
class Hs {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Hs.prototype);
    return e.__wbg_ptr = t, s0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, s0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_booleancompressedciphertext_free(t, 0);
  }
}
const _0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_booleancompressedserverkey_free(n >>> 0, 1));
class Ba {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ba.prototype);
    return e.__wbg_ptr = t, _0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, _0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_booleancompressedserverkey_free(t, 0);
  }
}
const o0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_booleannoisedistribution_free(n >>> 0, 1));
class qs {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(qs.prototype);
    return e.__wbg_ptr = t, o0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, o0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_booleannoisedistribution_free(t, 0);
  }
}
const a0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_booleanparameters_free(n >>> 0, 1));
class Qs {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Qs.prototype);
    return e.__wbg_ptr = t, a0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, a0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_booleanparameters_free(t, 0);
  }
}
const c0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_booleanpublickey_free(n >>> 0, 1));
class Ws {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ws.prototype);
    return e.__wbg_ptr = t, c0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, c0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_booleanpublickey_free(t, 0);
  }
}
const u0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compactciphertextlist_free(n >>> 0, 1));
class Es {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Es.prototype);
    return e.__wbg_ptr = t, u0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, u0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compactciphertextlist_free(t, 0);
  }
  /**
   * @param {TfheCompactPublicKey} public_key
   * @returns {CompactCiphertextListBuilder}
   */
  static builder(t) {
    b(t, Xe);
    const e = i.compactciphertextlist_builder(t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return Ou.__wrap(e[0]);
  }
  /**
   * @returns {number}
   */
  len() {
    return i.compactciphertextlist_len(this.__wbg_ptr) >>> 0;
  }
  /**
   * @returns {boolean}
   */
  is_empty() {
    return i.compactciphertextlist_is_empty(this.__wbg_ptr) !== 0;
  }
  /**
   * @param {number} index
   * @returns {FheTypes | undefined}
   */
  get_kind_of(t) {
    const e = i.compactciphertextlist_get_kind_of(this.__wbg_ptr, t);
    return e === 84 ? void 0 : e;
  }
  /**
   * @returns {CompactCiphertextListExpander}
   */
  expand() {
    const t = i.compactciphertextlist_expand(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Cc.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compactciphertextlist_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompactCiphertextList}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compactciphertextlist_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Es.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compactciphertextlist_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompactCiphertextList}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compactciphertextlist_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Es.__wrap(_[0]);
  }
}
const f0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compactciphertextlistbuilder_free(n >>> 0, 1));
class Ou {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ou.prototype);
    return e.__wbg_ptr = t, f0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, f0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compactciphertextlistbuilder_free(t, 0);
  }
  /**
   * @param {number} value
   */
  push_u24(t) {
    const e = i.compactciphertextlistbuilder_push_u24(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {bigint} value
   */
  push_u40(t) {
    const e = i.compactciphertextlistbuilder_push_u40(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {bigint} value
   */
  push_u48(t) {
    const e = i.compactciphertextlistbuilder_push_u48(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {bigint} value
   */
  push_u56(t) {
    const e = i.compactciphertextlistbuilder_push_u56(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u2(t) {
    const e = i.compactciphertextlistbuilder_push_u2(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u4(t) {
    const e = i.compactciphertextlistbuilder_push_u4(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u6(t) {
    const e = i.compactciphertextlistbuilder_push_u6(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u8(t) {
    const e = i.compactciphertextlistbuilder_push_u8(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u10(t) {
    const e = i.compactciphertextlistbuilder_push_u10(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u12(t) {
    const e = i.compactciphertextlistbuilder_push_u12(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u14(t) {
    const e = i.compactciphertextlistbuilder_push_u14(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u16(t) {
    const e = i.compactciphertextlistbuilder_push_u16(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u32(t) {
    const e = i.compactciphertextlistbuilder_push_u32(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {bigint} value
   */
  push_u64(t) {
    const e = i.compactciphertextlistbuilder_push_u64(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i24(t) {
    const e = i.compactciphertextlistbuilder_push_i24(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {bigint} value
   */
  push_i40(t) {
    const e = i.compactciphertextlistbuilder_push_i40(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {bigint} value
   */
  push_i48(t) {
    const e = i.compactciphertextlistbuilder_push_i48(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {bigint} value
   */
  push_i56(t) {
    const e = i.compactciphertextlistbuilder_push_i56(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i2(t) {
    const e = i.compactciphertextlistbuilder_push_i2(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i4(t) {
    const e = i.compactciphertextlistbuilder_push_i4(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i6(t) {
    const e = i.compactciphertextlistbuilder_push_i6(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i8(t) {
    const e = i.compactciphertextlistbuilder_push_i8(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i10(t) {
    const e = i.compactciphertextlistbuilder_push_i10(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i12(t) {
    const e = i.compactciphertextlistbuilder_push_i12(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i14(t) {
    const e = i.compactciphertextlistbuilder_push_i14(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i16(t) {
    const e = i.compactciphertextlistbuilder_push_i16(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i32(t) {
    const e = i.compactciphertextlistbuilder_push_i32(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {bigint} value
   */
  push_i64(t) {
    const e = i.compactciphertextlistbuilder_push_i64(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u128(t) {
    const e = i.compactciphertextlistbuilder_push_u128(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u160(t) {
    const e = i.compactciphertextlistbuilder_push_u160(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u256(t) {
    const e = i.compactciphertextlistbuilder_push_u256(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u512(t) {
    const e = i.compactciphertextlistbuilder_push_u512(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u1024(t) {
    const e = i.compactciphertextlistbuilder_push_u1024(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u2048(t) {
    const e = i.compactciphertextlistbuilder_push_u2048(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i128(t) {
    const e = i.compactciphertextlistbuilder_push_i128(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i160(t) {
    const e = i.compactciphertextlistbuilder_push_i160(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i256(t) {
    const e = i.compactciphertextlistbuilder_push_i256(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i512(t) {
    const e = i.compactciphertextlistbuilder_push_i512(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i1024(t) {
    const e = i.compactciphertextlistbuilder_push_i1024(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i2048(t) {
    const e = i.compactciphertextlistbuilder_push_i2048(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {boolean} value
   */
  push_boolean(t) {
    const e = i.compactciphertextlistbuilder_push_boolean(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @returns {CompactCiphertextList}
   */
  build() {
    const t = i.compactciphertextlistbuilder_build(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Es.__wrap(t[0]);
  }
  /**
   * @returns {CompactCiphertextList}
   */
  build_packed() {
    const t = i.compactciphertextlistbuilder_build_packed(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Es.__wrap(t[0]);
  }
  /**
   * @param {CompactPkeCrs} crs
   * @param {Uint8Array} metadata
   * @param {ZkComputeLoad} compute_load
   * @returns {ProvenCompactCiphertextList}
   */
  build_with_proof_packed(t, e, r) {
    b(t, pr);
    const s = S(e, i.__wbindgen_malloc), _ = m, a = i.compactciphertextlistbuilder_build_with_proof_packed(this.__wbg_ptr, t.__wbg_ptr, s, _, r);
    if (a[2])
      throw o(a[1]);
    return Ca.__wrap(a[0]);
  }
  /**
   * @param {any} value
   */
  push_u72(t) {
    const e = i.compactciphertextlistbuilder_push_u72(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u80(t) {
    const e = i.compactciphertextlistbuilder_push_u80(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u88(t) {
    const e = i.compactciphertextlistbuilder_push_u88(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u96(t) {
    const e = i.compactciphertextlistbuilder_push_u96(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u104(t) {
    const e = i.compactciphertextlistbuilder_push_u104(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u112(t) {
    const e = i.compactciphertextlistbuilder_push_u112(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u120(t) {
    const e = i.compactciphertextlistbuilder_push_u120(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u136(t) {
    const e = i.compactciphertextlistbuilder_push_u136(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u144(t) {
    const e = i.compactciphertextlistbuilder_push_u144(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u152(t) {
    const e = i.compactciphertextlistbuilder_push_u152(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u168(t) {
    const e = i.compactciphertextlistbuilder_push_u168(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u176(t) {
    const e = i.compactciphertextlistbuilder_push_u176(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u184(t) {
    const e = i.compactciphertextlistbuilder_push_u184(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u192(t) {
    const e = i.compactciphertextlistbuilder_push_u192(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u200(t) {
    const e = i.compactciphertextlistbuilder_push_u200(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u208(t) {
    const e = i.compactciphertextlistbuilder_push_u208(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u216(t) {
    const e = i.compactciphertextlistbuilder_push_u216(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u224(t) {
    const e = i.compactciphertextlistbuilder_push_u224(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u232(t) {
    const e = i.compactciphertextlistbuilder_push_u232(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u240(t) {
    const e = i.compactciphertextlistbuilder_push_u240(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u248(t) {
    const e = i.compactciphertextlistbuilder_push_u248(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i72(t) {
    const e = i.compactciphertextlistbuilder_push_i72(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i80(t) {
    const e = i.compactciphertextlistbuilder_push_i80(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i88(t) {
    const e = i.compactciphertextlistbuilder_push_i88(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i96(t) {
    const e = i.compactciphertextlistbuilder_push_i96(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i104(t) {
    const e = i.compactciphertextlistbuilder_push_i104(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i112(t) {
    const e = i.compactciphertextlistbuilder_push_i112(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i120(t) {
    const e = i.compactciphertextlistbuilder_push_i120(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i136(t) {
    const e = i.compactciphertextlistbuilder_push_i136(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i144(t) {
    const e = i.compactciphertextlistbuilder_push_i144(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i152(t) {
    const e = i.compactciphertextlistbuilder_push_i152(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i168(t) {
    const e = i.compactciphertextlistbuilder_push_i168(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i176(t) {
    const e = i.compactciphertextlistbuilder_push_i176(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i184(t) {
    const e = i.compactciphertextlistbuilder_push_i184(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i192(t) {
    const e = i.compactciphertextlistbuilder_push_i192(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i200(t) {
    const e = i.compactciphertextlistbuilder_push_i200(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i208(t) {
    const e = i.compactciphertextlistbuilder_push_i208(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i216(t) {
    const e = i.compactciphertextlistbuilder_push_i216(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i224(t) {
    const e = i.compactciphertextlistbuilder_push_i224(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i232(t) {
    const e = i.compactciphertextlistbuilder_push_i232(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i240(t) {
    const e = i.compactciphertextlistbuilder_push_i240(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i248(t) {
    const e = i.compactciphertextlistbuilder_push_i248(this.__wbg_ptr, t);
    if (e[1])
      throw o(e[0]);
  }
}
const l0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compactciphertextlistexpander_free(n >>> 0, 1));
class Cc {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Cc.prototype);
    return e.__wbg_ptr = t, l0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, l0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compactciphertextlistexpander_free(t, 0);
  }
  /**
   * @param {number} index
   * @returns {FheUint24}
   */
  get_uint24(t) {
    const e = i.compactciphertextlistexpander_get_uint24(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return si.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint40}
   */
  get_uint40(t) {
    const e = i.compactciphertextlistexpander_get_uint40(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return fi.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint48}
   */
  get_uint48(t) {
    const e = i.compactciphertextlistexpander_get_uint48(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return li.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint56}
   */
  get_uint56(t) {
    const e = i.compactciphertextlistexpander_get_uint56(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return hi.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint72}
   */
  get_uint72(t) {
    const e = i.compactciphertextlistexpander_get_uint72(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return gi.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint80}
   */
  get_uint80(t) {
    const e = i.compactciphertextlistexpander_get_uint80(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return yi.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint88}
   */
  get_uint88(t) {
    const e = i.compactciphertextlistexpander_get_uint88(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Ai.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint96}
   */
  get_uint96(t) {
    const e = i.compactciphertextlistexpander_get_uint96(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return mi.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint104}
   */
  get_uint104(t) {
    const e = i.compactciphertextlistexpander_get_uint104(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Gn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint112}
   */
  get_uint112(t) {
    const e = i.compactciphertextlistexpander_get_uint112(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Un.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint120}
   */
  get_uint120(t) {
    const e = i.compactciphertextlistexpander_get_uint120(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Kn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint136}
   */
  get_uint136(t) {
    const e = i.compactciphertextlistexpander_get_uint136(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Ln.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint144}
   */
  get_uint144(t) {
    const e = i.compactciphertextlistexpander_get_uint144(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Vn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint152}
   */
  get_uint152(t) {
    const e = i.compactciphertextlistexpander_get_uint152(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Yn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint168}
   */
  get_uint168(t) {
    const e = i.compactciphertextlistexpander_get_uint168(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Qn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint176}
   */
  get_uint176(t) {
    const e = i.compactciphertextlistexpander_get_uint176(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Wn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint184}
   */
  get_uint184(t) {
    const e = i.compactciphertextlistexpander_get_uint184(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Jn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint192}
   */
  get_uint192(t) {
    const e = i.compactciphertextlistexpander_get_uint192(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return $n.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint200}
   */
  get_uint200(t) {
    const e = i.compactciphertextlistexpander_get_uint200(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Xn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint208}
   */
  get_uint208(t) {
    const e = i.compactciphertextlistexpander_get_uint208(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return ei.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint216}
   */
  get_uint216(t) {
    const e = i.compactciphertextlistexpander_get_uint216(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return ri.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint224}
   */
  get_uint224(t) {
    const e = i.compactciphertextlistexpander_get_uint224(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return ni.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint232}
   */
  get_uint232(t) {
    const e = i.compactciphertextlistexpander_get_uint232(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return ii.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint240}
   */
  get_uint240(t) {
    const e = i.compactciphertextlistexpander_get_uint240(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return _i.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint248}
   */
  get_uint248(t) {
    const e = i.compactciphertextlistexpander_get_uint248(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return oi.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint256}
   */
  get_uint256(t) {
    const e = i.compactciphertextlistexpander_get_uint256(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return ai.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint2}
   */
  get_uint2(t) {
    const e = i.compactciphertextlistexpander_get_uint2(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Zn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint4}
   */
  get_uint4(t) {
    const e = i.compactciphertextlistexpander_get_uint4(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return ui.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint6}
   */
  get_uint6(t) {
    const e = i.compactciphertextlistexpander_get_uint6(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return wi.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint8}
   */
  get_uint8(t) {
    const e = i.compactciphertextlistexpander_get_uint8(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return bi.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint10}
   */
  get_uint10(t) {
    const e = i.compactciphertextlistexpander_get_uint10(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return kn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint12}
   */
  get_uint12(t) {
    const e = i.compactciphertextlistexpander_get_uint12(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Fn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint14}
   */
  get_uint14(t) {
    const e = i.compactciphertextlistexpander_get_uint14(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return jn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint16}
   */
  get_uint16(t) {
    const e = i.compactciphertextlistexpander_get_uint16(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Hn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint32}
   */
  get_uint32(t) {
    const e = i.compactciphertextlistexpander_get_uint32(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return ci.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint64}
   */
  get_uint64(t) {
    const e = i.compactciphertextlistexpander_get_uint64(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return di.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint128}
   */
  get_uint128(t) {
    const e = i.compactciphertextlistexpander_get_uint128(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Dn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint160}
   */
  get_uint160(t) {
    const e = i.compactciphertextlistexpander_get_uint160(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return qn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint512}
   */
  get_uint512(t) {
    const e = i.compactciphertextlistexpander_get_uint512(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return pi.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint1024}
   */
  get_uint1024(t) {
    const e = i.compactciphertextlistexpander_get_uint1024(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Tn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint2048}
   */
  get_uint2048(t) {
    const e = i.compactciphertextlistexpander_get_uint2048(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return ti.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt24}
   */
  get_int24(t) {
    const e = i.compactciphertextlistexpander_get_int24(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return bn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt40}
   */
  get_int40(t) {
    const e = i.compactciphertextlistexpander_get_int40(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return En.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt48}
   */
  get_int48(t) {
    const e = i.compactciphertextlistexpander_get_int48(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Pn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt56}
   */
  get_int56(t) {
    const e = i.compactciphertextlistexpander_get_int56(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return vn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt72}
   */
  get_int72(t) {
    const e = i.compactciphertextlistexpander_get_int72(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Bn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt80}
   */
  get_int80(t) {
    const e = i.compactciphertextlistexpander_get_int80(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return In.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt88}
   */
  get_int88(t) {
    const e = i.compactciphertextlistexpander_get_int88(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Nn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt96}
   */
  get_int96(t) {
    const e = i.compactciphertextlistexpander_get_int96(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return On.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt104}
   */
  get_int104(t) {
    const e = i.compactciphertextlistexpander_get_int104(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Wr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt112}
   */
  get_int112(t) {
    const e = i.compactciphertextlistexpander_get_int112(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Jr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt120}
   */
  get_int120(t) {
    const e = i.compactciphertextlistexpander_get_int120(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Zr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt136}
   */
  get_int136(t) {
    const e = i.compactciphertextlistexpander_get_int136(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return tn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt144}
   */
  get_int144(t) {
    const e = i.compactciphertextlistexpander_get_int144(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return rn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt152}
   */
  get_int152(t) {
    const e = i.compactciphertextlistexpander_get_int152(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return nn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt168}
   */
  get_int168(t) {
    const e = i.compactciphertextlistexpander_get_int168(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return on.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt176}
   */
  get_int176(t) {
    const e = i.compactciphertextlistexpander_get_int176(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return an.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt184}
   */
  get_int184(t) {
    const e = i.compactciphertextlistexpander_get_int184(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return cn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt192}
   */
  get_int192(t) {
    const e = i.compactciphertextlistexpander_get_int192(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return un.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt200}
   */
  get_int200(t) {
    const e = i.compactciphertextlistexpander_get_int200(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return ln.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt208}
   */
  get_int208(t) {
    const e = i.compactciphertextlistexpander_get_int208(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return hn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt216}
   */
  get_int216(t) {
    const e = i.compactciphertextlistexpander_get_int216(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return wn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt224}
   */
  get_int224(t) {
    const e = i.compactciphertextlistexpander_get_int224(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return dn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt232}
   */
  get_int232(t) {
    const e = i.compactciphertextlistexpander_get_int232(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return gn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt240}
   */
  get_int240(t) {
    const e = i.compactciphertextlistexpander_get_int240(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return yn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt248}
   */
  get_int248(t) {
    const e = i.compactciphertextlistexpander_get_int248(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return An.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt2}
   */
  get_int2(t) {
    const e = i.compactciphertextlistexpander_get_int2(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return fn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt4}
   */
  get_int4(t) {
    const e = i.compactciphertextlistexpander_get_int4(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Rn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt6}
   */
  get_int6(t) {
    const e = i.compactciphertextlistexpander_get_int6(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Mn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt8}
   */
  get_int8(t) {
    const e = i.compactciphertextlistexpander_get_int8(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Cn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt10}
   */
  get_int10(t) {
    const e = i.compactciphertextlistexpander_get_int10(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return qr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt12}
   */
  get_int12(t) {
    const e = i.compactciphertextlistexpander_get_int12(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return $r.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt14}
   */
  get_int14(t) {
    const e = i.compactciphertextlistexpander_get_int14(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return en.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt16}
   */
  get_int16(t) {
    const e = i.compactciphertextlistexpander_get_int16(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return sn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt32}
   */
  get_int32(t) {
    const e = i.compactciphertextlistexpander_get_int32(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Sn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt64}
   */
  get_int64(t) {
    const e = i.compactciphertextlistexpander_get_int64(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return xn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt128}
   */
  get_int128(t) {
    const e = i.compactciphertextlistexpander_get_int128(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Xr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt160}
   */
  get_int160(t) {
    const e = i.compactciphertextlistexpander_get_int160(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return _n.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt256}
   */
  get_int256(t) {
    const e = i.compactciphertextlistexpander_get_int256(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return mn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt512}
   */
  get_int512(t) {
    const e = i.compactciphertextlistexpander_get_int512(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return zn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt1024}
   */
  get_int1024(t) {
    const e = i.compactciphertextlistexpander_get_int1024(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Qr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt2048}
   */
  get_int2048(t) {
    const e = i.compactciphertextlistexpander_get_int2048(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return pn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheBool}
   */
  get_bool(t) {
    const e = i.compactciphertextlistexpander_get_bool(this.__wbg_ptr, t);
    if (e[2])
      throw o(e[1]);
    return Hr.__wrap(e[0]);
  }
  /**
   * @returns {number}
   */
  len() {
    return i.compactciphertextlistexpander_len(this.__wbg_ptr) >>> 0;
  }
  /**
   * @returns {boolean}
   */
  is_empty() {
    return i.compactciphertextlistexpander_is_empty(this.__wbg_ptr) !== 0;
  }
  /**
   * @param {number} index
   * @returns {FheTypes | undefined}
   */
  get_kind_of(t) {
    const e = i.compactciphertextlistexpander_get_kind_of(this.__wbg_ptr, t);
    return e === 84 ? void 0 : e;
  }
}
const p0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compactpkecrs_free(n >>> 0, 1));
class pr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(pr.prototype);
    return e.__wbg_ptr = t, p0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, p0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compactpkecrs_free(t, 0);
  }
  /**
   * @param {boolean} compress
   * @returns {Uint8Array}
   */
  serialize(t) {
    const e = i.compactpkecrs_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompactPkeCrs}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compactpkecrs_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return pr.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compactpkecrs_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompactPkeCrs}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compactpkecrs_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return pr.__wrap(_[0]);
  }
  /**
   * @param {TfheConfig} config
   * @param {number} max_num_bits
   * @returns {CompactPkeCrs}
   */
  static from_config(t, e) {
    b(t, x_);
    const r = i.compactpkecrs_from_config(t.__wbg_ptr, e);
    if (r[2])
      throw o(r[1]);
    return pr.__wrap(r[0]);
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompactPkeCrs}
   */
  static deserialize_from_public_params(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compactpkecrs_deserialize_from_public_params(e, r);
    if (s[2])
      throw o(s[1]);
    return pr.__wrap(s[0]);
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompactPkeCrs}
   */
  static safe_deserialize_from_public_params(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compactpkecrs_safe_deserialize_from_public_params(r, s, e);
    if (_[2])
      throw o(_[1]);
    return pr.__wrap(_[0]);
  }
}
const h0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfhebool_free(n >>> 0, 1));
class j_ {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(j_.prototype);
    return e.__wbg_ptr = t, h0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, h0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfhebool_free(t, 0);
  }
  /**
   * @param {boolean} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheBool}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfhebool_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return j_.__wrap(r[0]);
  }
  /**
   * @returns {FheBool}
   */
  decompress() {
    const t = i.compressedfhebool_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Hr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfhebool_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheBool}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfhebool_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return j_.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfhebool_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheBool}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfhebool_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return j_.__wrap(_[0]);
  }
}
const w0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint10_free(n >>> 0, 1));
class V_ {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(V_.prototype);
    return e.__wbg_ptr = t, w0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, w0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint10_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt10}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint10_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return V_.__wrap(r[0]);
  }
  /**
   * @returns {FheInt10}
   */
  decompress() {
    const t = i.compressedfheint10_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return qr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint10_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt10}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint10_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return V_.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint10_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt10}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint10_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return V_.__wrap(_[0]);
  }
}
const d0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint1024_free(n >>> 0, 1));
class Y_ {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Y_.prototype);
    return e.__wbg_ptr = t, d0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, d0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint1024_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt1024}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint1024_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Y_.__wrap(r[0]);
  }
  /**
   * @returns {FheInt1024}
   */
  decompress() {
    const t = i.compressedfheint1024_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Qr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint1024_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt1024}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint1024_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Y_.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint1024_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt1024}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint1024_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Y_.__wrap(_[0]);
  }
}
const g0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint104_free(n >>> 0, 1));
class H_ {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(H_.prototype);
    return e.__wbg_ptr = t, g0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, g0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint104_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt104}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint104_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return H_.__wrap(r[0]);
  }
  /**
   * @returns {FheInt104}
   */
  decompress() {
    const t = i.compressedfheint104_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Wr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint104_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt104}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint104_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return H_.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint104_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt104}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint104_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return H_.__wrap(_[0]);
  }
}
const b0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint112_free(n >>> 0, 1));
class q_ {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(q_.prototype);
    return e.__wbg_ptr = t, b0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, b0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint112_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt112}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint112_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return q_.__wrap(r[0]);
  }
  /**
   * @returns {FheInt112}
   */
  decompress() {
    const t = i.compressedfheint112_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Jr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint112_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt112}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint112_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return q_.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint112_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt112}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint112_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return q_.__wrap(_[0]);
  }
}
const y0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint12_free(n >>> 0, 1));
class Q_ {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Q_.prototype);
    return e.__wbg_ptr = t, y0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, y0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint12_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt12}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint12_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Q_.__wrap(r[0]);
  }
  /**
   * @returns {FheInt12}
   */
  decompress() {
    const t = i.compressedfheint12_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return $r.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint12_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt12}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint12_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Q_.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint12_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt12}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint12_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Q_.__wrap(_[0]);
  }
}
const A0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint120_free(n >>> 0, 1));
class W_ {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(W_.prototype);
    return e.__wbg_ptr = t, A0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, A0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint120_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt120}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint120_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return W_.__wrap(r[0]);
  }
  /**
   * @returns {FheInt120}
   */
  decompress() {
    const t = i.compressedfheint120_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Zr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint120_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt120}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint120_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return W_.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint120_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt120}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint120_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return W_.__wrap(_[0]);
  }
}
const m0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint128_free(n >>> 0, 1));
class J_ {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(J_.prototype);
    return e.__wbg_ptr = t, m0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, m0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint128_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt128}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint128_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return J_.__wrap(r[0]);
  }
  /**
   * @returns {FheInt128}
   */
  decompress() {
    const t = i.compressedfheint128_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Xr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint128_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt128}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint128_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return J_.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint128_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt128}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint128_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return J_.__wrap(_[0]);
  }
}
const S0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint136_free(n >>> 0, 1));
class $_ {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create($_.prototype);
    return e.__wbg_ptr = t, S0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, S0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint136_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt136}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint136_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return $_.__wrap(r[0]);
  }
  /**
   * @returns {FheInt136}
   */
  decompress() {
    const t = i.compressedfheint136_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return tn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint136_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt136}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint136_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return $_.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint136_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt136}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint136_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return $_.__wrap(_[0]);
  }
}
const R0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint14_free(n >>> 0, 1));
class Z_ {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Z_.prototype);
    return e.__wbg_ptr = t, R0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, R0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint14_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt14}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint14_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Z_.__wrap(r[0]);
  }
  /**
   * @returns {FheInt14}
   */
  decompress() {
    const t = i.compressedfheint14_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return en.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint14_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt14}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint14_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Z_.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint14_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt14}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint14_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Z_.__wrap(_[0]);
  }
}
const E0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint144_free(n >>> 0, 1));
class X_ {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(X_.prototype);
    return e.__wbg_ptr = t, E0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, E0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint144_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt144}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint144_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return X_.__wrap(r[0]);
  }
  /**
   * @returns {FheInt144}
   */
  decompress() {
    const t = i.compressedfheint144_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return rn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint144_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt144}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint144_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return X_.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint144_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt144}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint144_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return X_.__wrap(_[0]);
  }
}
const P0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint152_free(n >>> 0, 1));
class to {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(to.prototype);
    return e.__wbg_ptr = t, P0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, P0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint152_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt152}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint152_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return to.__wrap(r[0]);
  }
  /**
   * @returns {FheInt152}
   */
  decompress() {
    const t = i.compressedfheint152_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return nn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint152_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt152}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint152_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return to.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint152_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt152}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint152_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return to.__wrap(_[0]);
  }
}
const z0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint16_free(n >>> 0, 1));
class eo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(eo.prototype);
    return e.__wbg_ptr = t, z0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, z0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint16_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt16}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint16_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return eo.__wrap(r[0]);
  }
  /**
   * @returns {FheInt16}
   */
  decompress() {
    const t = i.compressedfheint16_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return sn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint16_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt16}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint16_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return eo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint16_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt16}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint16_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return eo.__wrap(_[0]);
  }
}
const v0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint160_free(n >>> 0, 1));
class ro {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ro.prototype);
    return e.__wbg_ptr = t, v0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, v0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint160_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt160}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint160_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ro.__wrap(r[0]);
  }
  /**
   * @returns {FheInt160}
   */
  decompress() {
    const t = i.compressedfheint160_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return _n.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint160_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt160}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint160_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ro.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint160_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt160}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint160_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ro.__wrap(_[0]);
  }
}
const M0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint168_free(n >>> 0, 1));
class no {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(no.prototype);
    return e.__wbg_ptr = t, M0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, M0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint168_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt168}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint168_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return no.__wrap(r[0]);
  }
  /**
   * @returns {FheInt168}
   */
  decompress() {
    const t = i.compressedfheint168_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return on.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint168_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt168}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint168_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return no.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint168_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt168}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint168_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return no.__wrap(_[0]);
  }
}
const x0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint176_free(n >>> 0, 1));
class io {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(io.prototype);
    return e.__wbg_ptr = t, x0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, x0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint176_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt176}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint176_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return io.__wrap(r[0]);
  }
  /**
   * @returns {FheInt176}
   */
  decompress() {
    const t = i.compressedfheint176_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return an.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint176_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt176}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint176_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return io.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint176_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt176}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint176_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return io.__wrap(_[0]);
  }
}
const B0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint184_free(n >>> 0, 1));
class so {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(so.prototype);
    return e.__wbg_ptr = t, B0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, B0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint184_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt184}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint184_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return so.__wrap(r[0]);
  }
  /**
   * @returns {FheInt184}
   */
  decompress() {
    const t = i.compressedfheint184_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return cn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint184_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt184}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint184_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return so.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint184_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt184}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint184_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return so.__wrap(_[0]);
  }
}
const C0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint192_free(n >>> 0, 1));
class _o {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(_o.prototype);
    return e.__wbg_ptr = t, C0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, C0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint192_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt192}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint192_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return _o.__wrap(r[0]);
  }
  /**
   * @returns {FheInt192}
   */
  decompress() {
    const t = i.compressedfheint192_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return un.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint192_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt192}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint192_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return _o.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint192_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt192}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint192_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return _o.__wrap(_[0]);
  }
}
const I0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint2_free(n >>> 0, 1));
class oo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(oo.prototype);
    return e.__wbg_ptr = t, I0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, I0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint2_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt2}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint2_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return oo.__wrap(r[0]);
  }
  /**
   * @returns {FheInt2}
   */
  decompress() {
    const t = i.compressedfheint2_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return fn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint2_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt2}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint2_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return oo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint2_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt2}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint2_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return oo.__wrap(_[0]);
  }
}
const N0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint200_free(n >>> 0, 1));
class ao {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ao.prototype);
    return e.__wbg_ptr = t, N0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, N0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint200_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt200}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint200_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ao.__wrap(r[0]);
  }
  /**
   * @returns {FheInt200}
   */
  decompress() {
    const t = i.compressedfheint200_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return ln.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint200_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt200}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint200_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ao.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint200_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt200}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint200_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ao.__wrap(_[0]);
  }
}
const O0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint2048_free(n >>> 0, 1));
class co {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(co.prototype);
    return e.__wbg_ptr = t, O0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, O0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint2048_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt2048}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint2048_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return co.__wrap(r[0]);
  }
  /**
   * @returns {FheInt2048}
   */
  decompress() {
    const t = i.compressedfheint2048_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return pn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint2048_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt2048}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint2048_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return co.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint2048_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt2048}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint2048_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return co.__wrap(_[0]);
  }
}
const k0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint208_free(n >>> 0, 1));
class uo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(uo.prototype);
    return e.__wbg_ptr = t, k0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, k0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint208_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt208}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint208_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return uo.__wrap(r[0]);
  }
  /**
   * @returns {FheInt208}
   */
  decompress() {
    const t = i.compressedfheint208_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return hn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint208_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt208}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint208_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return uo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint208_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt208}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint208_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return uo.__wrap(_[0]);
  }
}
const T0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint216_free(n >>> 0, 1));
class fo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(fo.prototype);
    return e.__wbg_ptr = t, T0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, T0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint216_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt216}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint216_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return fo.__wrap(r[0]);
  }
  /**
   * @returns {FheInt216}
   */
  decompress() {
    const t = i.compressedfheint216_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return wn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint216_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt216}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint216_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return fo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint216_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt216}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint216_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return fo.__wrap(_[0]);
  }
}
const G0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint224_free(n >>> 0, 1));
class lo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(lo.prototype);
    return e.__wbg_ptr = t, G0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, G0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint224_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt224}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint224_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return lo.__wrap(r[0]);
  }
  /**
   * @returns {FheInt224}
   */
  decompress() {
    const t = i.compressedfheint224_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return dn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint224_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt224}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint224_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return lo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint224_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt224}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint224_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return lo.__wrap(_[0]);
  }
}
const U0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint232_free(n >>> 0, 1));
class po {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(po.prototype);
    return e.__wbg_ptr = t, U0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, U0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint232_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt232}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint232_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return po.__wrap(r[0]);
  }
  /**
   * @returns {FheInt232}
   */
  decompress() {
    const t = i.compressedfheint232_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return gn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint232_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt232}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint232_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return po.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint232_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt232}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint232_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return po.__wrap(_[0]);
  }
}
const F0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint24_free(n >>> 0, 1));
class ho {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ho.prototype);
    return e.__wbg_ptr = t, F0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, F0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint24_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt24}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint24_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ho.__wrap(r[0]);
  }
  /**
   * @returns {FheInt24}
   */
  decompress() {
    const t = i.compressedfheint24_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return bn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint24_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt24}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint24_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ho.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint24_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt24}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint24_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ho.__wrap(_[0]);
  }
}
const K0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint240_free(n >>> 0, 1));
class wo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(wo.prototype);
    return e.__wbg_ptr = t, K0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, K0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint240_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt240}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint240_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return wo.__wrap(r[0]);
  }
  /**
   * @returns {FheInt240}
   */
  decompress() {
    const t = i.compressedfheint240_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return yn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint240_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt240}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint240_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return wo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint240_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt240}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint240_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return wo.__wrap(_[0]);
  }
}
const D0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint248_free(n >>> 0, 1));
class go {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(go.prototype);
    return e.__wbg_ptr = t, D0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, D0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint248_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt248}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint248_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return go.__wrap(r[0]);
  }
  /**
   * @returns {FheInt248}
   */
  decompress() {
    const t = i.compressedfheint248_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return An.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint248_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt248}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint248_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return go.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint248_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt248}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint248_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return go.__wrap(_[0]);
  }
}
const L0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint256_free(n >>> 0, 1));
class bo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(bo.prototype);
    return e.__wbg_ptr = t, L0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, L0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint256_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt256}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint256_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return bo.__wrap(r[0]);
  }
  /**
   * @returns {FheInt256}
   */
  decompress() {
    const t = i.compressedfheint256_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return mn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint256_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt256}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint256_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return bo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint256_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt256}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint256_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return bo.__wrap(_[0]);
  }
}
const j0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint32_free(n >>> 0, 1));
class yo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(yo.prototype);
    return e.__wbg_ptr = t, j0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, j0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint32_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt32}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint32_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return yo.__wrap(r[0]);
  }
  /**
   * @returns {FheInt32}
   */
  decompress() {
    const t = i.compressedfheint32_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Sn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint32_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt32}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint32_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return yo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint32_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt32}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint32_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return yo.__wrap(_[0]);
  }
}
const V0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint4_free(n >>> 0, 1));
class Ao {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ao.prototype);
    return e.__wbg_ptr = t, V0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, V0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint4_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt4}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint4_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Ao.__wrap(r[0]);
  }
  /**
   * @returns {FheInt4}
   */
  decompress() {
    const t = i.compressedfheint4_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Rn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint4_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt4}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint4_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Ao.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint4_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt4}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint4_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Ao.__wrap(_[0]);
  }
}
const Y0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint40_free(n >>> 0, 1));
class mo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(mo.prototype);
    return e.__wbg_ptr = t, Y0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Y0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint40_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt40}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint40_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return mo.__wrap(r[0]);
  }
  /**
   * @returns {FheInt40}
   */
  decompress() {
    const t = i.compressedfheint40_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return En.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint40_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt40}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint40_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return mo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint40_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt40}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint40_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return mo.__wrap(_[0]);
  }
}
const H0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint48_free(n >>> 0, 1));
class So {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(So.prototype);
    return e.__wbg_ptr = t, H0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, H0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint48_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt48}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint48_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return So.__wrap(r[0]);
  }
  /**
   * @returns {FheInt48}
   */
  decompress() {
    const t = i.compressedfheint48_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Pn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint48_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt48}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint48_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return So.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint48_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt48}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint48_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return So.__wrap(_[0]);
  }
}
const q0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint512_free(n >>> 0, 1));
class Ro {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ro.prototype);
    return e.__wbg_ptr = t, q0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, q0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint512_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt512}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint512_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Ro.__wrap(r[0]);
  }
  /**
   * @returns {FheInt512}
   */
  decompress() {
    const t = i.compressedfheint512_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return zn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint512_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt512}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint512_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Ro.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint512_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt512}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint512_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Ro.__wrap(_[0]);
  }
}
const Q0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint56_free(n >>> 0, 1));
class Eo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Eo.prototype);
    return e.__wbg_ptr = t, Q0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Q0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint56_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt56}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint56_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Eo.__wrap(r[0]);
  }
  /**
   * @returns {FheInt56}
   */
  decompress() {
    const t = i.compressedfheint56_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return vn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint56_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt56}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint56_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Eo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint56_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt56}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint56_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Eo.__wrap(_[0]);
  }
}
const W0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint6_free(n >>> 0, 1));
class Po {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Po.prototype);
    return e.__wbg_ptr = t, W0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, W0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint6_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt6}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint6_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Po.__wrap(r[0]);
  }
  /**
   * @returns {FheInt6}
   */
  decompress() {
    const t = i.compressedfheint6_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Mn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint6_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt6}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint6_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Po.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint6_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt6}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint6_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Po.__wrap(_[0]);
  }
}
const J0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint64_free(n >>> 0, 1));
class zo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(zo.prototype);
    return e.__wbg_ptr = t, J0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, J0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint64_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt64}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint64_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return zo.__wrap(r[0]);
  }
  /**
   * @returns {FheInt64}
   */
  decompress() {
    const t = i.compressedfheint64_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return xn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint64_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt64}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint64_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return zo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint64_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt64}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint64_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return zo.__wrap(_[0]);
  }
}
const $0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint72_free(n >>> 0, 1));
class vo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(vo.prototype);
    return e.__wbg_ptr = t, $0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, $0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint72_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt72}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint72_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return vo.__wrap(r[0]);
  }
  /**
   * @returns {FheInt72}
   */
  decompress() {
    const t = i.compressedfheint72_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Bn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint72_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt72}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint72_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return vo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint72_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt72}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint72_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return vo.__wrap(_[0]);
  }
}
const Z0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint8_free(n >>> 0, 1));
class Mo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Mo.prototype);
    return e.__wbg_ptr = t, Z0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Z0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint8_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt8}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint8_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Mo.__wrap(r[0]);
  }
  /**
   * @returns {FheInt8}
   */
  decompress() {
    const t = i.compressedfheint8_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Cn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint8_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt8}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint8_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Mo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint8_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt8}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint8_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Mo.__wrap(_[0]);
  }
}
const X0 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint80_free(n >>> 0, 1));
class xo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(xo.prototype);
    return e.__wbg_ptr = t, X0.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, X0.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint80_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt80}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint80_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return xo.__wrap(r[0]);
  }
  /**
   * @returns {FheInt80}
   */
  decompress() {
    const t = i.compressedfheint80_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return In.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint80_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt80}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint80_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return xo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint80_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt80}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint80_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return xo.__wrap(_[0]);
  }
}
const t1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint88_free(n >>> 0, 1));
class Bo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Bo.prototype);
    return e.__wbg_ptr = t, t1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, t1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint88_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt88}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint88_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Bo.__wrap(r[0]);
  }
  /**
   * @returns {FheInt88}
   */
  decompress() {
    const t = i.compressedfheint88_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Nn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint88_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt88}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint88_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Bo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint88_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt88}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint88_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Bo.__wrap(_[0]);
  }
}
const e1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheint96_free(n >>> 0, 1));
class Co {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Co.prototype);
    return e.__wbg_ptr = t, e1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, e1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheint96_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt96}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheint96_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Co.__wrap(r[0]);
  }
  /**
   * @returns {FheInt96}
   */
  decompress() {
    const t = i.compressedfheint96_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return On.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheint96_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt96}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheint96_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Co.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheint96_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt96}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheint96_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Co.__wrap(_[0]);
  }
}
const r1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint10_free(n >>> 0, 1));
class Io {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Io.prototype);
    return e.__wbg_ptr = t, r1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, r1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint10_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint10}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint10_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Io.__wrap(r[0]);
  }
  /**
   * @returns {FheUint10}
   */
  decompress() {
    const t = i.compressedfheuint10_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return kn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint10_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint10}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint10_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Io.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint10_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint10}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint10_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Io.__wrap(_[0]);
  }
}
const n1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint1024_free(n >>> 0, 1));
class No {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(No.prototype);
    return e.__wbg_ptr = t, n1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, n1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint1024_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint1024}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint1024_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return No.__wrap(r[0]);
  }
  /**
   * @returns {FheUint1024}
   */
  decompress() {
    const t = i.compressedfheuint1024_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Tn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint1024_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint1024}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint1024_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return No.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint1024_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint1024}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint1024_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return No.__wrap(_[0]);
  }
}
const i1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint104_free(n >>> 0, 1));
class Oo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Oo.prototype);
    return e.__wbg_ptr = t, i1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, i1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint104_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint104}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint104_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Oo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint104}
   */
  decompress() {
    const t = i.compressedfheuint104_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Gn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint104_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint104}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint104_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Oo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint104_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint104}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint104_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Oo.__wrap(_[0]);
  }
}
const s1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint112_free(n >>> 0, 1));
class ko {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ko.prototype);
    return e.__wbg_ptr = t, s1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, s1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint112_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint112}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint112_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ko.__wrap(r[0]);
  }
  /**
   * @returns {FheUint112}
   */
  decompress() {
    const t = i.compressedfheuint112_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Un.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint112_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint112}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint112_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ko.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint112_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint112}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint112_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ko.__wrap(_[0]);
  }
}
const _1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint12_free(n >>> 0, 1));
class To {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(To.prototype);
    return e.__wbg_ptr = t, _1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, _1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint12_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint12}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint12_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return To.__wrap(r[0]);
  }
  /**
   * @returns {FheUint12}
   */
  decompress() {
    const t = i.compressedfheuint12_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Fn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint12_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint12}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint12_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return To.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint12_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint12}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint12_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return To.__wrap(_[0]);
  }
}
const o1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint120_free(n >>> 0, 1));
class Go {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Go.prototype);
    return e.__wbg_ptr = t, o1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, o1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint120_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint120}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint120_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Go.__wrap(r[0]);
  }
  /**
   * @returns {FheUint120}
   */
  decompress() {
    const t = i.compressedfheuint120_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Kn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint120_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint120}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint120_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Go.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint120_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint120}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint120_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Go.__wrap(_[0]);
  }
}
const a1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint128_free(n >>> 0, 1));
class Uo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Uo.prototype);
    return e.__wbg_ptr = t, a1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, a1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint128_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint128}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint128_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Uo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint128}
   */
  decompress() {
    const t = i.compressedfheuint128_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Dn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint128_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint128}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint128_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Uo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint128_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint128}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint128_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Uo.__wrap(_[0]);
  }
}
const c1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint136_free(n >>> 0, 1));
class Fo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Fo.prototype);
    return e.__wbg_ptr = t, c1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, c1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint136_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint136}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint136_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Fo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint136}
   */
  decompress() {
    const t = i.compressedfheuint136_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Ln.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint136_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint136}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint136_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Fo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint136_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint136}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint136_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Fo.__wrap(_[0]);
  }
}
const u1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint14_free(n >>> 0, 1));
class Ko {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ko.prototype);
    return e.__wbg_ptr = t, u1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, u1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint14_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint14}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint14_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Ko.__wrap(r[0]);
  }
  /**
   * @returns {FheUint14}
   */
  decompress() {
    const t = i.compressedfheuint14_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return jn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint14_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint14}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint14_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Ko.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint14_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint14}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint14_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Ko.__wrap(_[0]);
  }
}
const f1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint144_free(n >>> 0, 1));
class Do {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Do.prototype);
    return e.__wbg_ptr = t, f1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, f1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint144_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint144}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint144_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Do.__wrap(r[0]);
  }
  /**
   * @returns {FheUint144}
   */
  decompress() {
    const t = i.compressedfheuint144_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Vn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint144_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint144}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint144_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Do.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint144_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint144}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint144_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Do.__wrap(_[0]);
  }
}
const l1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint152_free(n >>> 0, 1));
class Lo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Lo.prototype);
    return e.__wbg_ptr = t, l1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, l1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint152_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint152}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint152_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Lo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint152}
   */
  decompress() {
    const t = i.compressedfheuint152_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Yn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint152_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint152}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint152_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Lo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint152_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint152}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint152_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Lo.__wrap(_[0]);
  }
}
const p1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint16_free(n >>> 0, 1));
class jo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(jo.prototype);
    return e.__wbg_ptr = t, p1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, p1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint16_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint16}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint16_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return jo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint16}
   */
  decompress() {
    const t = i.compressedfheuint16_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Hn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint16_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint16}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint16_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return jo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint16_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint16}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint16_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return jo.__wrap(_[0]);
  }
}
const h1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint160_free(n >>> 0, 1));
class Vo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Vo.prototype);
    return e.__wbg_ptr = t, h1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, h1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint160_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint160}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint160_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Vo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint160}
   */
  decompress() {
    const t = i.compressedfheuint160_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return qn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint160_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint160}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint160_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Vo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint160_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint160}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint160_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Vo.__wrap(_[0]);
  }
}
const w1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint168_free(n >>> 0, 1));
class Yo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Yo.prototype);
    return e.__wbg_ptr = t, w1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, w1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint168_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint168}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint168_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Yo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint168}
   */
  decompress() {
    const t = i.compressedfheuint168_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Qn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint168_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint168}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint168_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Yo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint168_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint168}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint168_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Yo.__wrap(_[0]);
  }
}
const d1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint176_free(n >>> 0, 1));
class Ho {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ho.prototype);
    return e.__wbg_ptr = t, d1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, d1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint176_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint176}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint176_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Ho.__wrap(r[0]);
  }
  /**
   * @returns {FheUint176}
   */
  decompress() {
    const t = i.compressedfheuint176_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Wn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint176_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint176}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint176_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Ho.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint176_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint176}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint176_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Ho.__wrap(_[0]);
  }
}
const g1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint184_free(n >>> 0, 1));
class qo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(qo.prototype);
    return e.__wbg_ptr = t, g1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, g1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint184_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint184}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint184_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return qo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint184}
   */
  decompress() {
    const t = i.compressedfheuint184_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Jn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint184_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint184}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint184_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return qo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint184_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint184}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint184_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return qo.__wrap(_[0]);
  }
}
const b1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint192_free(n >>> 0, 1));
class Qo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Qo.prototype);
    return e.__wbg_ptr = t, b1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, b1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint192_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint192}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint192_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Qo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint192}
   */
  decompress() {
    const t = i.compressedfheuint192_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return $n.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint192_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint192}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint192_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Qo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint192_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint192}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint192_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Qo.__wrap(_[0]);
  }
}
const y1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint2_free(n >>> 0, 1));
class Wo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Wo.prototype);
    return e.__wbg_ptr = t, y1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, y1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint2_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint2}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint2_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Wo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint2}
   */
  decompress() {
    const t = i.compressedfheuint2_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Zn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint2_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint2}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint2_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Wo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint2_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint2}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint2_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Wo.__wrap(_[0]);
  }
}
const A1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint200_free(n >>> 0, 1));
class Jo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Jo.prototype);
    return e.__wbg_ptr = t, A1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, A1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint200_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint200}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint200_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Jo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint200}
   */
  decompress() {
    const t = i.compressedfheuint200_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Xn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint200_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint200}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint200_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Jo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint200_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint200}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint200_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Jo.__wrap(_[0]);
  }
}
const m1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint2048_free(n >>> 0, 1));
class $o {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create($o.prototype);
    return e.__wbg_ptr = t, m1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, m1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint2048_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint2048}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint2048_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return $o.__wrap(r[0]);
  }
  /**
   * @returns {FheUint2048}
   */
  decompress() {
    const t = i.compressedfheuint2048_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return ti.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint2048_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint2048}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint2048_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return $o.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint2048_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint2048}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint2048_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return $o.__wrap(_[0]);
  }
}
const S1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint208_free(n >>> 0, 1));
class Zo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Zo.prototype);
    return e.__wbg_ptr = t, S1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, S1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint208_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint208}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint208_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Zo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint208}
   */
  decompress() {
    const t = i.compressedfheuint208_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return ei.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint208_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint208}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint208_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Zo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint208_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint208}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint208_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Zo.__wrap(_[0]);
  }
}
const R1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint216_free(n >>> 0, 1));
class Xo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Xo.prototype);
    return e.__wbg_ptr = t, R1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, R1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint216_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint216}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint216_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Xo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint216}
   */
  decompress() {
    const t = i.compressedfheuint216_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return ri.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint216_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint216}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint216_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Xo.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint216_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint216}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint216_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Xo.__wrap(_[0]);
  }
}
const E1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint224_free(n >>> 0, 1));
class ta {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ta.prototype);
    return e.__wbg_ptr = t, E1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, E1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint224_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint224}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint224_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ta.__wrap(r[0]);
  }
  /**
   * @returns {FheUint224}
   */
  decompress() {
    const t = i.compressedfheuint224_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return ni.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint224_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint224}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint224_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ta.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint224_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint224}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint224_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ta.__wrap(_[0]);
  }
}
const P1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint232_free(n >>> 0, 1));
class ea {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ea.prototype);
    return e.__wbg_ptr = t, P1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, P1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint232_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint232}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint232_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ea.__wrap(r[0]);
  }
  /**
   * @returns {FheUint232}
   */
  decompress() {
    const t = i.compressedfheuint232_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return ii.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint232_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint232}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint232_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ea.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint232_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint232}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint232_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ea.__wrap(_[0]);
  }
}
const z1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint24_free(n >>> 0, 1));
class ra {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ra.prototype);
    return e.__wbg_ptr = t, z1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, z1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint24_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint24}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint24_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ra.__wrap(r[0]);
  }
  /**
   * @returns {FheUint24}
   */
  decompress() {
    const t = i.compressedfheuint24_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return si.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint24_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint24}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint24_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ra.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint24_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint24}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint24_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ra.__wrap(_[0]);
  }
}
const v1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint240_free(n >>> 0, 1));
class na {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(na.prototype);
    return e.__wbg_ptr = t, v1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, v1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint240_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint240}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint240_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return na.__wrap(r[0]);
  }
  /**
   * @returns {FheUint240}
   */
  decompress() {
    const t = i.compressedfheuint240_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return _i.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint240_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint240}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint240_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return na.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint240_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint240}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint240_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return na.__wrap(_[0]);
  }
}
const M1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint248_free(n >>> 0, 1));
class ia {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ia.prototype);
    return e.__wbg_ptr = t, M1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, M1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint248_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint248}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint248_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ia.__wrap(r[0]);
  }
  /**
   * @returns {FheUint248}
   */
  decompress() {
    const t = i.compressedfheuint248_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return oi.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint248_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint248}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint248_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ia.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint248_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint248}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint248_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ia.__wrap(_[0]);
  }
}
const x1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint256_free(n >>> 0, 1));
class sa {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(sa.prototype);
    return e.__wbg_ptr = t, x1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, x1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint256_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint256}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint256_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return sa.__wrap(r[0]);
  }
  /**
   * @returns {FheUint256}
   */
  decompress() {
    const t = i.compressedfheuint256_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return ai.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint256_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint256}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint256_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return sa.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint256_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint256}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint256_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return sa.__wrap(_[0]);
  }
}
const B1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint32_free(n >>> 0, 1));
class _a {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(_a.prototype);
    return e.__wbg_ptr = t, B1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, B1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint32_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint32}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint32_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return _a.__wrap(r[0]);
  }
  /**
   * @returns {FheUint32}
   */
  decompress() {
    const t = i.compressedfheuint32_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return ci.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint32_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint32}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint32_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return _a.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint32_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint32}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint32_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return _a.__wrap(_[0]);
  }
}
const C1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint4_free(n >>> 0, 1));
class oa {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(oa.prototype);
    return e.__wbg_ptr = t, C1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, C1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint4_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint4}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint4_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return oa.__wrap(r[0]);
  }
  /**
   * @returns {FheUint4}
   */
  decompress() {
    const t = i.compressedfheuint4_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return ui.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint4_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint4}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint4_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return oa.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint4_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint4}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint4_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return oa.__wrap(_[0]);
  }
}
const I1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint40_free(n >>> 0, 1));
class aa {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(aa.prototype);
    return e.__wbg_ptr = t, I1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, I1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint40_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint40}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint40_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return aa.__wrap(r[0]);
  }
  /**
   * @returns {FheUint40}
   */
  decompress() {
    const t = i.compressedfheuint40_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return fi.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint40_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint40}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint40_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return aa.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint40_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint40}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint40_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return aa.__wrap(_[0]);
  }
}
const N1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint48_free(n >>> 0, 1));
class ca {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ca.prototype);
    return e.__wbg_ptr = t, N1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, N1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint48_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint48}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint48_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ca.__wrap(r[0]);
  }
  /**
   * @returns {FheUint48}
   */
  decompress() {
    const t = i.compressedfheuint48_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return li.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint48_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint48}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint48_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ca.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint48_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint48}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint48_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ca.__wrap(_[0]);
  }
}
const O1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint512_free(n >>> 0, 1));
class ua {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ua.prototype);
    return e.__wbg_ptr = t, O1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, O1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint512_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint512}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint512_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ua.__wrap(r[0]);
  }
  /**
   * @returns {FheUint512}
   */
  decompress() {
    const t = i.compressedfheuint512_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return pi.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint512_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint512}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint512_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ua.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint512_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint512}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint512_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ua.__wrap(_[0]);
  }
}
const k1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint56_free(n >>> 0, 1));
class fa {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(fa.prototype);
    return e.__wbg_ptr = t, k1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, k1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint56_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint56}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint56_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return fa.__wrap(r[0]);
  }
  /**
   * @returns {FheUint56}
   */
  decompress() {
    const t = i.compressedfheuint56_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return hi.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint56_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint56}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint56_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return fa.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint56_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint56}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint56_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return fa.__wrap(_[0]);
  }
}
const T1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint6_free(n >>> 0, 1));
class la {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(la.prototype);
    return e.__wbg_ptr = t, T1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, T1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint6_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint6}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint6_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return la.__wrap(r[0]);
  }
  /**
   * @returns {FheUint6}
   */
  decompress() {
    const t = i.compressedfheuint6_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return wi.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint6_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint6}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint6_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return la.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint6_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint6}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint6_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return la.__wrap(_[0]);
  }
}
const G1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint64_free(n >>> 0, 1));
class pa {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(pa.prototype);
    return e.__wbg_ptr = t, G1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, G1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint64_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint64}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint64_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return pa.__wrap(r[0]);
  }
  /**
   * @returns {FheUint64}
   */
  decompress() {
    const t = i.compressedfheuint64_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return di.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint64_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint64}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint64_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return pa.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint64_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint64}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint64_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return pa.__wrap(_[0]);
  }
}
const U1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint72_free(n >>> 0, 1));
class ha {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ha.prototype);
    return e.__wbg_ptr = t, U1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, U1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint72_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint72}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint72_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ha.__wrap(r[0]);
  }
  /**
   * @returns {FheUint72}
   */
  decompress() {
    const t = i.compressedfheuint72_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return gi.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint72_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint72}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint72_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ha.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint72_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint72}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint72_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ha.__wrap(_[0]);
  }
}
const F1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint8_free(n >>> 0, 1));
class wa {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(wa.prototype);
    return e.__wbg_ptr = t, F1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, F1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint8_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint8}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint8_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return wa.__wrap(r[0]);
  }
  /**
   * @returns {FheUint8}
   */
  decompress() {
    const t = i.compressedfheuint8_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return bi.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint8_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint8}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint8_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return wa.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint8_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint8}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint8_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return wa.__wrap(_[0]);
  }
}
const K1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint80_free(n >>> 0, 1));
class da {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(da.prototype);
    return e.__wbg_ptr = t, K1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, K1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint80_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint80}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint80_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return da.__wrap(r[0]);
  }
  /**
   * @returns {FheUint80}
   */
  decompress() {
    const t = i.compressedfheuint80_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return yi.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint80_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint80}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint80_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return da.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint80_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint80}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint80_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return da.__wrap(_[0]);
  }
}
const D1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint88_free(n >>> 0, 1));
class ga {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ga.prototype);
    return e.__wbg_ptr = t, D1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, D1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint88_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint88}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint88_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ga.__wrap(r[0]);
  }
  /**
   * @returns {FheUint88}
   */
  decompress() {
    const t = i.compressedfheuint88_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Ai.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint88_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint88}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint88_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ga.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint88_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint88}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint88_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ga.__wrap(_[0]);
  }
}
const L1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_compressedfheuint96_free(n >>> 0, 1));
class ba {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ba.prototype);
    return e.__wbg_ptr = t, L1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, L1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_compressedfheuint96_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint96}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.compressedfheuint96_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ba.__wrap(r[0]);
  }
  /**
   * @returns {FheUint96}
   */
  decompress() {
    const t = i.compressedfheuint96_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return mi.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.compressedfheuint96_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint96}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.compressedfheuint96_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ba.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.compressedfheuint96_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint96}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.compressedfheuint96_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ba.__wrap(_[0]);
  }
}
const j1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fhebool_free(n >>> 0, 1));
class Hr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Hr.prototype);
    return e.__wbg_ptr = t, j1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, j1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fhebool_free(t, 0);
  }
  /**
   * @param {boolean} value
   * @param {TfheClientKey} client_key
   * @returns {FheBool}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fhebool_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Hr.__wrap(r[0]);
  }
  /**
   * @param {boolean} value
   * @param {TfhePublicKey} public_key
   * @returns {FheBool}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fhebool_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Hr.__wrap(r[0]);
  }
  /**
   * @param {boolean} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheBool}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fhebool_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Hr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {boolean}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fhebool_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0] !== 0;
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fhebool_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheBool}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fhebool_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Hr.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fhebool_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheBool}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fhebool_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Hr.__wrap(_[0]);
  }
}
const V1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint10_free(n >>> 0, 1));
class qr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(qr.prototype);
    return e.__wbg_ptr = t, V1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, V1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint10_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt10}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint10_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return qr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt10}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint10_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return qr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt10}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint10_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return qr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint10_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint10_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt10}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint10_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return qr.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint10_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt10}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint10_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return qr.__wrap(_[0]);
  }
}
const Y1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint1024_free(n >>> 0, 1));
class Qr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Qr.prototype);
    return e.__wbg_ptr = t, Y1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Y1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint1024_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt1024}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint1024_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Qr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt1024}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint1024_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Qr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt1024}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint1024_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Qr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint1024_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint1024_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt1024}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint1024_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Qr.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint1024_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt1024}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint1024_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Qr.__wrap(_[0]);
  }
}
const H1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint104_free(n >>> 0, 1));
class Wr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Wr.prototype);
    return e.__wbg_ptr = t, H1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, H1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint104_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt104}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint104_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Wr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt104}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint104_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Wr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt104}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint104_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Wr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint104_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint104_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt104}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint104_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Wr.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint104_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt104}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint104_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Wr.__wrap(_[0]);
  }
}
const q1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint112_free(n >>> 0, 1));
class Jr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Jr.prototype);
    return e.__wbg_ptr = t, q1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, q1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint112_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt112}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint112_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Jr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt112}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint112_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Jr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt112}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint112_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Jr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint112_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint112_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt112}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint112_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Jr.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint112_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt112}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint112_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Jr.__wrap(_[0]);
  }
}
const Q1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint12_free(n >>> 0, 1));
class $r {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create($r.prototype);
    return e.__wbg_ptr = t, Q1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Q1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint12_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt12}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint12_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return $r.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt12}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint12_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return $r.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt12}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint12_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return $r.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint12_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint12_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt12}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint12_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return $r.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint12_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt12}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint12_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return $r.__wrap(_[0]);
  }
}
const W1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint120_free(n >>> 0, 1));
class Zr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Zr.prototype);
    return e.__wbg_ptr = t, W1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, W1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint120_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt120}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint120_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Zr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt120}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint120_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Zr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt120}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint120_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Zr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint120_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint120_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt120}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint120_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Zr.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint120_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt120}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint120_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Zr.__wrap(_[0]);
  }
}
const J1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint128_free(n >>> 0, 1));
class Xr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Xr.prototype);
    return e.__wbg_ptr = t, J1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, J1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint128_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt128}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint128_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Xr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt128}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint128_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Xr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt128}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint128_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Xr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint128_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint128_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt128}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint128_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Xr.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint128_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt128}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint128_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Xr.__wrap(_[0]);
  }
}
const $1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint136_free(n >>> 0, 1));
class tn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(tn.prototype);
    return e.__wbg_ptr = t, $1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, $1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint136_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt136}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint136_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return tn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt136}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint136_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return tn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt136}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint136_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return tn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint136_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint136_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt136}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint136_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return tn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint136_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt136}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint136_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return tn.__wrap(_[0]);
  }
}
const Z1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint14_free(n >>> 0, 1));
class en {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(en.prototype);
    return e.__wbg_ptr = t, Z1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Z1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint14_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt14}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint14_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return en.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt14}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint14_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return en.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt14}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint14_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return en.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint14_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint14_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt14}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint14_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return en.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint14_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt14}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint14_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return en.__wrap(_[0]);
  }
}
const X1 = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint144_free(n >>> 0, 1));
class rn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(rn.prototype);
    return e.__wbg_ptr = t, X1.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, X1.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint144_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt144}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint144_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return rn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt144}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint144_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return rn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt144}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint144_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return rn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint144_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint144_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt144}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint144_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return rn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint144_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt144}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint144_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return rn.__wrap(_[0]);
  }
}
const tb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint152_free(n >>> 0, 1));
class nn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(nn.prototype);
    return e.__wbg_ptr = t, tb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, tb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint152_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt152}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint152_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return nn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt152}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint152_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return nn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt152}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint152_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return nn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint152_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint152_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt152}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint152_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return nn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint152_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt152}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint152_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return nn.__wrap(_[0]);
  }
}
const eb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint16_free(n >>> 0, 1));
class sn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(sn.prototype);
    return e.__wbg_ptr = t, eb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, eb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint16_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt16}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint16_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return sn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt16}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint16_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return sn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt16}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint16_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return sn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint16_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint16_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt16}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint16_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return sn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint16_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt16}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint16_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return sn.__wrap(_[0]);
  }
}
const rb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint160_free(n >>> 0, 1));
class _n {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(_n.prototype);
    return e.__wbg_ptr = t, rb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, rb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint160_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt160}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint160_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return _n.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt160}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint160_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return _n.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt160}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint160_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return _n.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint160_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint160_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt160}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint160_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return _n.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint160_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt160}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint160_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return _n.__wrap(_[0]);
  }
}
const nb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint168_free(n >>> 0, 1));
class on {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(on.prototype);
    return e.__wbg_ptr = t, nb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, nb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint168_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt168}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint168_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return on.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt168}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint168_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return on.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt168}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint168_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return on.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint168_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint168_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt168}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint168_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return on.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint168_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt168}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint168_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return on.__wrap(_[0]);
  }
}
const ib = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint176_free(n >>> 0, 1));
class an {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(an.prototype);
    return e.__wbg_ptr = t, ib.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ib.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint176_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt176}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint176_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return an.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt176}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint176_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return an.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt176}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint176_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return an.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint176_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint176_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt176}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint176_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return an.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint176_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt176}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint176_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return an.__wrap(_[0]);
  }
}
const sb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint184_free(n >>> 0, 1));
class cn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(cn.prototype);
    return e.__wbg_ptr = t, sb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, sb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint184_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt184}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint184_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return cn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt184}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint184_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return cn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt184}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint184_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return cn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint184_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint184_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt184}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint184_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return cn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint184_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt184}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint184_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return cn.__wrap(_[0]);
  }
}
const _b = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint192_free(n >>> 0, 1));
class un {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(un.prototype);
    return e.__wbg_ptr = t, _b.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, _b.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint192_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt192}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint192_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return un.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt192}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint192_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return un.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt192}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint192_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return un.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint192_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint192_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt192}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint192_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return un.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint192_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt192}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint192_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return un.__wrap(_[0]);
  }
}
const ob = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint2_free(n >>> 0, 1));
class fn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(fn.prototype);
    return e.__wbg_ptr = t, ob.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ob.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint2_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt2}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint2_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return fn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt2}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint2_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return fn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt2}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint2_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return fn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint2_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint2_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt2}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint2_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return fn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint2_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt2}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint2_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return fn.__wrap(_[0]);
  }
}
const ab = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint200_free(n >>> 0, 1));
class ln {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ln.prototype);
    return e.__wbg_ptr = t, ab.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ab.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint200_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt200}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint200_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ln.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt200}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint200_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ln.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt200}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint200_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ln.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint200_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint200_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt200}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint200_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ln.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint200_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt200}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint200_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ln.__wrap(_[0]);
  }
}
const cb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint2048_free(n >>> 0, 1));
class pn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(pn.prototype);
    return e.__wbg_ptr = t, cb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, cb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint2048_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt2048}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint2048_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return pn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt2048}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint2048_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return pn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt2048}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint2048_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return pn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint2048_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint2048_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt2048}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint2048_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return pn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint2048_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt2048}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint2048_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return pn.__wrap(_[0]);
  }
}
const ub = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint208_free(n >>> 0, 1));
class hn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(hn.prototype);
    return e.__wbg_ptr = t, ub.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ub.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint208_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt208}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint208_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return hn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt208}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint208_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return hn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt208}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint208_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return hn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint208_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint208_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt208}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint208_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return hn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint208_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt208}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint208_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return hn.__wrap(_[0]);
  }
}
const fb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint216_free(n >>> 0, 1));
class wn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(wn.prototype);
    return e.__wbg_ptr = t, fb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, fb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint216_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt216}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint216_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return wn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt216}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint216_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return wn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt216}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint216_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return wn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint216_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint216_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt216}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint216_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return wn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint216_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt216}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint216_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return wn.__wrap(_[0]);
  }
}
const lb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint224_free(n >>> 0, 1));
class dn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(dn.prototype);
    return e.__wbg_ptr = t, lb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, lb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint224_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt224}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint224_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return dn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt224}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint224_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return dn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt224}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint224_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return dn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint224_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint224_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt224}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint224_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return dn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint224_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt224}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint224_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return dn.__wrap(_[0]);
  }
}
const pb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint232_free(n >>> 0, 1));
class gn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(gn.prototype);
    return e.__wbg_ptr = t, pb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, pb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint232_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt232}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint232_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return gn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt232}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint232_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return gn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt232}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint232_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return gn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint232_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint232_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt232}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint232_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return gn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint232_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt232}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint232_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return gn.__wrap(_[0]);
  }
}
const hb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint24_free(n >>> 0, 1));
class bn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(bn.prototype);
    return e.__wbg_ptr = t, hb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, hb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint24_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt24}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint24_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return bn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt24}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint24_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return bn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt24}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint24_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return bn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint24_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint24_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt24}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint24_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return bn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint24_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt24}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint24_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return bn.__wrap(_[0]);
  }
}
const wb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint240_free(n >>> 0, 1));
class yn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(yn.prototype);
    return e.__wbg_ptr = t, wb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, wb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint240_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt240}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint240_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return yn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt240}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint240_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return yn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt240}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint240_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return yn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint240_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint240_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt240}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint240_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return yn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint240_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt240}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint240_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return yn.__wrap(_[0]);
  }
}
const db = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint248_free(n >>> 0, 1));
class An {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(An.prototype);
    return e.__wbg_ptr = t, db.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, db.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint248_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt248}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint248_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return An.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt248}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint248_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return An.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt248}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint248_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return An.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint248_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint248_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt248}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint248_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return An.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint248_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt248}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint248_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return An.__wrap(_[0]);
  }
}
const gb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint256_free(n >>> 0, 1));
class mn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(mn.prototype);
    return e.__wbg_ptr = t, gb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, gb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint256_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt256}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint256_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return mn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt256}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint256_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return mn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt256}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint256_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return mn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint256_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint256_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt256}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint256_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return mn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint256_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt256}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint256_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return mn.__wrap(_[0]);
  }
}
const bb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint32_free(n >>> 0, 1));
class Sn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Sn.prototype);
    return e.__wbg_ptr = t, bb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, bb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint32_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt32}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint32_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Sn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt32}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint32_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Sn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt32}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint32_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Sn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint32_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint32_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt32}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint32_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Sn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint32_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt32}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint32_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Sn.__wrap(_[0]);
  }
}
const yb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint4_free(n >>> 0, 1));
class Rn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Rn.prototype);
    return e.__wbg_ptr = t, yb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, yb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint4_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt4}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint4_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Rn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt4}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint4_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Rn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt4}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint4_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Rn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint4_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint4_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt4}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint4_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Rn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint4_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt4}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint4_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Rn.__wrap(_[0]);
  }
}
const Ab = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint40_free(n >>> 0, 1));
class En {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(En.prototype);
    return e.__wbg_ptr = t, Ab.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ab.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint40_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt40}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint40_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return En.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt40}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint40_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return En.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt40}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint40_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return En.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {bigint}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint40_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint40_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt40}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint40_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return En.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint40_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt40}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint40_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return En.__wrap(_[0]);
  }
}
const mb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint48_free(n >>> 0, 1));
class Pn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Pn.prototype);
    return e.__wbg_ptr = t, mb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, mb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint48_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt48}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint48_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Pn.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt48}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint48_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Pn.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt48}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint48_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Pn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {bigint}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint48_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint48_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt48}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint48_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Pn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint48_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt48}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint48_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Pn.__wrap(_[0]);
  }
}
const Sb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint512_free(n >>> 0, 1));
class zn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(zn.prototype);
    return e.__wbg_ptr = t, Sb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Sb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint512_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt512}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint512_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return zn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt512}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint512_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return zn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt512}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint512_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return zn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint512_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint512_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt512}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint512_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return zn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint512_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt512}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint512_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return zn.__wrap(_[0]);
  }
}
const Rb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint56_free(n >>> 0, 1));
class vn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(vn.prototype);
    return e.__wbg_ptr = t, Rb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Rb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint56_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt56}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint56_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return vn.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt56}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint56_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return vn.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt56}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint56_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return vn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {bigint}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint56_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint56_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt56}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint56_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return vn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint56_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt56}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint56_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return vn.__wrap(_[0]);
  }
}
const Eb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint6_free(n >>> 0, 1));
class Mn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Mn.prototype);
    return e.__wbg_ptr = t, Eb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Eb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint6_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt6}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint6_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Mn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt6}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint6_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Mn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt6}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint6_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Mn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint6_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint6_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt6}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint6_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Mn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint6_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt6}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint6_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Mn.__wrap(_[0]);
  }
}
const Pb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint64_free(n >>> 0, 1));
class xn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(xn.prototype);
    return e.__wbg_ptr = t, Pb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Pb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint64_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt64}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint64_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return xn.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt64}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint64_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return xn.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt64}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint64_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return xn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {bigint}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint64_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint64_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt64}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint64_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return xn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint64_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt64}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint64_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return xn.__wrap(_[0]);
  }
}
const zb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint72_free(n >>> 0, 1));
class Bn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Bn.prototype);
    return e.__wbg_ptr = t, zb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, zb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint72_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt72}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint72_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Bn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt72}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint72_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Bn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt72}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint72_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Bn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint72_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint72_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt72}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint72_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Bn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint72_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt72}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint72_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Bn.__wrap(_[0]);
  }
}
const vb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint8_free(n >>> 0, 1));
class Cn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Cn.prototype);
    return e.__wbg_ptr = t, vb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, vb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint8_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt8}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint8_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Cn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt8}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint8_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Cn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt8}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint8_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Cn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint8_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint8_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt8}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint8_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Cn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint8_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt8}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint8_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Cn.__wrap(_[0]);
  }
}
const Mb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint80_free(n >>> 0, 1));
class In {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(In.prototype);
    return e.__wbg_ptr = t, Mb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Mb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint80_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt80}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint80_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return In.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt80}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint80_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return In.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt80}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint80_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return In.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint80_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint80_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt80}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint80_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return In.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint80_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt80}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint80_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return In.__wrap(_[0]);
  }
}
const xb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint88_free(n >>> 0, 1));
class Nn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Nn.prototype);
    return e.__wbg_ptr = t, xb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, xb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint88_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt88}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint88_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Nn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt88}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint88_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Nn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt88}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint88_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Nn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint88_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint88_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt88}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint88_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Nn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint88_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt88}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint88_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Nn.__wrap(_[0]);
  }
}
const Bb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheint96_free(n >>> 0, 1));
class On {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(On.prototype);
    return e.__wbg_ptr = t, Bb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Bb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheint96_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt96}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheint96_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return On.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt96}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheint96_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return On.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt96}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheint96_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return On.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheint96_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheint96_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt96}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheint96_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return On.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheint96_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt96}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheint96_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return On.__wrap(_[0]);
  }
}
const Cb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint10_free(n >>> 0, 1));
class kn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(kn.prototype);
    return e.__wbg_ptr = t, Cb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Cb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint10_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint10}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint10_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return kn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint10}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint10_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return kn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint10}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint10_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return kn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint10_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint10_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint10}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint10_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return kn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint10_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint10}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint10_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return kn.__wrap(_[0]);
  }
}
const Ib = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint1024_free(n >>> 0, 1));
class Tn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Tn.prototype);
    return e.__wbg_ptr = t, Ib.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ib.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint1024_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint1024}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint1024_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Tn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint1024}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint1024_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Tn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint1024}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint1024_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Tn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint1024_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint1024_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint1024}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint1024_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Tn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint1024_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint1024}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint1024_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Tn.__wrap(_[0]);
  }
}
const Nb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint104_free(n >>> 0, 1));
class Gn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Gn.prototype);
    return e.__wbg_ptr = t, Nb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Nb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint104_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint104}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint104_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Gn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint104}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint104_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Gn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint104}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint104_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Gn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint104_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint104_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint104}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint104_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Gn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint104_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint104}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint104_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Gn.__wrap(_[0]);
  }
}
const Ob = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint112_free(n >>> 0, 1));
class Un {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Un.prototype);
    return e.__wbg_ptr = t, Ob.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ob.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint112_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint112}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint112_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Un.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint112}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint112_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Un.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint112}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint112_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Un.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint112_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint112_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint112}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint112_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Un.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint112_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint112}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint112_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Un.__wrap(_[0]);
  }
}
const kb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint12_free(n >>> 0, 1));
class Fn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Fn.prototype);
    return e.__wbg_ptr = t, kb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, kb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint12_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint12}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint12_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Fn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint12}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint12_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Fn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint12}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint12_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Fn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint12_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint12_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint12}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint12_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Fn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint12_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint12}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint12_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Fn.__wrap(_[0]);
  }
}
const Tb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint120_free(n >>> 0, 1));
class Kn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Kn.prototype);
    return e.__wbg_ptr = t, Tb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Tb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint120_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint120}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint120_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Kn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint120}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint120_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Kn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint120}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint120_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Kn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint120_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint120_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint120}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint120_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Kn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint120_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint120}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint120_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Kn.__wrap(_[0]);
  }
}
const Gb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint128_free(n >>> 0, 1));
class Dn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Dn.prototype);
    return e.__wbg_ptr = t, Gb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Gb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint128_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint128}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint128_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Dn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint128}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint128_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Dn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint128}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint128_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Dn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint128_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint128_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint128}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint128_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Dn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint128_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint128}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint128_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Dn.__wrap(_[0]);
  }
}
const Ub = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint136_free(n >>> 0, 1));
class Ln {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ln.prototype);
    return e.__wbg_ptr = t, Ub.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ub.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint136_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint136}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint136_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Ln.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint136}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint136_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Ln.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint136}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint136_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Ln.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint136_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint136_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint136}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint136_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Ln.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint136_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint136}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint136_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Ln.__wrap(_[0]);
  }
}
const Fb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint14_free(n >>> 0, 1));
class jn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(jn.prototype);
    return e.__wbg_ptr = t, Fb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Fb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint14_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint14}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint14_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return jn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint14}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint14_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return jn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint14}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint14_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return jn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint14_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint14_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint14}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint14_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return jn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint14_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint14}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint14_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return jn.__wrap(_[0]);
  }
}
const Kb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint144_free(n >>> 0, 1));
class Vn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Vn.prototype);
    return e.__wbg_ptr = t, Kb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Kb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint144_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint144}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint144_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Vn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint144}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint144_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Vn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint144}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint144_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Vn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint144_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint144_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint144}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint144_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Vn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint144_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint144}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint144_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Vn.__wrap(_[0]);
  }
}
const Db = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint152_free(n >>> 0, 1));
class Yn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Yn.prototype);
    return e.__wbg_ptr = t, Db.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Db.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint152_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint152}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint152_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Yn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint152}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint152_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Yn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint152}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint152_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Yn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint152_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint152_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint152}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint152_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Yn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint152_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint152}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint152_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Yn.__wrap(_[0]);
  }
}
const Lb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint16_free(n >>> 0, 1));
class Hn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Hn.prototype);
    return e.__wbg_ptr = t, Lb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Lb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint16_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint16}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint16_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Hn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint16}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint16_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Hn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint16}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint16_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Hn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint16_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint16_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint16}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint16_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Hn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint16_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint16}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint16_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Hn.__wrap(_[0]);
  }
}
const jb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint160_free(n >>> 0, 1));
class qn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(qn.prototype);
    return e.__wbg_ptr = t, jb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, jb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint160_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint160}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint160_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return qn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint160}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint160_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return qn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint160}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint160_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return qn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint160_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint160_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint160}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint160_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return qn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint160_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint160}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint160_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return qn.__wrap(_[0]);
  }
}
const Vb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint168_free(n >>> 0, 1));
class Qn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Qn.prototype);
    return e.__wbg_ptr = t, Vb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Vb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint168_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint168}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint168_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Qn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint168}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint168_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Qn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint168}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint168_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Qn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint168_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint168_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint168}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint168_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Qn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint168_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint168}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint168_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Qn.__wrap(_[0]);
  }
}
const Yb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint176_free(n >>> 0, 1));
class Wn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Wn.prototype);
    return e.__wbg_ptr = t, Yb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Yb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint176_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint176}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint176_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Wn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint176}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint176_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Wn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint176}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint176_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Wn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint176_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint176_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint176}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint176_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Wn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint176_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint176}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint176_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Wn.__wrap(_[0]);
  }
}
const Hb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint184_free(n >>> 0, 1));
class Jn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Jn.prototype);
    return e.__wbg_ptr = t, Hb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Hb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint184_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint184}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint184_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Jn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint184}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint184_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Jn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint184}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint184_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Jn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint184_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint184_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint184}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint184_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Jn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint184_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint184}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint184_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Jn.__wrap(_[0]);
  }
}
const qb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint192_free(n >>> 0, 1));
class $n {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create($n.prototype);
    return e.__wbg_ptr = t, qb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, qb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint192_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint192}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint192_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return $n.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint192}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint192_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return $n.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint192}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint192_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return $n.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint192_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint192_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint192}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint192_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return $n.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint192_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint192}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint192_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return $n.__wrap(_[0]);
  }
}
const Qb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint2_free(n >>> 0, 1));
class Zn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Zn.prototype);
    return e.__wbg_ptr = t, Qb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Qb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint2_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint2}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint2_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Zn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint2}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint2_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Zn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint2}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint2_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Zn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint2_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint2_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint2}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint2_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Zn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint2_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint2}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint2_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Zn.__wrap(_[0]);
  }
}
const Wb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint200_free(n >>> 0, 1));
class Xn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Xn.prototype);
    return e.__wbg_ptr = t, Wb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Wb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint200_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint200}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint200_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Xn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint200}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint200_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Xn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint200}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint200_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Xn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint200_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint200_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint200}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint200_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Xn.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint200_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint200}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint200_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Xn.__wrap(_[0]);
  }
}
const Jb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint2048_free(n >>> 0, 1));
class ti {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ti.prototype);
    return e.__wbg_ptr = t, Jb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Jb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint2048_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint2048}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint2048_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ti.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint2048}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint2048_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ti.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint2048}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint2048_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ti.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint2048_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint2048_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint2048}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint2048_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ti.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint2048_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint2048}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint2048_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ti.__wrap(_[0]);
  }
}
const $b = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint208_free(n >>> 0, 1));
class ei {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ei.prototype);
    return e.__wbg_ptr = t, $b.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, $b.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint208_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint208}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint208_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ei.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint208}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint208_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ei.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint208}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint208_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ei.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint208_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint208_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint208}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint208_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ei.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint208_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint208}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint208_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ei.__wrap(_[0]);
  }
}
const Zb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint216_free(n >>> 0, 1));
class ri {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ri.prototype);
    return e.__wbg_ptr = t, Zb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Zb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint216_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint216}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint216_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ri.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint216}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint216_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ri.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint216}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint216_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ri.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint216_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint216_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint216}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint216_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ri.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint216_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint216}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint216_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ri.__wrap(_[0]);
  }
}
const Xb = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint224_free(n >>> 0, 1));
class ni {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ni.prototype);
    return e.__wbg_ptr = t, Xb.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Xb.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint224_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint224}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint224_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ni.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint224}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint224_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ni.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint224}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint224_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ni.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint224_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint224_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint224}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint224_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ni.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint224_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint224}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint224_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ni.__wrap(_[0]);
  }
}
const ty = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint232_free(n >>> 0, 1));
class ii {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ii.prototype);
    return e.__wbg_ptr = t, ty.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ty.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint232_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint232}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint232_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ii.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint232}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint232_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ii.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint232}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint232_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ii.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint232_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint232_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint232}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint232_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ii.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint232_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint232}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint232_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ii.__wrap(_[0]);
  }
}
const ey = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint24_free(n >>> 0, 1));
class si {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(si.prototype);
    return e.__wbg_ptr = t, ey.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ey.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint24_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint24}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint24_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return si.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint24}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint24_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return si.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint24}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint24_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return si.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint24_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0] >>> 0;
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint24_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint24}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint24_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return si.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint24_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint24}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint24_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return si.__wrap(_[0]);
  }
}
const ry = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint240_free(n >>> 0, 1));
class _i {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(_i.prototype);
    return e.__wbg_ptr = t, ry.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ry.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint240_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint240}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint240_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return _i.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint240}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint240_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return _i.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint240}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint240_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return _i.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint240_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint240_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint240}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint240_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return _i.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint240_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint240}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint240_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return _i.__wrap(_[0]);
  }
}
const ny = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint248_free(n >>> 0, 1));
class oi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(oi.prototype);
    return e.__wbg_ptr = t, ny.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ny.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint248_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint248}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint248_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return oi.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint248}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint248_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return oi.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint248}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint248_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return oi.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint248_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint248_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint248}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint248_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return oi.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint248_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint248}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint248_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return oi.__wrap(_[0]);
  }
}
const iy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint256_free(n >>> 0, 1));
class ai {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ai.prototype);
    return e.__wbg_ptr = t, iy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, iy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint256_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint256}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint256_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ai.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint256}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint256_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ai.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint256}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint256_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ai.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint256_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint256_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint256}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint256_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ai.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint256_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint256}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint256_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ai.__wrap(_[0]);
  }
}
const sy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint32_free(n >>> 0, 1));
class ci {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ci.prototype);
    return e.__wbg_ptr = t, sy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, sy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint32_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint32}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint32_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ci.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint32}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint32_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ci.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint32}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint32_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ci.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint32_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0] >>> 0;
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint32_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint32}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint32_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ci.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint32_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint32}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint32_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ci.__wrap(_[0]);
  }
}
const _y = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint4_free(n >>> 0, 1));
class ui {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ui.prototype);
    return e.__wbg_ptr = t, _y.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, _y.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint4_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint4}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint4_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ui.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint4}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint4_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ui.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint4}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint4_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return ui.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint4_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint4_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint4}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint4_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ui.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint4_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint4}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint4_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ui.__wrap(_[0]);
  }
}
const oy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint40_free(n >>> 0, 1));
class fi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(fi.prototype);
    return e.__wbg_ptr = t, oy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, oy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint40_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint40}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint40_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return fi.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint40}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint40_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return fi.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint40}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint40_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return fi.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {bigint}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint40_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return BigInt.asUintN(64, e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint40_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint40}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint40_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return fi.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint40_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint40}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint40_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return fi.__wrap(_[0]);
  }
}
const ay = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint48_free(n >>> 0, 1));
class li {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(li.prototype);
    return e.__wbg_ptr = t, ay.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ay.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint48_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint48}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint48_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return li.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint48}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint48_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return li.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint48}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint48_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return li.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {bigint}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint48_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return BigInt.asUintN(64, e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint48_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint48}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint48_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return li.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint48_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint48}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint48_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return li.__wrap(_[0]);
  }
}
const cy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint512_free(n >>> 0, 1));
class pi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(pi.prototype);
    return e.__wbg_ptr = t, cy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, cy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint512_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint512}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint512_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return pi.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint512}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint512_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return pi.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint512}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint512_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return pi.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint512_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint512_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint512}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint512_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return pi.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint512_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint512}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint512_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return pi.__wrap(_[0]);
  }
}
const uy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint56_free(n >>> 0, 1));
class hi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(hi.prototype);
    return e.__wbg_ptr = t, uy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, uy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint56_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint56}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint56_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return hi.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint56}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint56_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return hi.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint56}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint56_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return hi.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {bigint}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint56_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return BigInt.asUintN(64, e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint56_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint56}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint56_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return hi.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint56_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint56}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint56_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return hi.__wrap(_[0]);
  }
}
const fy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint6_free(n >>> 0, 1));
class wi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(wi.prototype);
    return e.__wbg_ptr = t, fy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, fy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint6_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint6}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint6_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return wi.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint6}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint6_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return wi.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint6}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint6_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return wi.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint6_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint6_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint6}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint6_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return wi.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint6_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint6}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint6_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return wi.__wrap(_[0]);
  }
}
const ly = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint64_free(n >>> 0, 1));
class di {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(di.prototype);
    return e.__wbg_ptr = t, ly.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ly.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint64_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint64}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint64_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return di.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint64}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint64_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return di.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint64}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint64_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return di.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {bigint}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint64_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return BigInt.asUintN(64, e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint64_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint64}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint64_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return di.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint64_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint64}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint64_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return di.__wrap(_[0]);
  }
}
const py = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint72_free(n >>> 0, 1));
class gi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(gi.prototype);
    return e.__wbg_ptr = t, py.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, py.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint72_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint72}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint72_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return gi.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint72}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint72_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return gi.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint72}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint72_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return gi.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint72_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint72_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint72}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint72_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return gi.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint72_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint72}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint72_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return gi.__wrap(_[0]);
  }
}
const hy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint8_free(n >>> 0, 1));
class bi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(bi.prototype);
    return e.__wbg_ptr = t, hy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, hy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint8_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint8}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint8_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return bi.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint8}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint8_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return bi.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint8}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint8_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return bi.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint8_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint8_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint8}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint8_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return bi.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint8_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint8}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint8_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return bi.__wrap(_[0]);
  }
}
const wy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint80_free(n >>> 0, 1));
class yi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(yi.prototype);
    return e.__wbg_ptr = t, wy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, wy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint80_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint80}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint80_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return yi.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint80}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint80_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return yi.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint80}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint80_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return yi.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint80_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint80_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint80}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint80_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return yi.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint80_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint80}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint80_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return yi.__wrap(_[0]);
  }
}
const dy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint88_free(n >>> 0, 1));
class Ai {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ai.prototype);
    return e.__wbg_ptr = t, dy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, dy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint88_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint88}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint88_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Ai.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint88}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint88_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Ai.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint88}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint88_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return Ai.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint88_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint88_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint88}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint88_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Ai.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint88_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint88}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint88_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Ai.__wrap(_[0]);
  }
}
const gy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_fheuint96_free(n >>> 0, 1));
class mi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(mi.prototype);
    return e.__wbg_ptr = t, gy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, gy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_fheuint96_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint96}
   */
  static encrypt_with_client_key(t, e) {
    b(e, F);
    const r = i.fheuint96_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return mi.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint96}
   */
  static encrypt_with_public_key(t, e) {
    b(e, bt);
    const r = i.fheuint96_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return mi.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint96}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(e, yt);
    const r = i.fheuint96_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw o(r[1]);
    return mi.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    b(t, F);
    const e = i.fheuint96_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return o(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.fheuint96_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint96}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.fheuint96_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return mi.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.fheuint96_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint96}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.fheuint96_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return mi.__wrap(_[0]);
  }
}
const by = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_provencompactciphertextlist_free(n >>> 0, 1));
class Ca {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ca.prototype);
    return e.__wbg_ptr = t, by.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, by.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_provencompactciphertextlist_free(t, 0);
  }
  /**
   * @param {TfheCompactPublicKey} public_key
   * @returns {CompactCiphertextListBuilder}
   */
  static builder(t) {
    b(t, Xe);
    const e = i.provencompactciphertextlist_builder(t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return Ou.__wrap(e[0]);
  }
  /**
   * @returns {number}
   */
  len() {
    return i.compactciphertextlistexpander_len(this.__wbg_ptr) >>> 0;
  }
  /**
   * @returns {boolean}
   */
  is_empty() {
    return i.compactciphertextlistexpander_is_empty(this.__wbg_ptr) !== 0;
  }
  /**
   * @param {number} index
   * @returns {FheTypes | undefined}
   */
  get_kind_of(t) {
    const e = i.provencompactciphertextlist_get_kind_of(this.__wbg_ptr, t);
    return e === 84 ? void 0 : e;
  }
  /**
   * @param {CompactPkeCrs} crs
   * @param {TfheCompactPublicKey} public_key
   * @param {Uint8Array} metadata
   * @returns {CompactCiphertextListExpander}
   */
  verify_and_expand(t, e, r) {
    b(t, pr), b(e, Xe);
    const s = S(r, i.__wbindgen_malloc), _ = m, a = i.provencompactciphertextlist_verify_and_expand(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, s, _);
    if (a[2])
      throw o(a[1]);
    return Cc.__wrap(a[0]);
  }
  /**
   * @returns {CompactCiphertextListExpander}
   */
  expand_without_verification() {
    const t = i.provencompactciphertextlist_expand_without_verification(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Cc.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.provencompactciphertextlist_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {ProvenCompactCiphertextList}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.provencompactciphertextlist_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Ca.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.provencompactciphertextlist_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {ProvenCompactCiphertextList}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.provencompactciphertextlist_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Ca.__wrap(_[0]);
  }
}
const xv = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_shortint_free(n >>> 0, 1));
class Bv {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, xv.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_shortint_free(t, 0);
  }
  /**
   * @param {number} std_dev
   * @returns {ShortintNoiseDistribution}
   */
  static new_gaussian_from_std_dev(t) {
    const e = i.shortint_new_gaussian_from_std_dev(t);
    return wr.__wrap(e);
  }
  /**
   * @param {number} bound_log2
   * @returns {ShortintNoiseDistribution}
   */
  static try_new_t_uniform(t) {
    const e = i.shortint_try_new_t_uniform(t);
    if (e[2])
      throw o(e[1]);
    return wr.__wrap(e[0]);
  }
  /**
   * @param {number} lwe_dimension
   * @param {number} glwe_dimension
   * @param {number} polynomial_size
   * @param {ShortintNoiseDistribution} lwe_noise_distribution
   * @param {ShortintNoiseDistribution} glwe_noise_distribution
   * @param {number} pbs_base_log
   * @param {number} pbs_level
   * @param {number} ks_base_log
   * @param {number} ks_level
   * @param {bigint} message_modulus
   * @param {bigint} carry_modulus
   * @param {bigint} max_noise_level
   * @param {number} log2_p_fail
   * @param {number} modulus_power_of_2_exponent
   * @param {ShortintEncryptionKeyChoice} encryption_key_choice
   * @returns {ShortintParameters}
   */
  static new_parameters(t, e, r, s, _, a, c, u, l, f, w, y, v, x, C) {
    b(s, wr), b(_, wr);
    const U = i.shortint_new_parameters(t, e, r, s.__wbg_ptr, _.__wbg_ptr, a, c, u, l, f, w, y, v, x, C);
    return Ps.__wrap(U);
  }
  /**
   * @param {bigint} seed_high_bytes
   * @param {bigint} seed_low_bytes
   * @param {ShortintParameters} parameters
   * @returns {ShortintClientKey}
   */
  static new_client_key_from_seed_and_parameters(t, e, r) {
    b(r, Ps);
    const s = i.shortint_new_client_key_from_seed_and_parameters(t, e, r.__wbg_ptr);
    return Qe.__wrap(s);
  }
  /**
   * @param {ShortintParameters} parameters
   * @returns {ShortintClientKey}
   */
  static new_client_key(t) {
    b(t, Ps);
    const e = i.shortint_new_client_key(t.__wbg_ptr);
    return Qe.__wrap(e);
  }
  /**
   * @param {ShortintClientKey} client_key
   * @returns {ShortintPublicKey}
   */
  static new_public_key(t) {
    b(t, Qe);
    const e = i.shortint_new_public_key(t.__wbg_ptr);
    return Zs.__wrap(e);
  }
  /**
   * @param {ShortintClientKey} client_key
   * @returns {ShortintCompressedPublicKey}
   */
  static new_compressed_public_key(t) {
    b(t, Qe);
    const e = i.shortint_new_compressed_public_key(t.__wbg_ptr);
    return $s.__wrap(e);
  }
  /**
   * @param {ShortintClientKey} client_key
   * @returns {ShortintCompressedServerKey}
   */
  static new_compressed_server_key(t) {
    b(t, Qe);
    const e = i.shortint_new_compressed_server_key(t.__wbg_ptr);
    return Ia.__wrap(e);
  }
  /**
   * @param {ShortintClientKey} client_key
   * @param {bigint} message
   * @returns {ShortintCiphertext}
   */
  static encrypt(t, e) {
    b(t, Qe);
    const r = i.shortint_encrypt(t.__wbg_ptr, e);
    return Gr.__wrap(r);
  }
  /**
   * @param {ShortintClientKey} client_key
   * @param {bigint} message
   * @returns {ShortintCompressedCiphertext}
   */
  static encrypt_compressed(t, e) {
    b(t, Qe);
    const r = i.shortint_encrypt_compressed(t.__wbg_ptr, e);
    return Js.__wrap(r);
  }
  /**
   * @param {ShortintCompressedCiphertext} compressed_ciphertext
   * @returns {ShortintCiphertext}
   */
  static decompress_ciphertext(t) {
    b(t, Js);
    const e = i.shortint_decompress_ciphertext(t.__wbg_ptr);
    return Gr.__wrap(e);
  }
  /**
   * @param {ShortintPublicKey} public_key
   * @param {bigint} message
   * @returns {ShortintCiphertext}
   */
  static encrypt_with_public_key(t, e) {
    b(t, Zs);
    const r = i.shortint_encrypt_with_public_key(t.__wbg_ptr, e);
    return Gr.__wrap(r);
  }
  /**
   * @param {ShortintCompressedPublicKey} public_key
   * @param {bigint} message
   * @returns {ShortintCiphertext}
   */
  static encrypt_with_compressed_public_key(t, e) {
    b(t, $s);
    const r = i.shortint_encrypt_with_compressed_public_key(t.__wbg_ptr, e);
    return Gr.__wrap(r);
  }
  /**
   * @param {ShortintClientKey} client_key
   * @param {ShortintCiphertext} ct
   * @returns {bigint}
   */
  static decrypt(t, e) {
    b(t, Qe), b(e, Gr);
    const r = i.shortint_decrypt(t.__wbg_ptr, e.__wbg_ptr);
    return BigInt.asUintN(64, r);
  }
  /**
   * @param {ShortintCiphertext} ciphertext
   * @returns {Uint8Array}
   */
  static serialize_ciphertext(t) {
    b(t, Gr);
    const e = i.shortint_serialize_ciphertext(t.__wbg_ptr);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {ShortintCiphertext}
   */
  static deserialize_ciphertext(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.shortint_deserialize_ciphertext(e, r);
    if (s[2])
      throw o(s[1]);
    return Gr.__wrap(s[0]);
  }
  /**
   * @param {ShortintCompressedCiphertext} ciphertext
   * @returns {Uint8Array}
   */
  static serialize_compressed_ciphertext(t) {
    b(t, Js);
    const e = i.shortint_serialize_compressed_ciphertext(t.__wbg_ptr);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {ShortintCompressedCiphertext}
   */
  static deserialize_compressed_ciphertext(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.shortint_deserialize_compressed_ciphertext(e, r);
    if (s[2])
      throw o(s[1]);
    return Js.__wrap(s[0]);
  }
  /**
   * @param {ShortintClientKey} client_key
   * @returns {Uint8Array}
   */
  static serialize_client_key(t) {
    b(t, Qe);
    const e = i.shortint_serialize_client_key(t.__wbg_ptr);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {ShortintClientKey}
   */
  static deserialize_client_key(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.shortint_deserialize_client_key(e, r);
    if (s[2])
      throw o(s[1]);
    return Qe.__wrap(s[0]);
  }
  /**
   * @param {ShortintPublicKey} public_key
   * @returns {Uint8Array}
   */
  static serialize_public_key(t) {
    b(t, Zs);
    const e = i.shortint_serialize_public_key(t.__wbg_ptr);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {ShortintPublicKey}
   */
  static deserialize_public_key(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.shortint_deserialize_public_key(e, r);
    if (s[2])
      throw o(s[1]);
    return Zs.__wrap(s[0]);
  }
  /**
   * @param {ShortintCompressedPublicKey} public_key
   * @returns {Uint8Array}
   */
  static serialize_compressed_public_key(t) {
    b(t, $s);
    const e = i.shortint_serialize_compressed_public_key(t.__wbg_ptr);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {ShortintCompressedPublicKey}
   */
  static deserialize_compressed_public_key(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.shortint_deserialize_compressed_public_key(e, r);
    if (s[2])
      throw o(s[1]);
    return $s.__wrap(s[0]);
  }
  /**
   * @param {ShortintCompressedServerKey} server_key
   * @returns {Uint8Array}
   */
  static serialize_compressed_server_key(t) {
    b(t, Ia);
    const e = i.shortint_serialize_compressed_server_key(t.__wbg_ptr);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {ShortintCompressedServerKey}
   */
  static deserialize_compressed_server_key(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.shortint_deserialize_compressed_server_key(e, r);
    if (s[2])
      throw o(s[1]);
    return Ia.__wrap(s[0]);
  }
}
const yy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_shortintciphertext_free(n >>> 0, 1));
class Gr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Gr.prototype);
    return e.__wbg_ptr = t, yy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, yy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_shortintciphertext_free(t, 0);
  }
}
const Ay = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_shortintclientkey_free(n >>> 0, 1));
class Qe {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Qe.prototype);
    return e.__wbg_ptr = t, Ay.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ay.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_shortintclientkey_free(t, 0);
  }
}
const Zp = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_shortintcompactpublickeyencryptionparameters_free(n >>> 0, 1));
class M_ {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(M_.prototype);
    return e.__wbg_ptr = t, Zp.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Zp.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_shortintcompactpublickeyencryptionparameters_free(t, 0);
  }
  /**
   * @param {ShortintCompactPublicKeyEncryptionParametersName} name
   */
  constructor(t) {
    const e = i.shortintcompactpublickeyencryptionparameters_new(t);
    return this.__wbg_ptr = e >>> 0, Zp.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * @param {number} encryption_lwe_dimension
   * @param {ShortintNoiseDistribution} encryption_noise_distribution
   * @param {bigint} message_modulus
   * @param {bigint} carry_modulus
   * @param {number} modulus_power_of_2_exponent
   * @param {number} ks_base_log
   * @param {number} ks_level
   * @param {ShortintEncryptionKeyChoice} encryption_key_choice
   * @returns {ShortintCompactPublicKeyEncryptionParameters}
   */
  static new_parameters(t, e, r, s, _, a, c, u) {
    b(e, wr);
    const l = i.shortintcompactpublickeyencryptionparameters_new_parameters(t, e.__wbg_ptr, r, s, _, a, c, u);
    if (l[2])
      throw o(l[1]);
    return M_.__wrap(l[0]);
  }
}
const my = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_shortintcompressedciphertext_free(n >>> 0, 1));
class Js {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Js.prototype);
    return e.__wbg_ptr = t, my.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, my.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_shortintcompressedciphertext_free(t, 0);
  }
}
const Sy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_shortintcompressedpublickey_free(n >>> 0, 1));
class $s {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create($s.prototype);
    return e.__wbg_ptr = t, Sy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Sy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_shortintcompressedpublickey_free(t, 0);
  }
}
const Ry = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_shortintcompressedserverkey_free(n >>> 0, 1));
class Ia {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ia.prototype);
    return e.__wbg_ptr = t, Ry.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ry.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_shortintcompressedserverkey_free(t, 0);
  }
}
const Ey = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_shortintnoisedistribution_free(n >>> 0, 1));
class wr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(wr.prototype);
    return e.__wbg_ptr = t, Ey.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ey.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_shortintnoisedistribution_free(t, 0);
  }
}
const Xp = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_shortintparameters_free(n >>> 0, 1));
class Ps {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ps.prototype);
    return e.__wbg_ptr = t, Xp.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Xp.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_shortintparameters_free(t, 0);
  }
  /**
   * @returns {number}
   */
  lwe_dimension() {
    return i.shortintparameters_lwe_dimension(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} new_value
   */
  set_lwe_dimension(t) {
    i.shortintparameters_set_lwe_dimension(this.__wbg_ptr, t);
  }
  /**
   * @returns {number}
   */
  glwe_dimension() {
    return i.shortintparameters_glwe_dimension(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} new_value
   */
  set_glwe_dimension(t) {
    i.shortintparameters_set_glwe_dimension(this.__wbg_ptr, t);
  }
  /**
   * @returns {number}
   */
  polynomial_size() {
    return i.shortintparameters_polynomial_size(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} new_value
   */
  set_polynomial_size(t) {
    i.shortintparameters_set_polynomial_size(this.__wbg_ptr, t);
  }
  /**
   * @returns {ShortintNoiseDistribution}
   */
  lwe_noise_distribution() {
    const t = i.shortintparameters_glwe_noise_distribution(this.__wbg_ptr);
    return wr.__wrap(t);
  }
  /**
   * @param {ShortintNoiseDistribution} new_value
   */
  set_lwe_noise_distribution(t) {
    b(t, wr), i.shortintparameters_set_lwe_noise_distribution(this.__wbg_ptr, t.__wbg_ptr);
  }
  /**
   * @returns {ShortintNoiseDistribution}
   */
  glwe_noise_distribution() {
    const t = i.shortintparameters_glwe_noise_distribution(this.__wbg_ptr);
    return wr.__wrap(t);
  }
  /**
   * @param {ShortintNoiseDistribution} new_value
   */
  set_glwe_noise_distribution(t) {
    b(t, wr), i.shortintparameters_set_glwe_noise_distribution(this.__wbg_ptr, t.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  pbs_base_log() {
    return i.shortintparameters_pbs_base_log(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} new_value
   */
  set_pbs_base_log(t) {
    i.shortintparameters_set_pbs_base_log(this.__wbg_ptr, t);
  }
  /**
   * @returns {number}
   */
  pbs_level() {
    return i.shortintparameters_pbs_level(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} new_value
   */
  set_pbs_level(t) {
    i.shortintparameters_set_pbs_level(this.__wbg_ptr, t);
  }
  /**
   * @returns {number}
   */
  ks_base_log() {
    return i.shortintparameters_ks_base_log(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} new_value
   */
  set_ks_base_log(t) {
    i.shortintparameters_set_ks_base_log(this.__wbg_ptr, t);
  }
  /**
   * @returns {number}
   */
  ks_level() {
    return i.shortintparameters_ks_level(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} new_value
   */
  set_ks_level(t) {
    i.shortintparameters_set_ks_level(this.__wbg_ptr, t);
  }
  /**
   * @returns {bigint}
   */
  message_modulus() {
    const t = i.shortintparameters_message_modulus(this.__wbg_ptr);
    return BigInt.asUintN(64, t);
  }
  /**
   * @param {bigint} new_value
   */
  set_message_modulus(t) {
    i.shortintparameters_set_message_modulus(this.__wbg_ptr, t);
  }
  /**
   * @returns {bigint}
   */
  carry_modulus() {
    const t = i.shortintparameters_carry_modulus(this.__wbg_ptr);
    return BigInt.asUintN(64, t);
  }
  /**
   * @param {bigint} new_value
   */
  set_carry_modulus(t) {
    i.shortintparameters_set_carry_modulus(this.__wbg_ptr, t);
  }
  /**
   * @returns {ShortintEncryptionKeyChoice}
   */
  encryption_key_choice() {
    return i.shortintparameters_encryption_key_choice(this.__wbg_ptr);
  }
  /**
   * @param {ShortintEncryptionKeyChoice} new_value
   */
  set_encryption_key_choice(t) {
    i.shortintparameters_set_encryption_key_choice(this.__wbg_ptr, t);
  }
  /**
   * @param {ShortintParametersName} name
   */
  constructor(t) {
    const e = i.shortintparameters_new(t);
    return this.__wbg_ptr = e >>> 0, Xp.register(this, this.__wbg_ptr, this), this;
  }
}
const Py = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_shortintpublickey_free(n >>> 0, 1));
class Zs {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Zs.prototype);
    return e.__wbg_ptr = t, Py.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Py.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_shortintpublickey_free(t, 0);
  }
}
const zy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_tfheclientkey_free(n >>> 0, 1));
class F {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(F.prototype);
    return e.__wbg_ptr = t, zy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, zy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_tfheclientkey_free(t, 0);
  }
  /**
   * @param {TfheConfig} config
   * @returns {TfheClientKey}
   */
  static generate(t) {
    b(t, x_);
    const e = i.tfheclientkey_generate(t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return F.__wrap(e[0]);
  }
  /**
   * @param {TfheConfig} config
   * @param {any} seed
   * @returns {TfheClientKey}
   */
  static generate_with_seed(t, e) {
    b(t, x_);
    const r = i.tfheclientkey_generate_with_seed(t.__wbg_ptr, e);
    if (r[2])
      throw o(r[1]);
    return F.__wrap(r[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.tfheclientkey_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {TfheClientKey}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.tfheclientkey_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return F.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.tfheclientkey_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {TfheClientKey}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.tfheclientkey_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return F.__wrap(_[0]);
  }
}
const vy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_tfhecompactpublickey_free(n >>> 0, 1));
class Xe {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Xe.prototype);
    return e.__wbg_ptr = t, vy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, vy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_tfhecompactpublickey_free(t, 0);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {TfheCompactPublicKey}
   */
  static new(t) {
    b(t, F);
    const e = i.tfhecompactpublickey_new(t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return Xe.__wrap(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.tfhecompactpublickey_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {TfheCompactPublicKey}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.tfhecompactpublickey_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Xe.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.tfhecompactpublickey_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {TfheCompactPublicKey}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.tfhecompactpublickey_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Xe.__wrap(_[0]);
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @param {ShortintCompactPublicKeyEncryptionParameters} conformance_params
   * @returns {TfheCompactPublicKey}
   */
  static safe_deserialize_conformant(t, e, r) {
    const s = S(t, i.__wbindgen_malloc), _ = m;
    b(r, M_);
    const a = i.tfhecompactpublickey_safe_deserialize_conformant(s, _, e, r.__wbg_ptr);
    if (a[2])
      throw o(a[1]);
    return Xe.__wrap(a[0]);
  }
}
const My = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_tfhecompressedcompactpublickey_free(n >>> 0, 1));
class Us {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Us.prototype);
    return e.__wbg_ptr = t, My.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, My.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_tfhecompressedcompactpublickey_free(t, 0);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {TfheCompressedCompactPublicKey}
   */
  static new(t) {
    b(t, F);
    const e = i.tfhecompressedcompactpublickey_new(t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return Us.__wrap(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.tfhecompressedcompactpublickey_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {TfheCompressedCompactPublicKey}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.tfhecompressedcompactpublickey_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return Us.__wrap(s[0]);
  }
  /**
   * @returns {TfheCompactPublicKey}
   */
  decompress() {
    const t = i.tfhecompressedcompactpublickey_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return Xe.__wrap(t[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.tfhecompressedcompactpublickey_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {TfheCompressedCompactPublicKey}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.tfhecompressedcompactpublickey_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return Us.__wrap(_[0]);
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @param {ShortintCompactPublicKeyEncryptionParameters} conformance_params
   * @returns {TfheCompressedCompactPublicKey}
   */
  static safe_deserialize_conformant(t, e, r) {
    const s = S(t, i.__wbindgen_malloc), _ = m;
    b(r, M_);
    const a = i.tfhecompressedcompactpublickey_safe_deserialize_conformant(s, _, e, r.__wbg_ptr);
    if (a[2])
      throw o(a[1]);
    return Us.__wrap(a[0]);
  }
}
const xy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_tfhecompressedpublickey_free(n >>> 0, 1));
class yt {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(yt.prototype);
    return e.__wbg_ptr = t, xy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, xy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_tfhecompressedpublickey_free(t, 0);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {TfheCompressedPublicKey}
   */
  static new(t) {
    b(t, F);
    const e = i.tfhecompressedpublickey_new(t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return yt.__wrap(e[0]);
  }
  /**
   * @returns {TfhePublicKey}
   */
  decompress() {
    const t = i.tfhecompressedpublickey_decompress(this.__wbg_ptr);
    if (t[2])
      throw o(t[1]);
    return bt.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.tfhecompressedpublickey_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {TfheCompressedPublicKey}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.tfhecompressedpublickey_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return yt.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.tfhecompressedpublickey_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {TfheCompressedPublicKey}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.tfhecompressedpublickey_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return yt.__wrap(_[0]);
  }
}
const By = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_tfhecompressedserverkey_free(n >>> 0, 1));
class ya {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ya.prototype);
    return e.__wbg_ptr = t, By.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, By.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_tfhecompressedserverkey_free(t, 0);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {TfheCompressedServerKey}
   */
  static new(t) {
    b(t, F);
    const e = i.tfhecompressedserverkey_new(t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return ya.__wrap(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.tfhecompressedserverkey_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {TfheCompressedServerKey}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.tfhecompressedserverkey_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return ya.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.tfhecompressedserverkey_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {TfheCompressedServerKey}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.tfhecompressedserverkey_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return ya.__wrap(_[0]);
  }
}
const Cy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_tfheconfig_free(n >>> 0, 1));
class x_ {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(x_.prototype);
    return e.__wbg_ptr = t, Cy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Cy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_tfheconfig_free(t, 0);
  }
}
const Iy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_tfheconfigbuilder_free(n >>> 0, 1));
class Fs {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Fs.prototype);
    return e.__wbg_ptr = t, Iy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Iy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_tfheconfigbuilder_free(t, 0);
  }
  /**
   * @returns {TfheConfigBuilder}
   */
  static default() {
    const t = i.tfheconfigbuilder_default();
    return Fs.__wrap(t);
  }
  /**
   * @param {ShortintParameters} block_parameters
   * @returns {TfheConfigBuilder}
   */
  static with_custom_parameters(t) {
    b(t, Ps);
    const e = i.tfheconfigbuilder_with_custom_parameters(t.__wbg_ptr);
    return Fs.__wrap(e);
  }
  /**
   * @param {ShortintParameters} block_parameters
   * @returns {TfheConfigBuilder}
   */
  use_custom_parameters(t) {
    const e = this.__destroy_into_raw();
    b(t, Ps);
    const r = i.tfheconfigbuilder_use_custom_parameters(e, t.__wbg_ptr);
    return Fs.__wrap(r);
  }
  /**
   * @param {ShortintCompactPublicKeyEncryptionParameters} compact_public_key_parameters
   * @returns {TfheConfigBuilder}
   */
  use_dedicated_compact_public_key_parameters(t) {
    const e = this.__destroy_into_raw();
    b(t, M_);
    const r = i.tfheconfigbuilder_use_dedicated_compact_public_key_parameters(e, t.__wbg_ptr);
    return Fs.__wrap(r);
  }
  /**
   * @returns {TfheConfig}
   */
  build() {
    const t = this.__destroy_into_raw(), e = i.tfheconfigbuilder_build(t);
    return x_.__wrap(e);
  }
}
const Ny = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_tfhepublickey_free(n >>> 0, 1));
class bt {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(bt.prototype);
    return e.__wbg_ptr = t, Ny.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ny.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_tfhepublickey_free(t, 0);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {TfhePublicKey}
   */
  static new(t) {
    b(t, F);
    const e = i.tfhepublickey_new(t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return bt.__wrap(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = i.tfhepublickey_serialize(this.__wbg_ptr);
    if (t[3])
      throw o(t[2]);
    var e = R(t[0], t[1]).slice();
    return i.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {TfhePublicKey}
   */
  static deserialize(t) {
    const e = S(t, i.__wbindgen_malloc), r = m, s = i.tfhepublickey_deserialize(e, r);
    if (s[2])
      throw o(s[1]);
    return bt.__wrap(s[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = i.tfhepublickey_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw o(e[2]);
    var r = R(e[0], e[1]).slice();
    return i.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {TfhePublicKey}
   */
  static safe_deserialize(t, e) {
    const r = S(t, i.__wbindgen_malloc), s = m, _ = i.tfhepublickey_safe_deserialize(r, s, e);
    if (_[2])
      throw o(_[1]);
    return bt.__wrap(_[0]);
  }
}
const Oy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_tfheserverkey_free(n >>> 0, 1));
class lu {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(lu.prototype);
    return e.__wbg_ptr = t, Oy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Oy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_tfheserverkey_free(t, 0);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {TfheServerKey}
   */
  static new(t) {
    b(t, F);
    const e = i.tfheserverkey_new(t.__wbg_ptr);
    if (e[2])
      throw o(e[1]);
    return lu.__wrap(e[0]);
  }
}
const Cv = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_tfhe_free(n >>> 0, 1));
class Iv {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Cv.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_tfhe_free(t, 0);
  }
}
const ky = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => i.__wbg_wbg_rayon_poolbuilder_free(n >>> 0, 1));
class Wf {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Wf.prototype);
    return e.__wbg_ptr = t, ky.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ky.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    i.__wbg_wbg_rayon_poolbuilder_free(t, 0);
  }
  /**
   * @returns {number}
   */
  numThreads() {
    return i.wbg_rayon_poolbuilder_numThreads(this.__wbg_ptr) >>> 0;
  }
  /**
   * @returns {number}
   */
  receiver() {
    return i.wbg_rayon_poolbuilder_receiver(this.__wbg_ptr) >>> 0;
  }
  build() {
    i.wbg_rayon_poolbuilder_build(this.__wbg_ptr);
  }
}
async function Nv(n, t) {
  if (typeof Response == "function" && n instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(n, t);
      } catch (r) {
        if (n.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", r);
        else
          throw r;
      }
    const e = await n.arrayBuffer();
    return await WebAssembly.instantiate(e, t);
  } else {
    const e = await WebAssembly.instantiate(n, t);
    return e instanceof WebAssembly.Instance ? { instance: e, module: n } : e;
  }
}
function bm() {
  const n = {};
  return n.wbg = {}, n.wbg.__wbg_BigInt_470dd987b8190f8e = function(t) {
    return BigInt(t);
  }, n.wbg.__wbg_BigInt_ddea6d2f55558acb = function() {
    return G_(function(t) {
      return BigInt(t);
    }, arguments);
  }, n.wbg.__wbg_buffer_609cc3eee51ed158 = function(t) {
    return t.buffer;
  }, n.wbg.__wbg_call_672a4d21634d4a24 = function() {
    return G_(function(t, e) {
      return t.call(e);
    }, arguments);
  }, n.wbg.__wbg_call_7cccdd69e0791ae2 = function() {
    return G_(function(t, e, r) {
      return t.call(e, r);
    }, arguments);
  }, n.wbg.__wbg_crypto_ed58b8e10a292839 = function(t) {
    return t.crypto;
  }, n.wbg.__wbg_error_7534b8e9a36f1ab4 = function(t, e) {
    let r, s;
    try {
      r = t, s = e, console.error(Gs(t, e));
    } finally {
      i.__wbindgen_free(r, s, 1);
    }
  }, n.wbg.__wbg_getRandomValues_bcb4912f16000dc4 = function() {
    return G_(function(t, e) {
      t.getRandomValues(e);
    }, arguments);
  }, n.wbg.__wbg_getTime_46267b1c24877e30 = function(t) {
    return t.getTime();
  }, n.wbg.__wbg_instanceof_Window_def73ea0955fc569 = function(t) {
    let e;
    try {
      e = t instanceof Window;
    } catch {
      e = !1;
    }
    return e;
  }, n.wbg.__wbg_msCrypto_0a36e2ec3a343d26 = function(t) {
    return t.msCrypto;
  }, n.wbg.__wbg_new0_f788a2397c7ca929 = function() {
    return /* @__PURE__ */ new Date();
  }, n.wbg.__wbg_new_8a6f238a6ece86ea = function() {
    return new Error();
  }, n.wbg.__wbg_new_a12002a7f91c75be = function(t) {
    return new Uint8Array(t);
  }, n.wbg.__wbg_newnoargs_105ed471475aaf50 = function(t, e) {
    return new Function(Gs(t, e));
  }, n.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(t, e, r) {
    return new Uint8Array(t, e >>> 0, r >>> 0);
  }, n.wbg.__wbg_newwithlength_a381634e90c276d4 = function(t) {
    return new Uint8Array(t >>> 0);
  }, n.wbg.__wbg_node_02999533c4ea02e3 = function(t) {
    return t.node;
  }, n.wbg.__wbg_process_5c1d670bc53614b8 = function(t) {
    return t.process;
  }, n.wbg.__wbg_randomFillSync_ab2cfe79ebbf2740 = function() {
    return G_(function(t, e) {
      t.randomFillSync(e);
    }, arguments);
  }, n.wbg.__wbg_require_79b1e9274cde3c87 = function() {
    return G_(function() {
      return module.require;
    }, arguments);
  }, n.wbg.__wbg_set_65595bdd868b3009 = function(t, e, r) {
    t.set(e, r >>> 0);
  }, n.wbg.__wbg_stack_0ed75d68575b0f3c = function(t, e) {
    const r = e.stack, s = Qu(r, i.__wbindgen_malloc, i.__wbindgen_realloc), _ = m;
    Ir().setInt32(t + 4 * 1, _, !0), Ir().setInt32(t + 4 * 0, s, !0);
  }, n.wbg.__wbg_startWorkers_2ca11761e08ff5d5 = function(t, e, r) {
    return hv(t, e, Wf.__wrap(r));
  }, n.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
    const t = typeof mf > "u" ? null : mf;
    return Cs(t) ? 0 : Wc(t);
  }, n.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
    const t = typeof globalThis > "u" ? null : globalThis;
    return Cs(t) ? 0 : Wc(t);
  }, n.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
    const t = typeof self > "u" ? null : self;
    return Cs(t) ? 0 : Wc(t);
  }, n.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
    const t = typeof window > "u" ? null : window;
    return Cs(t) ? 0 : Wc(t);
  }, n.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(t, e, r) {
    return t.subarray(e >>> 0, r >>> 0);
  }, n.wbg.__wbg_toString_2f76f493957b63da = function(t, e, r) {
    const s = e.toString(r), _ = Qu(s, i.__wbindgen_malloc, i.__wbindgen_realloc), a = m;
    Ir().setInt32(t + 4 * 1, a, !0), Ir().setInt32(t + 4 * 0, _, !0);
  }, n.wbg.__wbg_toString_c813bbd34d063839 = function(t) {
    return t.toString();
  }, n.wbg.__wbg_versions_c71aa1626a93e0a1 = function(t) {
    return t.versions;
  }, n.wbg.__wbindgen_bigint_from_i128 = function(t, e) {
    return t << BigInt(64) | BigInt.asUintN(64, e);
  }, n.wbg.__wbindgen_bigint_from_i64 = function(t) {
    return t;
  }, n.wbg.__wbindgen_bigint_from_u128 = function(t, e) {
    return BigInt.asUintN(64, t) << BigInt(64) | BigInt.asUintN(64, e);
  }, n.wbg.__wbindgen_bigint_from_u64 = function(t) {
    return BigInt.asUintN(64, t);
  }, n.wbg.__wbindgen_bigint_get_as_i64 = function(t, e) {
    const r = e, s = typeof r == "bigint" ? r : void 0;
    Ir().setBigInt64(t + 8 * 1, Cs(s) ? BigInt(0) : s, !0), Ir().setInt32(t + 4 * 0, !Cs(s), !0);
  }, n.wbg.__wbindgen_bit_and = function(t, e) {
    return t & e;
  }, n.wbg.__wbindgen_bit_or = function(t, e) {
    return t | e;
  }, n.wbg.__wbindgen_debug_string = function(t, e) {
    const r = Th(e), s = Qu(r, i.__wbindgen_malloc, i.__wbindgen_realloc), _ = m;
    Ir().setInt32(t + 4 * 1, _, !0), Ir().setInt32(t + 4 * 0, s, !0);
  }, n.wbg.__wbindgen_error_new = function(t, e) {
    return new Error(Gs(t, e));
  }, n.wbg.__wbindgen_init_externref_table = function() {
    const t = i.__wbindgen_export_2, e = t.grow(4);
    t.set(0, void 0), t.set(e + 0, void 0), t.set(e + 1, null), t.set(e + 2, !0), t.set(e + 3, !1);
  }, n.wbg.__wbindgen_is_function = function(t) {
    return typeof t == "function";
  }, n.wbg.__wbindgen_is_object = function(t) {
    const e = t;
    return typeof e == "object" && e !== null;
  }, n.wbg.__wbindgen_is_string = function(t) {
    return typeof t == "string";
  }, n.wbg.__wbindgen_is_undefined = function(t) {
    return t === void 0;
  }, n.wbg.__wbindgen_jsval_eq = function(t, e) {
    return t === e;
  }, n.wbg.__wbindgen_lt = function(t, e) {
    return t < e;
  }, n.wbg.__wbindgen_memory = function() {
    return i.memory;
  }, n.wbg.__wbindgen_module = function() {
    return Jf.__wbindgen_wasm_module;
  }, n.wbg.__wbindgen_neg = function(t) {
    return -t;
  }, n.wbg.__wbindgen_number_new = function(t) {
    return t;
  }, n.wbg.__wbindgen_shl = function(t, e) {
    return t << e;
  }, n.wbg.__wbindgen_shr = function(t, e) {
    return t >> e;
  }, n.wbg.__wbindgen_string_get = function(t, e) {
    const r = e, s = typeof r == "string" ? r : void 0;
    var _ = Cs(s) ? 0 : Qu(s, i.__wbindgen_malloc, i.__wbindgen_realloc), a = m;
    Ir().setInt32(t + 4 * 1, a, !0), Ir().setInt32(t + 4 * 0, _, !0);
  }, n.wbg.__wbindgen_string_new = function(t, e) {
    return Gs(t, e);
  }, n.wbg.__wbindgen_throw = function(t, e) {
    throw new Error(Gs(t, e));
  }, n;
}
function ym(n, t) {
  n.wbg.memory = t || new WebAssembly.Memory({ initial: 20, maximum: 16384, shared: !0 });
}
function Am(n, t, e) {
  if (i = n.exports, Jf.__wbindgen_wasm_module = t, $c = null, Jc = null, typeof e < "u" && (typeof e != "number" || e === 0 || e % 65536 !== 0))
    throw "invalid stack size";
  return i.__wbindgen_start(e), i;
}
function Ov(n, t) {
  if (i !== void 0) return i;
  let e;
  typeof n < "u" && (Object.getPrototypeOf(n) === Object.prototype ? { module: n, memory: t, thread_stack_size: e } = n : console.warn("using deprecated parameters for `initSync()`; pass a single object instead"));
  const r = bm();
  ym(r, t), n instanceof WebAssembly.Module || (n = new WebAssembly.Module(n));
  const s = new WebAssembly.Instance(n, r);
  return Am(s, n, e);
}
async function Jf(n, t) {
  if (i !== void 0) return i;
  let e;
  typeof n < "u" && (Object.getPrototypeOf(n) === Object.prototype ? { module_or_path: n, memory: t, thread_stack_size: e } = n : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof n > "u" && (n = new URL(
    /* @vite-ignore */
    "/tfhe_bg.wasm",
    import.meta.url
  ));
  const r = bm();
  (typeof n == "string" || typeof Request == "function" && n instanceof Request || typeof URL == "function" && n instanceof URL) && (n = fetch(n)), ym(r, t);
  const { instance: s, module: _ } = await Nv(await n, r);
  return Am(s, _, e);
}
var kv = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Boolean: Mv,
  BooleanCiphertext: Tr,
  BooleanClientKey: or,
  BooleanCompressedCiphertext: Hs,
  BooleanCompressedServerKey: Ba,
  BooleanEncryptionKeyChoice: Av,
  BooleanNoiseDistribution: qs,
  BooleanParameterSet: mv,
  BooleanParameters: Qs,
  BooleanPublicKey: Ws,
  CompactCiphertextList: Es,
  CompactCiphertextListBuilder: Ou,
  CompactCiphertextListExpander: Cc,
  CompactPkeCrs: pr,
  CompressedFheBool: j_,
  CompressedFheInt10: V_,
  CompressedFheInt1024: Y_,
  CompressedFheInt104: H_,
  CompressedFheInt112: q_,
  CompressedFheInt12: Q_,
  CompressedFheInt120: W_,
  CompressedFheInt128: J_,
  CompressedFheInt136: $_,
  CompressedFheInt14: Z_,
  CompressedFheInt144: X_,
  CompressedFheInt152: to,
  CompressedFheInt16: eo,
  CompressedFheInt160: ro,
  CompressedFheInt168: no,
  CompressedFheInt176: io,
  CompressedFheInt184: so,
  CompressedFheInt192: _o,
  CompressedFheInt2: oo,
  CompressedFheInt200: ao,
  CompressedFheInt2048: co,
  CompressedFheInt208: uo,
  CompressedFheInt216: fo,
  CompressedFheInt224: lo,
  CompressedFheInt232: po,
  CompressedFheInt24: ho,
  CompressedFheInt240: wo,
  CompressedFheInt248: go,
  CompressedFheInt256: bo,
  CompressedFheInt32: yo,
  CompressedFheInt4: Ao,
  CompressedFheInt40: mo,
  CompressedFheInt48: So,
  CompressedFheInt512: Ro,
  CompressedFheInt56: Eo,
  CompressedFheInt6: Po,
  CompressedFheInt64: zo,
  CompressedFheInt72: vo,
  CompressedFheInt8: Mo,
  CompressedFheInt80: xo,
  CompressedFheInt88: Bo,
  CompressedFheInt96: Co,
  CompressedFheUint10: Io,
  CompressedFheUint1024: No,
  CompressedFheUint104: Oo,
  CompressedFheUint112: ko,
  CompressedFheUint12: To,
  CompressedFheUint120: Go,
  CompressedFheUint128: Uo,
  CompressedFheUint136: Fo,
  CompressedFheUint14: Ko,
  CompressedFheUint144: Do,
  CompressedFheUint152: Lo,
  CompressedFheUint16: jo,
  CompressedFheUint160: Vo,
  CompressedFheUint168: Yo,
  CompressedFheUint176: Ho,
  CompressedFheUint184: qo,
  CompressedFheUint192: Qo,
  CompressedFheUint2: Wo,
  CompressedFheUint200: Jo,
  CompressedFheUint2048: $o,
  CompressedFheUint208: Zo,
  CompressedFheUint216: Xo,
  CompressedFheUint224: ta,
  CompressedFheUint232: ea,
  CompressedFheUint24: ra,
  CompressedFheUint240: na,
  CompressedFheUint248: ia,
  CompressedFheUint256: sa,
  CompressedFheUint32: _a,
  CompressedFheUint4: oa,
  CompressedFheUint40: aa,
  CompressedFheUint48: ca,
  CompressedFheUint512: ua,
  CompressedFheUint56: fa,
  CompressedFheUint6: la,
  CompressedFheUint64: pa,
  CompressedFheUint72: ha,
  CompressedFheUint8: wa,
  CompressedFheUint80: da,
  CompressedFheUint88: ga,
  CompressedFheUint96: ba,
  FheBool: Hr,
  FheInt10: qr,
  FheInt1024: Qr,
  FheInt104: Wr,
  FheInt112: Jr,
  FheInt12: $r,
  FheInt120: Zr,
  FheInt128: Xr,
  FheInt136: tn,
  FheInt14: en,
  FheInt144: rn,
  FheInt152: nn,
  FheInt16: sn,
  FheInt160: _n,
  FheInt168: on,
  FheInt176: an,
  FheInt184: cn,
  FheInt192: un,
  FheInt2: fn,
  FheInt200: ln,
  FheInt2048: pn,
  FheInt208: hn,
  FheInt216: wn,
  FheInt224: dn,
  FheInt232: gn,
  FheInt24: bn,
  FheInt240: yn,
  FheInt248: An,
  FheInt256: mn,
  FheInt32: Sn,
  FheInt4: Rn,
  FheInt40: En,
  FheInt48: Pn,
  FheInt512: zn,
  FheInt56: vn,
  FheInt6: Mn,
  FheInt64: xn,
  FheInt72: Bn,
  FheInt8: Cn,
  FheInt80: In,
  FheInt88: Nn,
  FheInt96: On,
  FheTypes: Sv,
  FheUint10: kn,
  FheUint1024: Tn,
  FheUint104: Gn,
  FheUint112: Un,
  FheUint12: Fn,
  FheUint120: Kn,
  FheUint128: Dn,
  FheUint136: Ln,
  FheUint14: jn,
  FheUint144: Vn,
  FheUint152: Yn,
  FheUint16: Hn,
  FheUint160: qn,
  FheUint168: Qn,
  FheUint176: Wn,
  FheUint184: Jn,
  FheUint192: $n,
  FheUint2: Zn,
  FheUint200: Xn,
  FheUint2048: ti,
  FheUint208: ei,
  FheUint216: ri,
  FheUint224: ni,
  FheUint232: ii,
  FheUint24: si,
  FheUint240: _i,
  FheUint248: oi,
  FheUint256: ai,
  FheUint32: ci,
  FheUint4: ui,
  FheUint40: fi,
  FheUint48: li,
  FheUint512: pi,
  FheUint56: hi,
  FheUint6: wi,
  FheUint64: di,
  FheUint72: gi,
  FheUint8: bi,
  FheUint80: yi,
  FheUint88: Ai,
  FheUint96: mi,
  ProvenCompactCiphertextList: Ca,
  Shortint: Bv,
  ShortintCiphertext: Gr,
  ShortintClientKey: Qe,
  ShortintCompactPublicKeyEncryptionParameters: M_,
  ShortintCompactPublicKeyEncryptionParametersName: Rv,
  ShortintCompressedCiphertext: Js,
  ShortintCompressedPublicKey: $s,
  ShortintCompressedServerKey: Ia,
  ShortintEncryptionKeyChoice: Ev,
  ShortintNoiseDistribution: wr,
  ShortintPBSOrder: Pv,
  ShortintParameters: Ps,
  ShortintParametersName: zv,
  ShortintPublicKey: Zs,
  TfheClientKey: F,
  TfheCompactPublicKey: Xe,
  TfheCompressedCompactPublicKey: Us,
  TfheCompressedPublicKey: yt,
  TfheCompressedServerKey: ya,
  TfheConfig: x_,
  TfheConfigBuilder: Fs,
  TfhePublicKey: bt,
  TfheServerKey: lu,
  ZkComputeLoad: gm,
  default: Jf,
  initSync: Ov,
  initThreadPool: dm,
  init_panic_hook: wm,
  set_server_key: bv,
  shortint_params_name: gv,
  shortint_pke_params_name: dv,
  tfhe: Iv,
  wbg_rayon_PoolBuilder: Wf,
  wbg_rayon_start_worker: yv
});
const Tv = BigInt(1024 * 1024 * 512), hw = BigInt(1024 * 1024 * 512), ww = BigInt(1024 * 1024 * 512), tu = (n) => n ? n.endsWith("/") ? n.slice(0, -1) : n : "", Ty = (n) => {
  let t = n.toString(16);
  return t.length % 2 ? "0" + t : t;
}, Er = (n) => {
  const t = n.replace(/^(0x)/, "").match(/.{1,2}/g);
  return t ? Uint8Array.from(t.map((e) => parseInt(e, 16))) : new Uint8Array();
}, zi = (n, t = !1) => `${t ? "0x" : ""}${n.reduce((e, r) => e + r.toString(16).padStart(2, "0"), "")}`, af = function(n) {
  if (!n || (n == null ? void 0 : n.length) === 0)
    return BigInt(0);
  const t = Array.from(n).map((e) => e.toString(16).padStart(2, "0")).join("");
  return BigInt(`0x${t}`);
}, th = {}, mm = async (n, t) => {
  if (th[n])
    return th[n];
  try {
    const e = await fetch(`${n}/v1/keyurl`);
    if (!e.ok)
      throw new Error(`HTTP error! status: ${e.status}`);
    const r = await e.json();
    if (r) {
      let s;
      if (!t)
        s = r.response.fhe_key_info[0].fhe_public_key.urls[0], t = r.response.fhe_key_info[0].fhe_public_key.data_id;
      else {
        const x = r.response.fhe_key_info.find((C) => C.fhe_public_key.data_id === t);
        if (!x)
          throw new Error(`Could not find FHE key info with data_id ${t}`);
        s = x.fhe_public_key.urls[0];
      }
      const _ = await fetch(s);
      if (!_.ok)
        throw new Error(`HTTP error! status: ${_.status} on ${_.url}`);
      let a;
      typeof _.bytes == "function" ? a = await _.bytes() : a = new Uint8Array(await _.arrayBuffer());
      const c = r.response.crs[2048].urls[0], u = r.response.crs[2048].data_id, l = await fetch(c);
      if (!l.ok)
        throw new Error(`HTTP error! status: ${l.status} on ${l.url}`);
      const f = await l.bytes();
      let w;
      try {
        w = Xe.safe_deserialize(a, hw);
      } catch (x) {
        throw new Error("Invalid public key (deserialization failed)", {
          cause: x
        });
      }
      let y;
      try {
        y = pr.safe_deserialize(new Uint8Array(f), ww);
      } catch (x) {
        throw new Error("Invalid crs (deserialization failed)", {
          cause: x
        });
      }
      const v = {
        publicKey: w,
        publicKeyId: t,
        publicParams: {
          2048: {
            publicParams: y,
            publicParamsId: u
          }
        }
      };
      return th[n] = v, v;
    } else
      throw new Error("No public key available");
  } catch (e) {
    throw new Error("Impossible to fetch public key: wrong relayer url.", {
      cause: e
    });
  }
}, Sm = [
  "function getKmsSigners() view returns (address[])",
  "function getThreshold() view returns (uint256)"
], Rm = [
  "function getCoprocessorSigners() view returns (address[])",
  "function getThreshold() view returns (uint256)"
], Gv = (n) => {
  if (typeof n.network == "string")
    return new uz(n.network);
  if (n.network)
    return new lz(n.network);
  throw new Error("You must provide a network URL or a EIP1193 object (eg: window.ethereum)");
}, Uv = async (n, t) => {
  if (t.chainId && typeof t.chainId == "number")
    return t.chainId;
  if (t.chainId && typeof t.chainId != "number")
    throw new Error("chainId must be a number.");
  {
    const e = (await n.getNetwork()).chainId;
    return Number(e);
  }
}, Fv = async (n) => {
  if (n.relayerUrl && !n.publicKey) {
    const t = await mm(tu(n.relayerUrl));
    return { publicKey: t.publicKey, publicKeyId: t.publicKeyId };
  } else if (n.publicKey && n.publicKey.data && n.publicKey.id) {
    const t = n.publicKey.data;
    try {
      return {
        publicKey: Xe.safe_deserialize(t, hw),
        publicKeyId: n.publicKey.id
      };
    } catch (e) {
      throw new Error("Invalid public key (deserialization failed)", {
        cause: e
      });
    }
  } else
    throw new Error("You must provide a public key with its public key ID.");
}, Kv = async (n) => {
  if (n.relayerUrl && !n.publicParams)
    return (await mm(tu(n.relayerUrl))).publicParams;
  if (n.publicParams && n.publicParams[2048]) {
    const t = n.publicParams[2048].publicParams;
    try {
      return {
        2048: {
          publicParams: pr.safe_deserialize(t, ww),
          publicParamsId: n.publicParams[2048].publicParamsId
        }
      };
    } catch (e) {
      throw new Error("Invalid public key (deserialization failed)", {
        cause: e
      });
    }
  } else
    throw new Error("You must provide a valid CRS with its CRS ID.");
}, Dv = async (n, t) => await new Pr(t.kmsContractAddress, Sm, n).getKmsSigners(), Lv = async (n, t) => {
  const r = await new Pr(t.kmsContractAddress, Sm, n).getThreshold();
  return Number(r);
}, jv = async (n, t) => await new Pr(t.inputVerifierContractAddress, Rm, n).getCoprocessorSigners(), Vv = async (n, t) => {
  const r = await new Pr(t.inputVerifierContractAddress, Rm, n).getThreshold();
  return Number(r);
};
let ot, _e = 0, Zc = null;
function Na() {
  return (Zc === null || Zc.byteLength === 0) && (Zc = new Uint8Array(ot.memory.buffer)), Zc;
}
const cf = typeof TextEncoder < "u" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} }, Yv = typeof cf.encodeInto == "function" ? function(n, t) {
  return cf.encodeInto(n, t);
} : function(n, t) {
  const e = cf.encode(n);
  return t.set(e), {
    read: n.length,
    written: e.length
  };
};
function Aa(n, t, e) {
  if (e === void 0) {
    const c = cf.encode(n), u = t(c.length, 1) >>> 0;
    return Na().subarray(u, u + c.length).set(c), _e = c.length, u;
  }
  let r = n.length, s = t(r, 1) >>> 0;
  const _ = Na();
  let a = 0;
  for (; a < r; a++) {
    const c = n.charCodeAt(a);
    if (c > 127) break;
    _[s + a] = c;
  }
  if (a !== r) {
    a !== 0 && (n = n.slice(a)), s = e(s, r, r = a + n.length * 3, 1) >>> 0;
    const c = Na().subarray(s + a, s + r), u = Yv(n, c);
    a += u.written, s = e(s, r, a, 1) >>> 0;
  }
  return _e = a, s;
}
let Os = null;
function nr() {
  return (Os === null || Os.buffer.detached === !0 || Os.buffer.detached === void 0 && Os.buffer !== ot.memory.buffer) && (Os = new DataView(ot.memory.buffer)), Os;
}
function ma(n) {
  const t = ot.__externref_table_alloc();
  return ot.__wbindgen_export_4.set(t, n), t;
}
function Is(n, t) {
  try {
    return n.apply(this, t);
  } catch (e) {
    const r = ma(e);
    ot.__wbindgen_exn_store(r);
  }
}
const Em = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && Em.decode();
function Lc(n, t) {
  return n = n >>> 0, Em.decode(Na().subarray(n, n + t));
}
function ss(n) {
  return n == null;
}
function Gh(n) {
  const t = typeof n;
  if (t == "number" || t == "boolean" || n == null)
    return `${n}`;
  if (t == "string")
    return `"${n}"`;
  if (t == "symbol") {
    const s = n.description;
    return s == null ? "Symbol" : `Symbol(${s})`;
  }
  if (t == "function") {
    const s = n.name;
    return typeof s == "string" && s.length > 0 ? `Function(${s})` : "Function";
  }
  if (Array.isArray(n)) {
    const s = n.length;
    let _ = "[";
    s > 0 && (_ += Gh(n[0]));
    for (let a = 1; a < s; a++)
      _ += ", " + Gh(n[a]);
    return _ += "]", _;
  }
  const e = /\[object ([^\]]+)\]/.exec(toString.call(n));
  let r;
  if (e && e.length > 1)
    r = e[1];
  else
    return toString.call(n);
  if (r == "Object")
    try {
      return "Object(" + JSON.stringify(n) + ")";
    } catch {
      return "Object";
    }
  return n instanceof Error ? `${n.name}: ${n.message}
${n.stack}` : r;
}
function m_(n, t) {
  if (!(n instanceof t))
    throw new Error(`expected instance of ${t.name}`);
}
function Mr(n, t) {
  return n = n >>> 0, Na().subarray(n / 1, n / 1 + t);
}
function xr(n, t) {
  const e = t(n.length * 1, 1) >>> 0;
  return Na().set(n, e / 1), _e = n.length, e;
}
function kc(n) {
  const t = ot.__wbindgen_export_4.get(n);
  return ot.__externref_table_dealloc(n), t;
}
function Pm(n, t) {
  const e = t(n.length * 4, 4) >>> 0;
  for (let r = 0; r < n.length; r++) {
    const s = ma(n[r]);
    nr().setUint32(e + 4 * r, s, !0);
  }
  return _e = n.length, e;
}
function Hv(n, t, e) {
  const r = Pm(n, ot.__wbindgen_malloc), s = _e, _ = Aa(t, ot.__wbindgen_malloc, ot.__wbindgen_realloc), a = _e, c = Aa(e, ot.__wbindgen_malloc, ot.__wbindgen_realloc), u = _e, l = ot.new_client(r, s, _, a, c, u);
  if (l[2])
    throw kc(l[1]);
  return $f.__wrap(l[0]);
}
function zm(n, t) {
  n = n >>> 0;
  const e = nr(), r = [];
  for (let s = n; s < n + 4 * t; s += 4)
    r.push(ot.__wbindgen_export_4.get(e.getUint32(s, !0)));
  return ot.__externref_drop_slice(n, t), r;
}
function qv() {
  const n = ot.cryptobox_keygen();
  return I_.__wrap(n);
}
function Qv(n) {
  m_(n, I_);
  const t = ot.cryptobox_get_pk(n.__wbg_ptr);
  return Tc.__wrap(t);
}
function Wv(n) {
  m_(n, Tc);
  const t = ot.cryptobox_pk_to_u8vec(n.__wbg_ptr);
  if (t[3])
    throw kc(t[2]);
  var e = Mr(t[0], t[1]).slice();
  return ot.__wbindgen_free(t[0], t[1] * 1, 1), e;
}
function Jv(n) {
  m_(n, I_);
  const t = ot.cryptobox_sk_to_u8vec(n.__wbg_ptr);
  if (t[3])
    throw kc(t[2]);
  var e = Mr(t[0], t[1]).slice();
  return ot.__wbindgen_free(t[0], t[1] * 1, 1), e;
}
function $v(n) {
  const t = xr(n, ot.__wbindgen_malloc), e = _e, r = ot.u8vec_to_cryptobox_pk(t, e);
  if (r[2])
    throw kc(r[1]);
  return Tc.__wrap(r[0]);
}
function Zv(n) {
  const t = xr(n, ot.__wbindgen_malloc), e = _e, r = ot.u8vec_to_cryptobox_sk(t, e);
  if (r[2])
    throw kc(r[1]);
  return I_.__wrap(r[0]);
}
function Xv(n, t, e, r, s, _, a) {
  m_(n, $f), m_(s, Tc), m_(_, I_);
  const c = ot.process_user_decryption_resp_from_js(n.__wbg_ptr, t, e, r, s.__wbg_ptr, _.__wbg_ptr, a);
  if (c[3])
    throw kc(c[2]);
  var u = zm(c[0], c[1]).slice();
  return ot.__wbindgen_free(c[0], c[1] * 4, 4), u;
}
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => ot.__wbg_ciphertexthandle_free(n >>> 0, 1));
const Gy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => ot.__wbg_client_free(n >>> 0, 1));
class $f {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create($f.prototype);
    return e.__wbg_ptr = t, Gy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Gy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    ot.__wbg_client_free(t, 0);
  }
}
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => ot.__wbg_cryptoboxct_free(n >>> 0, 1));
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => ot.__wbg_eip712domainmsg_free(n >>> 0, 1));
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => ot.__wbg_parseduserdecryptionrequest_free(n >>> 0, 1));
const Uy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => ot.__wbg_privateenckey_free(n >>> 0, 1));
class I_ {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(I_.prototype);
    return e.__wbg_ptr = t, Uy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Uy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    ot.__wbg_privateenckey_free(t, 0);
  }
}
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => ot.__wbg_privatesigkey_free(n >>> 0, 1));
const Fy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => ot.__wbg_publicenckey_free(n >>> 0, 1));
class Tc {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Tc.prototype);
    return e.__wbg_ptr = t, Fy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Fy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    ot.__wbg_publicenckey_free(t, 0);
  }
}
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => ot.__wbg_publicsigkey_free(n >>> 0, 1));
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => ot.__wbg_requestid_free(n >>> 0, 1));
const Ky = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => ot.__wbg_typedciphertext_free(n >>> 0, 1));
class pu {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(pu.prototype);
    return e.__wbg_ptr = t, Ky.register(e, e.__wbg_ptr, e), e;
  }
  static __unwrap(t) {
    return t instanceof pu ? t.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ky.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    ot.__wbg_typedciphertext_free(t, 0);
  }
  /**
   * The actual ciphertext to decrypt, taken directly from fhevm.
   * @returns {Uint8Array}
   */
  get ciphertext() {
    const t = ot.__wbg_get_typedciphertext_ciphertext(this.__wbg_ptr);
    var e = Mr(t[0], t[1]).slice();
    return ot.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * The actual ciphertext to decrypt, taken directly from fhevm.
   * @param {Uint8Array} arg0
   */
  set ciphertext(t) {
    const e = xr(t, ot.__wbindgen_malloc), r = _e;
    ot.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, e, r);
  }
  /**
   * The type of plaintext encrypted. The type should match FheType from tfhe-rs:
   * <https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/high_level_api/mod.rs>
   * @returns {number}
   */
  get fhe_type() {
    return ot.__wbg_get_typedciphertext_fhe_type(this.__wbg_ptr);
  }
  /**
   * The type of plaintext encrypted. The type should match FheType from tfhe-rs:
   * <https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/high_level_api/mod.rs>
   * @param {number} arg0
   */
  set fhe_type(t) {
    ot.__wbg_set_typedciphertext_fhe_type(this.__wbg_ptr, t);
  }
  /**
   * The external handle of the ciphertext (the handle used in the copro).
   * @returns {Uint8Array}
   */
  get external_handle() {
    const t = ot.__wbg_get_typedciphertext_external_handle(this.__wbg_ptr);
    var e = Mr(t[0], t[1]).slice();
    return ot.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * The external handle of the ciphertext (the handle used in the copro).
   * @param {Uint8Array} arg0
   */
  set external_handle(t) {
    const e = xr(t, ot.__wbindgen_malloc), r = _e;
    ot.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, e, r);
  }
  /**
   * The ciphertext format, see CiphertextFormat documentation for details.
   * CiphertextFormat::default() is used if unspecified.
   * @returns {number}
   */
  get ciphertext_format() {
    return ot.__wbg_get_typedciphertext_ciphertext_format(this.__wbg_ptr);
  }
  /**
   * The ciphertext format, see CiphertextFormat documentation for details.
   * CiphertextFormat::default() is used if unspecified.
   * @param {number} arg0
   */
  set ciphertext_format(t) {
    ot.__wbg_set_typedciphertext_ciphertext_format(this.__wbg_ptr, t);
  }
}
const Dy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => ot.__wbg_typedplaintext_free(n >>> 0, 1));
class dw {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(dw.prototype);
    return e.__wbg_ptr = t, Dy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Dy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    ot.__wbg_typedplaintext_free(t, 0);
  }
  /**
   * The actual plaintext in bytes.
   * @returns {Uint8Array}
   */
  get bytes() {
    const t = ot.__wbg_get_typedplaintext_bytes(this.__wbg_ptr);
    var e = Mr(t[0], t[1]).slice();
    return ot.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * The actual plaintext in bytes.
   * @param {Uint8Array} arg0
   */
  set bytes(t) {
    const e = xr(t, ot.__wbindgen_malloc), r = _e;
    ot.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, e, r);
  }
  /**
   * The type of plaintext encrypted. The type should match FheType from tfhe-rs:
   * <https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/high_level_api/mod.rs>
   * @returns {number}
   */
  get fhe_type() {
    return ot.__wbg_get_typedplaintext_fhe_type(this.__wbg_ptr);
  }
  /**
   * The type of plaintext encrypted. The type should match FheType from tfhe-rs:
   * <https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/high_level_api/mod.rs>
   * @param {number} arg0
   */
  set fhe_type(t) {
    ot.__wbg_set_typedplaintext_fhe_type(this.__wbg_ptr, t);
  }
}
const Ly = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => ot.__wbg_typedsigncryptedciphertext_free(n >>> 0, 1));
class hu {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(hu.prototype);
    return e.__wbg_ptr = t, Ly.register(e, e.__wbg_ptr, e), e;
  }
  static __unwrap(t) {
    return t instanceof hu ? t.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ly.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    ot.__wbg_typedsigncryptedciphertext_free(t, 0);
  }
  /**
   * The type of plaintext encrypted. The type should match FheType from tfhe-rs:
   * <https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/high_level_api/mod.rs>
   * @returns {number}
   */
  get fhe_type() {
    return ot.__wbg_get_typedciphertext_fhe_type(this.__wbg_ptr);
  }
  /**
   * The type of plaintext encrypted. The type should match FheType from tfhe-rs:
   * <https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/high_level_api/mod.rs>
   * @param {number} arg0
   */
  set fhe_type(t) {
    ot.__wbg_set_typedciphertext_fhe_type(this.__wbg_ptr, t);
  }
  /**
   * The signcrypted payload, using a hybrid encryption approach in
   * sign-then-encrypt.
   * @returns {Uint8Array}
   */
  get signcrypted_ciphertext() {
    const t = ot.__wbg_get_typedsigncryptedciphertext_signcrypted_ciphertext(this.__wbg_ptr);
    var e = Mr(t[0], t[1]).slice();
    return ot.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * The signcrypted payload, using a hybrid encryption approach in
   * sign-then-encrypt.
   * @param {Uint8Array} arg0
   */
  set signcrypted_ciphertext(t) {
    const e = xr(t, ot.__wbindgen_malloc), r = _e;
    ot.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, e, r);
  }
  /**
   * The external handles that were originally in the request.
   * @returns {Uint8Array}
   */
  get external_handle() {
    const t = ot.__wbg_get_typedsigncryptedciphertext_external_handle(this.__wbg_ptr);
    var e = Mr(t[0], t[1]).slice();
    return ot.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * The external handles that were originally in the request.
   * @param {Uint8Array} arg0
   */
  set external_handle(t) {
    const e = xr(t, ot.__wbindgen_malloc), r = _e;
    ot.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, e, r);
  }
  /**
   * The packing factor determines whether the decrypted plaintext
   * has a different way of packing compared to what is specified in the plaintext modulus.
   * @returns {number}
   */
  get packing_factor() {
    return ot.__wbg_get_typedciphertext_ciphertext_format(this.__wbg_ptr) >>> 0;
  }
  /**
   * The packing factor determines whether the decrypted plaintext
   * has a different way of packing compared to what is specified in the plaintext modulus.
   * @param {number} arg0
   */
  set packing_factor(t) {
    ot.__wbg_set_typedciphertext_ciphertext_format(this.__wbg_ptr, t);
  }
}
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => ot.__wbg_userdecryptionrequest_free(n >>> 0, 1));
const tM = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => ot.__wbg_userdecryptionresponse_free(n >>> 0, 1));
class gw {
  static __unwrap(t) {
    return t instanceof gw ? t.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, tM.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    ot.__wbg_userdecryptionresponse_free(t, 0);
  }
  /**
   * @returns {Uint8Array}
   */
  get signature() {
    const t = ot.__wbg_get_userdecryptionresponse_signature(this.__wbg_ptr);
    var e = Mr(t[0], t[1]).slice();
    return ot.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} arg0
   */
  set signature(t) {
    const e = xr(t, ot.__wbindgen_malloc), r = _e;
    ot.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, e, r);
  }
  /**
   * This is the external signature created from the Eip712 domain
   * on the structure, where userDecryptedShare is bincode::serialize(&payload)
   * struct UserDecryptResponseVerification {
   *      bytes publicKey;
   *      uint256\[\] ctHandles;
   *      bytes userDecryptedShare;
   * }
   * @returns {Uint8Array}
   */
  get external_signature() {
    const t = ot.__wbg_get_userdecryptionresponse_external_signature(this.__wbg_ptr);
    var e = Mr(t[0], t[1]).slice();
    return ot.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * This is the external signature created from the Eip712 domain
   * on the structure, where userDecryptedShare is bincode::serialize(&payload)
   * struct UserDecryptResponseVerification {
   *      bytes publicKey;
   *      uint256\[\] ctHandles;
   *      bytes userDecryptedShare;
   * }
   * @param {Uint8Array} arg0
   */
  set external_signature(t) {
    const e = xr(t, ot.__wbindgen_malloc), r = _e;
    ot.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, e, r);
  }
  /**
   * The actual \[UserDecryptionResponsePayload\].
   * @returns {UserDecryptionResponsePayload | undefined}
   */
  get payload() {
    const t = ot.__wbg_get_userdecryptionresponse_payload(this.__wbg_ptr);
    return t === 0 ? void 0 : Sf.__wrap(t);
  }
  /**
   * The actual \[UserDecryptionResponsePayload\].
   * @param {UserDecryptionResponsePayload | null} [arg0]
   */
  set payload(t) {
    let e = 0;
    ss(t) || (m_(t, Sf), e = t.__destroy_into_raw()), ot.__wbg_set_userdecryptionresponse_payload(this.__wbg_ptr, e);
  }
}
const jy = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => ot.__wbg_userdecryptionresponsepayload_free(n >>> 0, 1));
class Sf {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Sf.prototype);
    return e.__wbg_ptr = t, jy.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, jy.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    ot.__wbg_userdecryptionresponsepayload_free(t, 0);
  }
  /**
   * The server's signature verification key, Encoded using SEC1.
   * Needed to validate the response, but MUST also be linked to a list of
   * trusted keys.
   * @returns {Uint8Array}
   */
  get verification_key() {
    const t = ot.__wbg_get_userdecryptionresponsepayload_verification_key(this.__wbg_ptr);
    var e = Mr(t[0], t[1]).slice();
    return ot.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * The server's signature verification key, Encoded using SEC1.
   * Needed to validate the response, but MUST also be linked to a list of
   * trusted keys.
   * @param {Uint8Array} arg0
   */
  set verification_key(t) {
    const e = xr(t, ot.__wbindgen_malloc), r = _e;
    ot.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, e, r);
  }
  /**
   * This is needed to ensure the response corresponds to the request.
   * It is the digest of UserDecryptionLinker hashed using EIP712
   * under the given domain in the request.
   * @returns {Uint8Array}
   */
  get digest() {
    const t = ot.__wbg_get_userdecryptionresponsepayload_digest(this.__wbg_ptr);
    var e = Mr(t[0], t[1]).slice();
    return ot.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * This is needed to ensure the response corresponds to the request.
   * It is the digest of UserDecryptionLinker hashed using EIP712
   * under the given domain in the request.
   * @param {Uint8Array} arg0
   */
  set digest(t) {
    const e = xr(t, ot.__wbindgen_malloc), r = _e;
    ot.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, e, r);
  }
  /**
   * The resulting signcrypted ciphertexts, each ciphertext
   * must be decrypted and then reconstructed with the other shares
   * to produce the final plaintext.
   * @returns {TypedSigncryptedCiphertext[]}
   */
  get signcrypted_ciphertexts() {
    const t = ot.__wbg_get_userdecryptionresponsepayload_signcrypted_ciphertexts(this.__wbg_ptr);
    var e = zm(t[0], t[1]).slice();
    return ot.__wbindgen_free(t[0], t[1] * 4, 4), e;
  }
  /**
   * The resulting signcrypted ciphertexts, each ciphertext
   * must be decrypted and then reconstructed with the other shares
   * to produce the final plaintext.
   * @param {TypedSigncryptedCiphertext[]} arg0
   */
  set signcrypted_ciphertexts(t) {
    const e = Pm(t, ot.__wbindgen_malloc), r = _e;
    ot.__wbg_set_userdecryptionresponsepayload_signcrypted_ciphertexts(this.__wbg_ptr, e, r);
  }
  /**
   * The ID of the MPC party doing the user decryption. Used for polynomial
   * reconstruction.
   * @returns {number}
   */
  get party_id() {
    return ot.__wbg_get_userdecryptionresponsepayload_party_id(this.__wbg_ptr) >>> 0;
  }
  /**
   * The ID of the MPC party doing the user decryption. Used for polynomial
   * reconstruction.
   * @param {number} arg0
   */
  set party_id(t) {
    ot.__wbg_set_userdecryptionresponsepayload_party_id(this.__wbg_ptr, t);
  }
  /**
   * The degree of the sharing scheme used.
   * @returns {number}
   */
  get degree() {
    return ot.__wbg_get_userdecryptionresponsepayload_degree(this.__wbg_ptr) >>> 0;
  }
  /**
   * The degree of the sharing scheme used.
   * @param {number} arg0
   */
  set degree(t) {
    ot.__wbg_set_userdecryptionresponsepayload_degree(this.__wbg_ptr, t);
  }
}
async function eM(n, t) {
  if (typeof Response == "function" && n instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(n, t);
      } catch (r) {
        if (n.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", r);
        else
          throw r;
      }
    const e = await n.arrayBuffer();
    return await WebAssembly.instantiate(e, t);
  } else {
    const e = await WebAssembly.instantiate(n, t);
    return e instanceof WebAssembly.Instance ? { instance: e, module: n } : e;
  }
}
function rM() {
  const n = {};
  return n.wbg = {}, n.wbg.__wbg_String_8f0eb39a4a4c2f66 = function(t, e) {
    const r = String(e), s = Aa(r, ot.__wbindgen_malloc, ot.__wbindgen_realloc), _ = _e;
    nr().setInt32(t + 4 * 1, _, !0), nr().setInt32(t + 4 * 0, s, !0);
  }, n.wbg.__wbg_buffer_609cc3eee51ed158 = function(t) {
    return t.buffer;
  }, n.wbg.__wbg_call_672a4d21634d4a24 = function() {
    return Is(function(t, e) {
      return t.call(e);
    }, arguments);
  }, n.wbg.__wbg_call_7cccdd69e0791ae2 = function() {
    return Is(function(t, e, r) {
      return t.call(e, r);
    }, arguments);
  }, n.wbg.__wbg_crypto_ed58b8e10a292839 = function(t) {
    return t.crypto;
  }, n.wbg.__wbg_done_769e5ede4b31c67b = function(t) {
    return t.done;
  }, n.wbg.__wbg_error_7534b8e9a36f1ab4 = function(t, e) {
    let r, s;
    try {
      r = t, s = e, console.error(Lc(t, e));
    } finally {
      ot.__wbindgen_free(r, s, 1);
    }
  }, n.wbg.__wbg_getRandomValues_bcb4912f16000dc4 = function() {
    return Is(function(t, e) {
      t.getRandomValues(e);
    }, arguments);
  }, n.wbg.__wbg_get_67b2ba62fc30de12 = function() {
    return Is(function(t, e) {
      return Reflect.get(t, e);
    }, arguments);
  }, n.wbg.__wbg_get_b9b93047fe3cf45b = function(t, e) {
    return t[e >>> 0];
  }, n.wbg.__wbg_getwithrefkey_1dc361bd10053bfe = function(t, e) {
    return t[e];
  }, n.wbg.__wbg_instanceof_ArrayBuffer_e14585432e3737fc = function(t) {
    let e;
    try {
      e = t instanceof ArrayBuffer;
    } catch {
      e = !1;
    }
    return e;
  }, n.wbg.__wbg_instanceof_Uint8Array_17156bcf118086a9 = function(t) {
    let e;
    try {
      e = t instanceof Uint8Array;
    } catch {
      e = !1;
    }
    return e;
  }, n.wbg.__wbg_isArray_a1eab7e0d067391b = function(t) {
    return Array.isArray(t);
  }, n.wbg.__wbg_isSafeInteger_343e2beeeece1bb0 = function(t) {
    return Number.isSafeInteger(t);
  }, n.wbg.__wbg_iterator_9a24c88df860dc65 = function() {
    return Symbol.iterator;
  }, n.wbg.__wbg_length_a446193dc22c12f8 = function(t) {
    return t.length;
  }, n.wbg.__wbg_length_e2d2a49132c1b256 = function(t) {
    return t.length;
  }, n.wbg.__wbg_msCrypto_0a36e2ec3a343d26 = function(t) {
    return t.msCrypto;
  }, n.wbg.__wbg_new_8a6f238a6ece86ea = function() {
    return new Error();
  }, n.wbg.__wbg_new_a12002a7f91c75be = function(t) {
    return new Uint8Array(t);
  }, n.wbg.__wbg_newnoargs_105ed471475aaf50 = function(t, e) {
    return new Function(Lc(t, e));
  }, n.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(t, e, r) {
    return new Uint8Array(t, e >>> 0, r >>> 0);
  }, n.wbg.__wbg_newwithlength_a381634e90c276d4 = function(t) {
    return new Uint8Array(t >>> 0);
  }, n.wbg.__wbg_next_25feadfc0913fea9 = function(t) {
    return t.next;
  }, n.wbg.__wbg_next_6574e1a8a62d1055 = function() {
    return Is(function(t) {
      return t.next();
    }, arguments);
  }, n.wbg.__wbg_node_02999533c4ea02e3 = function(t) {
    return t.node;
  }, n.wbg.__wbg_process_5c1d670bc53614b8 = function(t) {
    return t.process;
  }, n.wbg.__wbg_randomFillSync_ab2cfe79ebbf2740 = function() {
    return Is(function(t, e) {
      t.randomFillSync(e);
    }, arguments);
  }, n.wbg.__wbg_require_79b1e9274cde3c87 = function() {
    return Is(function() {
      return module.require;
    }, arguments);
  }, n.wbg.__wbg_set_65595bdd868b3009 = function(t, e, r) {
    t.set(e, r >>> 0);
  }, n.wbg.__wbg_stack_0ed75d68575b0f3c = function(t, e) {
    const r = e.stack, s = Aa(r, ot.__wbindgen_malloc, ot.__wbindgen_realloc), _ = _e;
    nr().setInt32(t + 4 * 1, _, !0), nr().setInt32(t + 4 * 0, s, !0);
  }, n.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
    const t = typeof mf > "u" ? null : mf;
    return ss(t) ? 0 : ma(t);
  }, n.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
    const t = typeof globalThis > "u" ? null : globalThis;
    return ss(t) ? 0 : ma(t);
  }, n.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
    const t = typeof self > "u" ? null : self;
    return ss(t) ? 0 : ma(t);
  }, n.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
    const t = typeof window > "u" ? null : window;
    return ss(t) ? 0 : ma(t);
  }, n.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(t, e, r) {
    return t.subarray(e >>> 0, r >>> 0);
  }, n.wbg.__wbg_typedciphertext_new = function(t) {
    return pu.__wrap(t);
  }, n.wbg.__wbg_typedciphertext_unwrap = function(t) {
    return pu.__unwrap(t);
  }, n.wbg.__wbg_typedplaintext_new = function(t) {
    return dw.__wrap(t);
  }, n.wbg.__wbg_typedsigncryptedciphertext_new = function(t) {
    return hu.__wrap(t);
  }, n.wbg.__wbg_typedsigncryptedciphertext_unwrap = function(t) {
    return hu.__unwrap(t);
  }, n.wbg.__wbg_userdecryptionresponse_unwrap = function(t) {
    return gw.__unwrap(t);
  }, n.wbg.__wbg_value_cd1ffa7b1ab794f1 = function(t) {
    return t.value;
  }, n.wbg.__wbg_versions_c71aa1626a93e0a1 = function(t) {
    return t.versions;
  }, n.wbg.__wbindgen_as_number = function(t) {
    return +t;
  }, n.wbg.__wbindgen_boolean_get = function(t) {
    const e = t;
    return typeof e == "boolean" ? e ? 1 : 0 : 2;
  }, n.wbg.__wbindgen_debug_string = function(t, e) {
    const r = Gh(e), s = Aa(r, ot.__wbindgen_malloc, ot.__wbindgen_realloc), _ = _e;
    nr().setInt32(t + 4 * 1, _, !0), nr().setInt32(t + 4 * 0, s, !0);
  }, n.wbg.__wbindgen_error_new = function(t, e) {
    return new Error(Lc(t, e));
  }, n.wbg.__wbindgen_in = function(t, e) {
    return t in e;
  }, n.wbg.__wbindgen_init_externref_table = function() {
    const t = ot.__wbindgen_export_4, e = t.grow(4);
    t.set(0, void 0), t.set(e + 0, void 0), t.set(e + 1, null), t.set(e + 2, !0), t.set(e + 3, !1);
  }, n.wbg.__wbindgen_is_function = function(t) {
    return typeof t == "function";
  }, n.wbg.__wbindgen_is_null = function(t) {
    return t === null;
  }, n.wbg.__wbindgen_is_object = function(t) {
    const e = t;
    return typeof e == "object" && e !== null;
  }, n.wbg.__wbindgen_is_string = function(t) {
    return typeof t == "string";
  }, n.wbg.__wbindgen_is_undefined = function(t) {
    return t === void 0;
  }, n.wbg.__wbindgen_jsval_loose_eq = function(t, e) {
    return t == e;
  }, n.wbg.__wbindgen_memory = function() {
    return ot.memory;
  }, n.wbg.__wbindgen_number_get = function(t, e) {
    const r = e, s = typeof r == "number" ? r : void 0;
    nr().setFloat64(t + 8 * 1, ss(s) ? 0 : s, !0), nr().setInt32(t + 4 * 0, !ss(s), !0);
  }, n.wbg.__wbindgen_string_get = function(t, e) {
    const r = e, s = typeof r == "string" ? r : void 0;
    var _ = ss(s) ? 0 : Aa(s, ot.__wbindgen_malloc, ot.__wbindgen_realloc), a = _e;
    nr().setInt32(t + 4 * 1, a, !0), nr().setInt32(t + 4 * 0, _, !0);
  }, n.wbg.__wbindgen_string_new = function(t, e) {
    return Lc(t, e);
  }, n.wbg.__wbindgen_throw = function(t, e) {
    throw new Error(Lc(t, e));
  }, n;
}
function nM(n, t) {
  return ot = n.exports, vm.__wbindgen_wasm_module = t, Os = null, Zc = null, ot.__wbindgen_start(), ot;
}
async function vm(n) {
  if (ot !== void 0) return ot;
  typeof n < "u" && (Object.getPrototypeOf(n) === Object.prototype ? { module_or_path: n } = n : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof n > "u" && (n = new URL(
    /* @vite-ignore */
    "/kms_lib_bg.wasm",
    import.meta.url
  ));
  const t = rM();
  (typeof n == "string" || typeof Request == "function" && n instanceof Request || typeof URL == "function" && n instanceof URL) && (n = fetch(n));
  const { instance: e, module: r } = await eM(await n, t);
  return nM(e, r);
}
const Vy = {
  0: 2,
  // ebool
  2: 8,
  // euint8
  3: 16,
  // euint16
  4: 32,
  // euint32
  5: 64,
  // euint64
  6: 128,
  // euint128
  7: 160,
  // eaddress
  8: 256,
  // euint256
  9: 512,
  // ebytes64
  10: 1024,
  // ebytes128
  11: 2048
  // ebytes256
};
function Mm(n) {
  let t = 0;
  for (const e of n) {
    if (e.length !== 66)
      throw new Error(`Handle ${e} is not of valid length`);
    const r = e.slice(-4, -2).toLowerCase(), s = parseInt(r, 16);
    if (!(s in Vy))
      throw new Error(`Handle ${e} is not of valid type`);
    if (t += Vy[s], t > 2048)
      throw new Error("Cannot decrypt more than 2048 encrypted bits in a single request");
  }
  return t;
}
const iM = [
  "function persistAllowed(bytes32 handle, address account) view returns (bool)"
], Yy = 10, Hy = BigInt(365);
function sM(n, t) {
  return t === 0 ? n === BigInt(1) : t === 7 ? jt("0x" + n.toString(16).padStart(40, "0")) : t === 9 ? "0x" + n.toString(16).padStart(128, "0") : t === 10 ? "0x" + n.toString(16).padStart(256, "0") : t === 11 ? "0x" + n.toString(16).padStart(512, "0") : n;
}
function _M(n, t) {
  let e = [];
  for (const s of n) {
    const _ = s.slice(-4, -2).toLowerCase(), a = parseInt(_, 16);
    e.push(a);
  }
  let r = {};
  return n.forEach((s, _) => r[s] = sM(t[_], e[_])), r;
}
function oM(n, t) {
  if (t === BigInt(0))
    throw Error("durationDays is null");
  if (t > Hy)
    throw Error(`durationDays is above max duration of ${Hy}`);
  const e = BigInt(Math.floor(Date.now() / 1e3));
  if (n > e)
    throw Error("startTimestamp is set in the future");
  const r = t * BigInt(86400);
  if (n + r < e)
    throw Error("User decrypt request has expired");
}
const aM = (n, t, e, r, s, _, a) => async (c, u, l, f, w, y, v, x) => {
  const C = c.map((et) => ({
    handle: typeof et.handle == "string" ? zi(Er(et.handle), !0) : zi(et.handle, !0),
    contractAddress: et.contractAddress
  }));
  Mm(C.map((et) => et.handle)), oM(BigInt(v), BigInt(x));
  const U = new Pr(s, iM, a), z = C.map(async ({ handle: et, contractAddress: lt }) => {
    const Y = await U.persistAllowed(et, y), Et = await U.persistAllowed(et, lt);
    if (!Y)
      throw new Error(`User ${y} is not authorized to user decrypt handle ${et}!`);
    if (!Et)
      throw new Error(`dapp contract ${lt} is not authorized to user decrypt handle ${et}!`);
    if (y === lt)
      throw new Error(`userAddress ${y} should not be equal to contractAddress when requesting user decryption!`);
  }), M = w.length;
  if (M === 0)
    throw Error("contractAddresses is empty");
  if (M > Yy)
    throw Error(`contractAddresses max length of ${Yy} exceeded`);
  await Promise.all(z).catch((et) => {
    throw et;
  });
  const N = {
    handleContractPairs: C,
    requestValidity: {
      startTimestamp: v.toString(),
      // Convert to string
      durationDays: x.toString()
      // Convert to string
    },
    contractsChainId: e.toString(),
    // Convert to string
    contractAddresses: w.map((et) => jt(et)),
    userAddress: jt(y),
    signature: f.replace(/^(0x)/, ""),
    publicKey: l.replace(/^(0x)/, "")
  }, I = {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(N)
  };
  let G, D;
  try {
    G = $v(Er(l)), D = Zv(Er(u));
  } catch (et) {
    throw new Error("Invalid public or private key", { cause: et });
  }
  let j, L;
  try {
    if (j = await fetch(`${_}/v1/user-decrypt`, I), !j.ok)
      throw new Error(`User decrypt failed: relayer respond with HTTP code ${j.status}`);
  } catch (et) {
    throw new Error("User decrypt failed: Relayer didn't respond", {
      cause: et
    });
  }
  try {
    L = await j.json();
  } catch (et) {
    throw new Error("User decrypt failed: Relayer didn't return a JSON", {
      cause: et
    });
  }
  if (L.status === "failure")
    throw new Error("User decrypt failed: the user decryption didn't succeed for an unknown reason", { cause: L });
  const X = Hv(n, y, "default");
  try {
    const et = new ArrayBuffer(32);
    new DataView(et).setUint32(28, t, !1);
    const Et = {
      name: "Decryption",
      version: "1",
      chain_id: new Uint8Array(et),
      verifying_contract: r,
      salt: null
    }, Ct = {
      signature: f,
      client_address: y,
      enc_key: l.replace(/^0x/, ""),
      ciphertext_handles: C.map((Mt) => Mt.handle.replace(/^0x/, "")),
      eip712_verifying_contract: r
    }, wt = Xv(X, Ct, Et, L.response, G, D, !0).map((Mt) => af(Mt.bytes));
    return _M(C.map((Mt) => Mt.handle), wt);
  } catch (et) {
    throw new Error("An error occured during decryption", { cause: et });
  }
}, Nr = (n, t) => {
  if (n == null)
    throw new Error("Missing value");
  let e;
  if (t >= 8 ? e = BigInt(`0x${new Array(t / 8).fill(null).reduce((r) => `${r}ff`, "")}`) : e = BigInt(2 ** t - 1), typeof n != "number" && typeof n != "bigint")
    throw new Error("Value must be a number or a bigint.");
  if (n > e)
    throw new Error(`The value exceeds the limit for ${t}bits integer (${e.toString()}).`);
}, cM = ({ aclContractAddress: n, chainId: t, tfheCompactPublicKey: e, publicParams: r, contractAddress: s, userAddress: _ }) => {
  if (!hr(s))
    throw new Error("Contract address is not a valid address.");
  if (!hr(_))
    throw new Error("User address is not a valid address.");
  const a = e, c = [], u = Es.builder(a);
  let l = new Uint8Array();
  const f = (w) => {
    if (c.reduce((y, v) => y + Math.max(2, v), 0) + w > 2048)
      throw Error("Packing more than 2048 bits in a single input ciphertext is unsupported");
    if (c.length + 1 > 256)
      throw Error("Packing more than 256 variables in a single input ciphertext is unsupported");
  };
  return {
    addBool(w) {
      if (w == null)
        throw new Error("Missing value");
      if (typeof w != "boolean" && typeof w != "number" && typeof w != "bigint")
        throw new Error("The value must be a boolean, a number or a bigint.");
      if (Number(w) > 1)
        throw new Error("The value must be 1 or 0.");
      return Nr(Number(w), 1), f(2), u.push_boolean(!!w), c.push(1), this;
    },
    add8(w) {
      return Nr(w, 8), f(8), u.push_u8(Number(w)), c.push(8), this;
    },
    add16(w) {
      return Nr(w, 16), f(16), u.push_u16(Number(w)), c.push(16), this;
    },
    add32(w) {
      return Nr(w, 32), f(32), u.push_u32(Number(w)), c.push(32), this;
    },
    add64(w) {
      return Nr(w, 64), f(64), u.push_u64(BigInt(w)), c.push(64), this;
    },
    add128(w) {
      return Nr(w, 128), f(128), u.push_u128(BigInt(w)), c.push(128), this;
    },
    addAddress(w) {
      if (!hr(w))
        throw new Error("The value must be a valid address.");
      return f(160), u.push_u160(BigInt(w)), c.push(160), this;
    },
    add256(w) {
      return Nr(w, 256), f(256), u.push_u256(BigInt(w)), c.push(256), this;
    },
    addBytes64(w) {
      if (w.length !== 64)
        throw Error("Uncorrect length of input Uint8Array, should be 64 for an ebytes64");
      const y = af(w);
      return Nr(y, 512), f(512), u.push_u512(y), c.push(512), this;
    },
    addBytes128(w) {
      if (w.length !== 128)
        throw Error("Uncorrect length of input Uint8Array, should be 128 for an ebytes128");
      const y = af(w);
      return Nr(y, 1024), f(1024), u.push_u1024(y), c.push(1024), this;
    },
    addBytes256(w) {
      if (w.length !== 256)
        throw Error("Uncorrect length of input Uint8Array, should be 256 for an ebytes256");
      const y = af(w);
      return Nr(y, 2048), f(2048), u.push_u2048(y), c.push(2048), this;
    },
    getBits() {
      return c;
    },
    encrypt() {
      const y = (() => {
        const I = (L) => Object.keys(L), G = c.reduce((L, X) => L + X, 0), D = I(r), j = D.find((L) => Number(L) >= G);
        if (!j)
          throw new Error(`Too many bits in provided values. Maximum is ${D[D.length - 1]}.`);
        return j;
      })(), v = r[y].publicParams, x = Er(s), C = Er(_), U = Er(n), z = Er(t.toString(16).padStart(64, "0")), M = new Uint8Array(x.length + C.length + U.length + 32);
      return M.set(x, 0), M.set(C, 20), M.set(U, 40), M.set(z, M.length - z.length), l = u.build_with_proof_packed(v, M, gm.Verify).safe_serialize(Tv), l;
    }
  };
}, uM = {
  1: 0,
  // ebool takes 2 encrypted bits
  8: 2,
  16: 3,
  32: 4,
  64: 5,
  128: 6,
  160: 7,
  256: 8,
  512: 9,
  1024: 10,
  2048: 11
}, fM = BigInt("18446744073709551615"), lM = (n, t, e, r, s) => {
  const _ = e0("keccak256").update(Rr.from(n)).digest(), a = Rr.from(Er(e)), c = r.toString(16).padStart(64, "0"), u = Rr.from(c, "hex");
  return t.map((f, w) => {
    const y = uM[f], v = Rr.from([w]), x = e0("keccak256").update(_).update(v).update(a).update(u).digest(), C = new Uint8Array(32);
    if (C.set(x, 0), BigInt(r) > fM)
      throw new Error("ChainId exceeds maximum allowed value (8 bytes)");
    const U = u.slice(24, 32);
    return C[21] = w, U.copy(C, 22), C[30] = y, C[31] = s, C;
  });
}, pM = () => 0;
function hM(n, t, e) {
  const r = /* @__PURE__ */ new Map();
  t.forEach((s, _) => {
    if (r.has(s)) {
      const a = s;
      throw new Error(`Duplicate coprocessor signer address found: ${a} appears multiple times in recovered addresses`);
    }
    r.set(s, _);
  });
  for (const s of t)
    if (!n.includes(s))
      throw new Error(`Invalid address found: ${s} is not in the list of coprocessor signers`);
  return t.length >= e;
}
const wM = (n, t, e, r, s, _, a, c, u) => (l, f) => {
  if (!hr(l))
    throw new Error("Contract address is not a valid address.");
  if (!hr(f))
    throw new Error("User address is not a valid address.");
  const w = cM({
    aclContractAddress: n,
    chainId: e,
    tfheCompactPublicKey: _,
    publicParams: a,
    contractAddress: l,
    userAddress: f
  });
  return {
    _input: w,
    addBool(y) {
      return w.addBool(y), this;
    },
    add8(y) {
      return w.add8(y), this;
    },
    add16(y) {
      return w.add16(y), this;
    },
    add32(y) {
      return w.add32(y), this;
    },
    add64(y) {
      return w.add64(y), this;
    },
    add128(y) {
      return w.add128(y), this;
    },
    add256(y) {
      return w.add256(y), this;
    },
    addBytes64(y) {
      return w.addBytes64(y), this;
    },
    addBytes128(y) {
      return w.addBytes128(y), this;
    },
    addBytes256(y) {
      return w.addBytes256(y), this;
    },
    addAddress(y) {
      return w.addAddress(y), this;
    },
    getBits() {
      return w.getBits();
    },
    encrypt: async () => {
      const y = w.getBits(), v = w.encrypt(), x = {
        contractAddress: jt(l),
        userAddress: jt(f),
        ciphertextWithInputVerification: zi(v),
        contractChainId: "0x" + e.toString(16)
      }, C = {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(x)
      }, U = `${s}/v1/input-proof`;
      let z;
      try {
        const lt = await fetch(U, C);
        if (!lt.ok)
          throw new Error(`Relayer didn't response correctly. Bad status ${lt.statusText}. Content: ${await lt.text()}`);
        try {
          z = await lt.json();
        } catch (Y) {
          throw new Error("Relayer didn't response correctly. Bad JSON.", {
            cause: Y
          });
        }
      } catch (lt) {
        throw new Error("Relayer didn't response correctly.", {
          cause: lt
        });
      }
      const M = lM(v, y, n, e, pM());
      if (z.response.handles && z.response.handles.length > 0) {
        const lt = z.response.handles.map(Er);
        if (M.length != lt.length)
          throw new Error(`Incorrect Handles list sizes: (expected) ${M.length} != ${lt.length} (received)`);
        for (let Y = 0; Y < M.length; Y += 1) {
          let Et = M[Y], Ct = lt[Y], pt = zi(Et), wt = zi(Ct);
          if (pt !== wt)
            throw new Error(`Incorrect Handle ${Y}: (expected) ${pt} != ${wt} (received)`);
        }
      }
      const N = z.response.signatures, I = {
        name: "InputVerification",
        version: "1",
        chainId: r,
        verifyingContract: t
      }, G = {
        CiphertextVerification: [
          { name: "ctHandles", type: "bytes32[]" },
          { name: "userAddress", type: "address" },
          { name: "contractAddress", type: "address" },
          { name: "contractChainId", type: "uint256" }
        ]
      }, D = N.map((lt) => {
        const Y = lt.startsWith("0x") ? lt : `0x${lt}`;
        return d2(I, G, {
          ctHandles: M,
          userAddress: f,
          contractAddress: l,
          contractChainId: e
        }, Y);
      });
      if (!hM(c, D, u))
        throw Error("Coprocessor signers threshold is not reached");
      let L = Ty(M.length);
      const X = N.length;
      return L += Ty(X), M.map((lt) => zi(lt)).map((lt) => L += lt), N.map((lt) => L += lt.slice(2)), {
        handles: M,
        inputProof: Er(L)
      };
    }
  };
}, dM = [
  "function isAllowedForDecryption(bytes32 handle) view returns (bool)"
];
function gM(n, t, e) {
  const r = /* @__PURE__ */ new Map();
  t.forEach((s, _) => {
    if (r.has(s)) {
      const a = s;
      throw new Error(`Duplicate KMS signer address found: ${a} appears multiple times in recovered addresses`);
    }
    r.set(s, _);
  });
  for (const s of t)
    if (!n.includes(s))
      throw new Error(`Invalid address found: ${s} is not in the list of KMS signers`);
  return t.length >= e;
}
const bM = {
  0: "bool",
  2: "uint256",
  3: "uint256",
  4: "uint256",
  5: "uint256",
  6: "uint256",
  7: "address",
  8: "uint256",
  9: "bytes",
  10: "bytes",
  11: "bytes"
};
function yM(n, t) {
  let e = [];
  for (const l of n) {
    const f = l.slice(-4, -2).toLowerCase(), w = parseInt(f, 16);
    e.push(w);
  }
  const r = "0x" + "00".repeat(32) + // dummy requestID (ignored)
  t.slice(2) + "00".repeat(32), s = e.map((l) => bM[l]), c = new Mc().decode(["uint256", ...s, "bytes[]"], r).slice(1, 1 + e.length);
  let u = {};
  return n.forEach((l, f) => u[l] = c[f]), u;
}
const AM = (n, t, e, r, s, _, a) => async (c) => {
  const u = new Pr(s, dM, a);
  let l;
  try {
    l = await Promise.all(c.map(async (j) => {
      const L = zi(typeof j == "string" ? Er(j) : j, !0);
      if (!await u.isAllowedForDecryption(L))
        throw new Error(`Handle ${L} is not allowed for public decryption!`);
      return L;
    }));
  } catch (j) {
    throw j;
  }
  const f = l.map(async (j) => {
    if (!await u.isAllowedForDecryption(j))
      throw new Error(`Handle ${j} is not allowed for public decryption!`);
  });
  await Promise.all(f).catch((j) => {
    throw j;
  }), Mm(l);
  const y = {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      ciphertextHandles: l
    })
  };
  let v, x;
  try {
    if (v = await fetch(`${_}/v1/public-decrypt`, y), !v.ok)
      throw new Error(`Public decrypt failed: relayer respond with HTTP code ${v.status}`);
  } catch (j) {
    throw new Error("Public decrypt failed: Relayer didn't respond", {
      cause: j
    });
  }
  try {
    x = await v.json();
  } catch (j) {
    throw new Error("Public decrypt failed: Relayer didn't return a JSON", {
      cause: j
    });
  }
  if (x.status === "failure")
    throw new Error("Public decrypt failed: the public decrypt didn't succeed for an unknown reason", { cause: x });
  const C = {
    name: "Decryption",
    version: "1",
    chainId: e,
    verifyingContract: r
  }, U = {
    PublicDecryptVerification: [
      { name: "ctHandles", type: "bytes32[]" },
      { name: "decryptedResult", type: "bytes" }
    ]
  }, z = x.response[0], M = z.decrypted_value.startsWith("0x") ? z.decrypted_value : `0x${z.decrypted_value}`, I = z.signatures.map((j) => {
    const L = j.startsWith("0x") ? j : `0x${j}`;
    return d2(C, U, { ctHandles: l, decryptedResult: M }, L);
  });
  if (!gM(n, I, t))
    throw Error("KMS signers threshold is not reached");
  return yM(l, M);
}, mM = (n, t, e) => (r, s, _, a, c) => {
  if (c && !hr(c))
    throw new Error("Invalid delegated account.");
  if (!hr(t))
    throw new Error("Invalid verifying contract address.");
  if (!s.every((v) => hr(v)))
    throw new Error("Invalid contract address.");
  const u = typeof r == "string" ? r.startsWith("0x") ? r : `0x${r}` : r, l = typeof _ == "number" ? _.toString() : _, f = typeof a == "number" ? a.toString() : a, w = [
    { name: "name", type: "string" },
    { name: "version", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "verifyingContract", type: "address" }
  ], y = {
    name: "Decryption",
    version: "1",
    chainId: n,
    verifyingContract: t
  };
  return c ? {
    types: {
      EIP712Domain: w,
      DelegatedUserDecryptRequestVerification: [
        { name: "publicKey", type: "bytes" },
        { name: "contractAddresses", type: "address[]" },
        { name: "contractsChainId", type: "uint256" },
        { name: "startTimestamp", type: "uint256" },
        { name: "durationDays", type: "uint256" },
        {
          name: "delegatedAccount",
          type: "address"
        }
      ]
    },
    primaryType: "DelegatedUserDecryptRequestVerification",
    domain: y,
    message: {
      publicKey: u,
      contractAddresses: s,
      contractsChainId: e,
      startTimestamp: l,
      durationDays: f,
      delegatedAccount: c
    }
  } : {
    types: {
      EIP712Domain: w,
      UserDecryptRequestVerification: [
        { name: "publicKey", type: "bytes" },
        { name: "contractAddresses", type: "address[]" },
        { name: "contractsChainId", type: "uint256" },
        { name: "startTimestamp", type: "uint256" },
        { name: "durationDays", type: "uint256" }
      ]
    },
    primaryType: "UserDecryptRequestVerification",
    domain: y,
    message: {
      publicKey: u,
      contractAddresses: s,
      contractsChainId: e,
      startTimestamp: l,
      durationDays: f
    }
  };
}, SM = () => {
  const n = qv();
  return {
    publicKey: zi(Wv(Qv(n))),
    privateKey: zi(Jv(n))
  };
};
Ac.fetch = lv(Ac.fetch, { retries: 5, retryDelay: 500 });
const MM = async (n) => {
  const { verifyingContractAddressDecryption: t, verifyingContractAddressInputVerification: e, publicKey: r, kmsContractAddress: s, aclContractAddress: _, gatewayChainId: a } = n;
  if (!s || !hr(s))
    throw new Error("KMS contract address is not valid or empty");
  if (!t || !hr(t))
    throw new Error("Verifying contract for Decryption address is not valid or empty");
  if (!e || !hr(e))
    throw new Error("Verifying contract for InputVerification address is not valid or empty");
  if (!_ || !hr(_))
    throw new Error("ACL contract address is not valid or empty");
  if (r && !(r.data instanceof Uint8Array))
    throw new Error("publicKey must be a Uint8Array");
  const c = Gv(n);
  if (!c)
    throw new Error("No network has been provided!");
  const u = await Uv(c, n), l = await Fv(n), f = await Kv(n), w = await Dv(c, n), y = await Lv(c, n), v = await jv(c, n), x = await Vv(c, n);
  return {
    createEncryptedInput: wM(_, e, u, a, tu(n.relayerUrl), l.publicKey, f, v, x),
    generateKeypair: SM,
    createEIP712: mM(a, t, u),
    publicDecrypt: AM(w, y, a, t, _, tu(n.relayerUrl), c),
    userDecrypt: aM(w, a, u, t, _, tu(n.relayerUrl), c),
    getPublicKey: () => l.publicKey ? {
      publicKey: l.publicKey.safe_serialize(hw),
      publicKeyId: l.publicKeyId
    } : null,
    getPublicParams: (C) => f[C] ? {
      publicParams: f[C].publicParams.safe_serialize(ww),
      publicParamsId: f[C].publicParamsId
    } : null
  };
};
let qy = !1;
const xM = async ({ tfheParams: n, kmsParams: t, thread: e } = {}) => (e == null && (e = navigator.hardwareConcurrency), await pv() || (console.warn(`This browser does not support threads. Verify that your server returns correct headers:
`, `'Cross-Origin-Opener-Policy': 'same-origin'
`, "'Cross-Origin-Embedder-Policy': 'require-corp'"), e = void 0), qy || (await Jf({ module_or_path: n }), await vm({
  module_or_path: t
}), e && (wm(), await dm(e)), qy = !0), !0);
export {
  mM as createEIP712,
  MM as createInstance,
  SM as generateKeypair,
  xM as initFhevm
};
